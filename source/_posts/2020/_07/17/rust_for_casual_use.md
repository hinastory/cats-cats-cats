---
title: Rustをカジュアルに使うためのTIPS
thumbnail: /gallery/daily/others/rust-influences.png
categories:
    - Tech
    - Language
tags:
    - Rust
date: 2020-07-17 07:28:45
---

探せば必ずRubyと似た表現がある。それがRustです。


「型のついたRuby」くらいの感覚で

<!-- more -->

## 目次

<!-- toc -->

## はじめに

Rustをカジュアルに始めるには覚えることを絞り、事前の落とし穴を避けることが肝要です。

本記事はRustを普段使いしてみたいと言う人向けです。Rustはシステムプログラミング向けと言われていますが、実際には汎用言語であり大抵のプログラミング用途をこなすことができます。ただ、現実問題としてRustには他の言語ではあまり意識しなくてもいいことに意識を向ける必要があることも事実です。

基本的なデータ構造と制御構造についてセレクトしてみました。


## 整数型は`i32`, `f64`, `usize`を基本に使う

Rustは数値型が多いです。C/C++等を経験していれば気にならないかもしれませんが、そうでない方は戸惑うでしょう。でもカジュアルにRustを使うときには`i32`、`f64`、`usize`を中心に使うと良いでしょう。

`i32`は整数っぽくかけば自然と型推論され、`f64`は小数ぽくかけば型推論されます。きりの良い数値で`f64`と型推論させたい場合は`.0`を付けると良いです。

{% code lang:rust rust %}
let i1 = 10; // `i32`型と型推論される
let f2 = 10.0 // `f64`型と型推論される
{% endcode %}


Rustは型が強いので異なる型の暗黙的な変換は行いません。必要であれば`as`を使ってキャストして演算します。

{% code lang:rust rust %}
let i1 = 3; // `i32`型
let f2 = 2.7; // `f64`型
let bad = i1 * f2 // コンパイルエラー
let good = i1 as f64 * f2 // OK
{% endcode %}


整数リテラルは`i32`型に型推論されることが多いですが、配列やベクターの添字になる場合は`usize`型[^1]になります。
以下のように配列の引数になることが自明な場合は、Rustの型推論は賢いので`usize`型と推論してくれます。

{% code lang:rust rust %}
let u1 = 2; // `usize`型と型推論される
let v2 = vec![1, 2, 3, 4]; // Vec<i32>型
let i3 = v2[u1];
{% endcode %}

しかし以下のように`i32`型の変数を配列の添字に使いたい場合は`as`を使った明示的なキャストが必要です。

{% code lang:rust rust %}
let i1 = 2i32; // 明示的な`i32`型のリテラル
let v2 = vec![1, 2, 3, 4]; // Vec<i32>型
let i2 = v2[i1 as usize]; // 明示的なキャストが必要
{% endcode %}

[^1]: `usize`型はマシンによってサイズが変わる符号なし整数です。

## なるべく固定長配列と静的文字列を避ける

「固定長配列」は文字通り長さが固定された配列です。Rustでは長さを型に含めて区別しています。この固定長配列は以下のように要素の置換は(`mut`であれば)可能ですが、要素の追加は(`mut`であれ)不可能です。それと比較して、動的配列である`Vec`は要素の追加、削除が可能です。

{% code lang:rust rust %}
let mut a1 = [1, 2, 3]; // `[i32;3]`型(固定長配列)
let mut v1 = vec![1, 2, 3]; // `Vec` 型(動的配列)
a1[0] = 10; // 置換、OK
a1.push(4); // 追加、コンパイルエラー
v1[0] = 10; // 置換、OK
v1.push(10); // 追加、OK
{% endcode %}

それではなぜ固定長配列が存在するかというと、ひとえに性能のためです。固定長配列はスタックに確保されるため、メモリの確保と解放のオーバーヘッドが少ないのです。これはシビアに性能を要求されるシステムプログラミング等では重要な性質ですが、カジュアルに使いたい場合は少し面倒です。もちろん相互に変換は可能ですが、使い分けを考えなければ行けない時点でカジュアルには使えません。そこで固定長配列のことは一旦忘れて`Vec`だけを使うようにすれば幸せになれます。ストレスなく快適にプログラミングすることを優先するならこれが良い方法だと思います。

文字列の場合も同様に、動的な文字列型である`String`型に統一しておいたほうが、カジュアルな利用においては挙動の違いに悩まなくて済みます。`String`型の文字列の生成方法にはいくつかありますが、個人的には`owned()`が短くて気に入っています。また、`String`型の文字列の生成には`format!()`も便利です。このマクロは`println!()`と同じく、自由なフォーマットで文字列が出力できるので柔軟に文字列を生成したい場合の強い味方です。`format!()`ほどの自由さはいらず、単に文字列の結合を痛い場合には`join()`もおすすめです。ちなみに`join()`はスライスに実装された関数なので固定長配列にも`Vec`にも使うことができます。

{% code lang:rust %}
let ss1 = "abc"; // `& 'static str`型(静的文字列)
let sd2 = "def".owned(); String型(動的文字列)
let sd3 = format!("{}{}", ss1, sd2); String型(動的文字列)
let sd4 = ["ab", "cd", "df"].join("\n"); String型(動的文字列)
{% endcode %}


## なるべく参照を避ける

参照は上手く使えば性能向上に役立ちますが、カジュアルにプログラミングしたい場合には面倒なケースが多いのも事実です。例えば以下の場合、`t1`の文字列スライス（参照）を作った後に`t1`を`t3`に移動しようとしてエラーになっています[^2]。

{% code lang:rust rust %}
let t1 = "abcdef".to_owned();
let t2  =  &t1[1..3]; // `t2`に文字列スライスを保持(`t1`から借用)
let t3 = t1;  // コンパイルエラー(借用されている`t1`を`t3`に移動しようとしている)
print!("{}", t2);
{% endcode %}

この問題は以下のように文字列スライスから、`String`型の文字列を`to_owned()`関数を用いて作成すれば解消できます。もちろん`to_owned()`は文字列を複製するので性能的なオーバーヘッドは伴いますが、`t1`との依存関係から`t2`は完全に切り離されるので面倒なコンパイルエラーを後々見ずに済みます。

{% code lang:rust rust %}
let t1 = "abcdef".to_owned();
let t2  =  t1[1..3].to_owned(); // 文字列スライスから、`String`型の文字列を生成
let t3 = t1;
print!("{}", t2);
{% endcode %}

もう一つ例をあげます。文字列スライス（参照）を受け取り、文字列スライス（参照）を返す関数も時に厄介なものになります。例えば以下の`print_str()`ように渡された文字列の先頭2文字を返す関数を考えます。

{% code lang:rust rust %}
fn get_first2(s1: &str) -> &str {
    s1[..2] //  渡された文字列の最初の2文字を返す
}
{% endcode %}

上記の関数は問題なくコンパイルできますが、引数の文字列スライスが２つになると面倒になります。以下の`get_first2_max()`は如何にもコンパイルが通りそうですがコンパイルエラーになります。

{% code lang:rust rust %}
fn get_first2_max(s1: &str, s2: &str) -> &str { // コンパイルエラー
    if s1.len() > s2.len() {
        &s1[..2]
    } else {
        &s2[..2]
    }
}
{% endcode %}





ちなみに文字列を受け取る関数では以下の`print_str()`のように文字列スライスを受け取るような関数も目にしますが、文字列スライスも参照の一種なので

それはこのように定義しておくことで静的文字列も動的文字列(String)も受け取れるからです。しかしこの場合は呼び出しに違いが出て、String型で渡す場合には参照(`&sd2`)で渡す必要があります。

{% code lang:rust rust %}
fn print_str(s: &str) {
    println!("{}", s);
}

fn main(){
    let ss1 = "hoge"; // 静的文字列
    let sd2 = "mohe".to_owned(); // 動的文字列
    print_str(ss1);
    print_str(&sd2);
}
{% endcode %}

しかし、`String`を基本に使うようにしておけば関数を定義するときに迷う必要はありません。以下のように引数は常に`String`型を用いればOKです。文字列スライスは参照の一種なので関数呼び出し時のオーバーヘッドが低いと思われる方がいるかもしれませんが、`String`自体がスマートポインタなので関数の受け渡しのオーバーヘッドはスライスとほとんど変わりません。

{% code lang:rust rust %}
fn print_str2(s: String) { // 引数にString型を用いる
    println!("{}", s);
}

fn main(){
    let sd2 = "mohe".to_owned(); // 動的文字列
    print_str(sd2); //ここでsd2の所有権は`print_str()`に移る
    // ここではもう`sd2`は使えない
}
{% endcode %}

もちろん上記のコードでは、`sd2`の所有権は`print_str()`に移るので


{% code lang:rust rust %}
fn print_str2(s: String) { // 引数にString型を用いる
    println!("{}", s);
}

fn main(){
    let sd2 = "mohe".to_owned(); // 動的文字列
    let sd3 = sd2.clone();
    print_str(sd2); //ここでsd2の所有権は`print_str()`に移る
    // ここではもう`sd3`は使う
}
{% endcode %}


Rustの所有権は難しいとよく言われますが、その難しさの多くに「参照」が絡んでいます。ライフタイムの難しさもそうですが**「借用チェッカー」**が非常に手強いのです。そのことを踏まえるRustをカジュアルに使うためにはなるべく参照を使わずにすむ方法が一番です。そのためには、`to_owned()`等を使って複製してしまうのが一番手っ取り早いということは覚えておいたほうが良いでしょう[^4]。


[^2]: 実はここでは`t1`を`String`型の文字列にしているため、「ムーブセマンティクス」になりコンパイルエラーになりますが、静的文字列になれば「コピーセマンティクス」になるためエラーにはなりません。ここは静的文字列が便利なところですが、ここでは一般的にムーブセマンティクスと参照を組み合わせたときに起きやすい例として`String`型の例を挙げております。


## `mut`は最低限に抑える

`mut`は非常に便利です。変数や値を書き換えることができることは、多くのプログラマにとっては直感的で理解しやすいものです。しかし、変数の値がころころと書き換わってしまうとプログラムが把握しづらくなってしまうというのも事実です。例えば以下の例では変数`a`を途中で2回変更していますが、そのことをついうっかり忘れてしまうと思わぬバグに繋がります。

{% code lang:rust rust %}
let mut a = 2;
...
a = -1; // ここを見落としやすい
...
a = 3; // ここを見落としやすい
...
let x = a + 1;
println!("{}", x); // 4
{% endcode %}

この場合は変数名を変えて導入すると間違いが起こりにくくなります[^3]。

{% code lang:rust rust %}
let a = 2;
...
let b = -1;
...
let c = 3;
...
let x = c + 1;
println!("{}", x); // 4
{% endcode %}

個人的に`mut`の利用が妥当だと思われる一番のシーンはコレクションへの要素の追加・削除や書き換えです。`mut`を利用しない、いわゆるイミュータブルな状態は分かりやすいのは確かですが、さすがにコレクションの追加や変更のたびに全体を複製してイミュータブルを保つのはコストが高いのでこれは妥協できる点だと思います。

{% code lang:rust rust %}
let mut v1 = vec![1, 2, 3]; // 変更可能なベクタ
v1.push(4); // `mut`のおかげで要素の追加が可能
v1[0] = -1; // `mut`のおかげで要素の変更が可能
println!("{:?}",v1);
{% endcode %}

また文字列もコレクションの一種です。文字列の最後に別の文字列をくっつけることはよくやる操作だと思いますが、この`mut`の使い方も妥当な範囲だと思います。

{% code lang:rust rust %}
let mut s1 = "abc"; // 変更可能な文字列
s1.push_str("def"); // `mut`のおかげで要素の追加が可能
println!("{}",s1);
{% endcode %}

ちなみに`mut`と参照が組み合わさると厄介な問題を引き起こします。以下の例はコンパイルエラーになりますが、それはミュータブルな参照とイミュータブルな参照が同時に存在したために起こった悲劇です。このようなコードは特定の場面で問題を起こすことが知られておりRustは事前にコンパイル時点でチェックしてくれているわけですが、カジュアルにRustを使いたい場合にはこのようなコンパイルエラーでされ息苦しいものです。

{% code lang:rust %}
let mut t1 = vec![1, 2, 3];
let t2 = &mut t1[1..3];
t2[0] = -1;
let t3 = &t1[2..3]; // コンパイルエラー
println!("{:?}", t2); // ここで`t2`を利用しようとしたのが問題
{% endcode %}


[^3]: Rustの場合、同一スコープのシャドーイングを用いることもできますが、本質的に同じ変数でないと混乱を増長する結果になるので利用には慎重になったほうが良いと思われます。
[^4]: `to_owned()`を用いて複製できるのは`Clone`トレイトを実装している参照だけですが、Rustの多くの型が`Clone`を実装しているので`to_owned()`が使えないケースはそれほど多くはないと思われます。

## 4つのコレクションを活用する

Rustはコレクション周りが非常に充実していますが、基本的に4つのコレクション(`String`, `Vec`, `HashMap`, タプル)を押さえておけば普段使いのプログラミングで困ることはそれほどありません。Rustのコレクションで気をつけるべきは、コレクションが**インデックス**として使えるのか、**スライス**として使えるのか、***イテレータ**として使えるのかを把握しておくことです。

| コレクション | インデックス | スライス | イテレータ |
| ------------ | ------------ | -------- | ---------- |
| `String`     | -            | o        | o          |
| `Vec`        | o            | o        | o          |
| `HashMap`    | o            | -        | o          |
| タプル `()`  | -            | -        | -          |


{% code lang:rust rust %}
let v1 = vec![1, 2, 3, 4, 5];
let i2 = v1[2]; // インデックス(i2 = 3)
let v3 = &v1[1..3]; // スライス（v3 = [2, 3]）

// イテレータ(明示的に変換)
v1.iter().for_each(|i| println!("{}", i));

// イテレータ(`for`で暗黙的に利用)
for i in v1 {
    println!("{}", i);
}
{% endcode %}



## カジュアルに`unwrap`を使う


## 性能や再利用性のための機能は使わない

最後にざっくりですが、Rustをカジュアルに使う上で必要な指針を述べておきます。一番大事なのは使わない機能を予め決めておくことです。Rustはシステムプログラミングを効率的に行うために非常に多くの機能が実装されていますが、性能や再利用性を考慮しなければ必要ないものも多くあります。従って、LL言語的な感覚で軽めにRustを使いたい場合は以下のように利用しない機能を決めておくことでプログラムに無用な複雑さを取り入れたり、落とし穴にハマったりする可能性を下げられます。

- `unsafe`を利用しない
- ジェネリックな関数は定義しない
    - 利用はもちろんOK
- マクロを定義しない
- トレイトを定義しない
    - 構造体はOKだがジェネリックにしない
- トレイトオブジェクトを利用しない

## まとめ

気負わないRust
体たらくなRust
ゆるふわRust

実用的なサブセット

最初から足がつかないところで溺れるよりも、足がつくところから少しずつ


低レベルのレイヤーを意識したプログラミングを強いられる。
富豪的プログラミング(死語)も可能であり、Rustを「型付きのRuby」のような感覚で使うことができます。

ライフタイムががが・・・とか唸らなくても住むのです。


ここに書いてあることはRustという言語の本来の生まれた経緯からすると邪道でバッドノウハウ的なものも含まれているからです。

関数型プログラミングと関連が深く

寛容さ

## 参考文献

- [std::iter::Iterator - Rust](https://doc.rust-lang.org/std/iter/trait.Iterator.html)
- [std::vec::Vec - Rust](https://doc.rust-lang.org/std/vec/struct.Vec.html)
- [slice - Rust](https://doc.rust-lang.org/std/primitive.slice.html)