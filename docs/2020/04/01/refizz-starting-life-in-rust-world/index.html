<!doctype html>
<html lang="ja"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>Re：FizzBuzzから始めるRust生活 - cats cats cats</title><link rel="manifest" href="/cats-cats-cats/manifest.json"><meta name="application-name" content="cats cats cats"><meta name="msapplication-TileImage" content="/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="cats cats cats"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="新しいプログラミング言語に入門するためには、やはり手を動かすことが大事です。本を読んで体系的に学ぶのももちろん重要ですが、それは言語の魅力を知ってからでも遅くはありません。 しかし「Hello World」レベルだと簡単すぎて言語の違いを味わえず、ネットワークプログラミングのような高度なプログラミングはフレームワークの力が大きすぎて言語とフレームワークの狭間で立ち往生することになります。 そこで登"><meta property="og:type" content="article"><meta property="og:title" content="Re：FizzBuzzから始めるRust生活"><meta property="og:url" content="https://hinastory.github.io/cats-cats-cats/2020/04/01/refizz-starting-life-in-rust-world/"><meta property="og:site_name" content="cats cats cats"><meta property="og:description" content="新しいプログラミング言語に入門するためには、やはり手を動かすことが大事です。本を読んで体系的に学ぶのももちろん重要ですが、それは言語の魅力を知ってからでも遅くはありません。 しかし「Hello World」レベルだと簡単すぎて言語の違いを味わえず、ネットワークプログラミングのような高度なプログラミングはフレームワークの力が大きすぎて言語とフレームワークの狭間で立ち往生することになります。 そこで登"><meta property="og:locale" content="ja_JP"><meta property="og:image" content="https://hinastory.github.io/cats-cats-cats/gallery/thumbnails/rust.png"><meta property="article:published_time" content="2020-03-31T22:28:45.000Z"><meta property="article:modified_time" content="2021-02-13T01:27:59.467Z"><meta property="article:author" content="hinastory"><meta property="article:tag" content="Rust"><meta property="article:tag" content="FizzBuzz"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://hinastory.github.io/cats-cats-cats/gallery/thumbnails/rust.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://hinastory.github.io/cats-cats-cats/2020/04/01/refizz-starting-life-in-rust-world/"},"headline":"Re：FizzBuzzから始めるRust生活","image":["https://hinastory.github.io/cats-cats-cats/gallery/thumbnails/rust.png"],"datePublished":"2020-03-31T22:28:45.000Z","dateModified":"2021-02-13T01:27:59.467Z","author":{"@type":"Person","name":"hinastory"},"publisher":{"@type":"Organization","name":"cats cats cats","logo":{"@type":"ImageObject","url":"https://hinastory.github.io/gallery/profile/cats-cats-cats-logo.png"}},"description":"新しいプログラミング言語に入門するためには、やはり手を動かすことが大事です。本を読んで体系的に学ぶのももちろん重要ですが、それは言語の魅力を知ってからでも遅くはありません。 しかし「Hello World」レベルだと簡単すぎて言語の違いを味わえず、ネットワークプログラミングのような高度なプログラミングはフレームワークの力が大きすぎて言語とフレームワークの狭間で立ち往生することになります。 そこで登"}</script><link rel="canonical" href="https://hinastory.github.io/cats-cats-cats/2020/04/01/refizz-starting-life-in-rust-world/"><link rel="alternate" href="/cats-cats-cats/cats-cats-cats/atom.xml" title="cats cats cats" type="application/atom+xml"><link rel="icon" href="/cats-cats-cats/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/vs2015.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/cats-cats-cats/css/default.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><!--!--><!--!--><script src="https://www.googletagmanager.com/gtag/js?id=UA-132406459-1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-132406459-1');</script><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/cats-cats-cats/"><img src="/cats-cats-cats/gallery/profile/cats-cats-cats-logo.png" alt="cats cats cats" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/cats-cats-cats/"><i class="fa fa-home mr-1"></i> Home</a><a class="navbar-item" href="/cats-cats-cats/archives"><i class="fas fa-archive fa-fw mr-1"></i> Archives</a><a class="navbar-item" href="/cats-cats-cats/categories"><i class="fas fa-cat fa-fw mr-1"></i> Categories</a><a class="navbar-item" href="/cats-cats-cats/tags"><i class="fas fa-tags fa-fw mr-1"></i> Tags</a><a class="navbar-item" href="/cats-cats-cats/about"><i class="undefined mr-1"></i> About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="カタログ" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="検索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container is-fluid"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><h1 class="title is-3 is-size-4-mobile">Re：FizzBuzzから始めるRust生活</h1><div class="article-meta is-size-7 level is-mobile"><div class="level-left"><span class="level-item"><i class="mr-1 fas fa-calendar-alt"></i><span>2020-04-01</span></span><span class="level-item"><i class="mr-1 fas fa-cat"></i><a class="link-muted" href="/cats-cats-cats/categories/Tech/">Tech</a><span> / </span><a class="link-muted" href="/cats-cats-cats/categories/Tech/Language/">Language</a></span><span class="level-item"><i class="fas fa-tags"></i><span><a class="link-muted ml-1" rel="tag" href="/cats-cats-cats/tags/Rust/">Rust</a>, <a class="link-muted ml-1" rel="tag" href="/cats-cats-cats/tags/FizzBuzz/">FizzBuzz</a></span></span></div></div><div class="card-image"><span class="image is-7by3"><img class="cover-image" src="/cats-cats-cats/gallery/thumbnails/rust.png"></span></div><div class="content"><p>新しいプログラミング言語に入門するためには、やはり手を動かすことが大事です。本を読んで体系的に学ぶのももちろん重要ですが、それは言語の魅力を知ってからでも遅くはありません。</p>
<p>しかし「Hello World」レベルだと簡単すぎて言語の違いを味わえず、ネットワークプログラミングのような高度なプログラミングはフレームワークの力が大きすぎて<strong>言語とフレームワークの狭間で立ち往生</strong>することになります。</p>
<p>そこで登場するのが<strong>「FizzBuzz」</strong>です。「FizzBuzz」は単純なプログラムでありながら、プログラムの真髄である<strong>「順次」</strong>、<strong>「分岐」</strong>、<strong>「繰り返し」</strong>があり、数値計算も学べる興味深い題材です。</p>
<p>その「FizzBuzz」を利用して<strong>「Rust」</strong>という言語を学んでみようのが本記事の趣旨です。「FizzBuzz」というシンプルなプログラムで「Rust」のような<strong>表現力が豊かな言語</strong>の機能をどこまで使い尽くせるのかは興味が尽きないところですが、本記事では入門という観点で初歩的なFIzzBuzzから順を追って体を慣らしながらRustのある生活を体験できるようにしたいと思います。</p>
<p>さぁ、FizzBuzzからRust生活を始めましょう。</p>
<span id="more"></span>
<h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>本記事は、すでに何らかのプログラミング言語の経験を持っているRust初心者を対象としています。特になんとなく<strong>「Rust怖い」</strong>感じている方に対して、Rustの普段使いの魅力をFizzBuzzのようなシンプルな題材を通してお伝えできればと思います。</p>
<h2 id="前提知識"><a href="#前提知識" class="headerlink" title="前提知識"></a>前提知識</h2><p>まずは前提知識としてFizzBuzzプログラムとRust言語の特徴を簡単に説明します。すでにご存知の方はこの節は飛ばして頂いても構いません。</p>
<h3 id="FizzBuzzプログラムとは"><a href="#FizzBuzzプログラムとは" class="headerlink" title="FizzBuzzプログラムとは"></a>FizzBuzzプログラムとは</h3><p>FizzBuzzプログラムは、3で割り切れる場合に「<strong>Fizz</strong>」と表示し、5で割り切れる場合に「<strong>Buzz</strong>」と表示し、両者で割り切れる（15で割り切れる）場合には「<strong>FizzBuzz</strong>」と表示するプログラムです。1から16の数値の入力に対する出力は以下のようになります。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">1<br>2<br>Fizz<br>4<br>Buzz<br>Fizz<br>7<br>8<br>Fizz<br>Buzz<br>11<br>Fizz<br>13<br>14<br>FizzBuzz<br>16<br></code></pre></td></tr></tbody></table></figure>

<p>本記事では1から100までの数字を上記のルールで変換して画面に出力するFizzBuzzプログラムを扱います。</p>
<h3 id="Rustとは"><a href="#Rustとは" class="headerlink" title="Rustとは"></a>Rustとは</h3><p>RustはMozilla<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>が支援するオープンソースのプログラミング言語です。<a href="https://www.rust-lang.org/ja/" title="" target="_blank">Rust公式サイト<i class="fas fa-external-link-alt fa-fw"></i></a>から引用すると以下の３つの特徴があります。</p>
<ul>
<li>パフォーマンス<ul>
<li>Rustは非常に高速でメモリ効率が高くランタイムや<strong>ガベージコレクタがない</strong>ため、パフォーマンス重視のサービスを実装できますし、組込み機器上で実行したり他の言語との調和も簡単にできます。</li>
</ul>
</li>
<li>信頼性<ul>
<li>Rustの豊かな型システムと所有権モデルにより<strong>メモリ安全性とスレッド安全性が保証</strong>されます。さらに様々な種類のバグをコンパイル時に排除することが可能です。</li>
</ul>
</li>
<li>生産性<ul>
<li>Rustには優れたドキュメント、有用なエラーメッセージを備えた使いやすいコンパイラ、および統合されたパッケージマネージャとビルドツール、多数のエディタに対応するスマートな自動補完と型検査機能、自動フォーマッタといった<strong>一流のツール群が数多く揃っています</strong>。</li>
</ul>
</li>
</ul>
<p>Rustを利用しているユーザにはMozillaはもちろん<strong>Dropbox</strong>や<strong>AWS</strong>や<strong>Microsoft</strong>などの著名企業も含まれるので、今後も安定して開発やメンテナンスが行われる言語だと考えられます。</p>
<p>向いている用途としてはシステムプログラミングが挙げられ、OSやデータベース等のミドルウェアの開発に適しています。個人的には<strong>C/C++やGo言語が向いている用途にはRustも適している</strong>と考えています。特に性能を要求されるプログラムには向いています。以下は<a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/which-programs-are-fastest.html" title="" target="_blank">Computer Language Benchmarks Game<i class="fas fa-external-link-alt fa-fw"></i></a>からの引用ですが、Rustの性能がC/C++と同等であることが示されています。</p>
<img src="/cats-cats-cats/gallery/daily/others/fastest.png" class="" width="370"><img src="/cats-cats-cats/gallery/daily/others/fastest-more.png" class="" width="370">


<p>向いていない用途としては、RubyやPythonのようにプログラムを書いてすぐに実行するような軽量的な使い方です。Rustは必ずコンパイルする作業が発生し、しかもコンパイラのチェックが比較的厳しいので<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>「正しい」プログラムを書くのに時間がかかります。これはある程度大きな開発時にはメリットともとれますが、<strong>アイデアをプログラムで緩く試したい場合には不向き</strong>なので用途で使い分ける必要があります。</p>
<h2 id="第一章-Rust生活-初級編"><a href="#第一章-Rust生活-初級編" class="headerlink" title="第一章 Rust生活:初級編"></a>第一章 Rust生活:初級編</h2><p>さて、ここからが本題のRust生活です。１日にひとつのFizzBuzzを紹介するというスタイルで書いています。後半に行くほど難しくなっているので、自分のレベルに合った箇所から読み進めて頂いても構いません。</p>
<p>また、FizzBuzzプログラムのスタイルとしては関数として記述しています。実際にコンパイルして実行するには以下のように<code>main</code>関数の中から呼び出す必要があります。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {<br>    <span class="hljs-title function_ invoke__">fizz_buzz1</span>()<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>各ソースコードには<strong>「Run」</strong>のリンクが貼ってあるので具体的にはそのソースコードを見て実行してみるとより挙動が分かると思います。</p>
<h3 id="1日目-〜FizzBuzzでwhileとifに再会する〜"><a href="#1日目-〜FizzBuzzでwhileとifに再会する〜" class="headerlink" title="1日目 〜FizzBuzzでwhileとifに再会する〜"></a>1日目 〜FizzBuzzでwhileとifに再会する〜</h3><p>まずは多くの方が理解できる形のFizzBuzzから始めたいと思います。以下のRustプログラムは多少文法が異なっていてもC/C++やJava等の手続き的なパラダイムを持つ言語を経験した方ならすんなりと読めると思います。</p>
<figure class="highlight rust"><figcaption><span>fizz_buzz1(rust)</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">fizz_buzz1</span>() { <span class="hljs-comment">// Rustの関数定義（引数なし、戻り値なし）</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">x</span> = <span class="hljs-number">1</span>; <span class="hljs-comment">// xという変数を導入して整数1に束縛</span><br><br>  <span class="hljs-keyword">while</span> x &lt;= <span class="hljs-number">100</span> { <span class="hljs-comment">// xが100以下の場合に中括弧`{}`で囲まれたスコープを繰り返す</span><br>    <span class="hljs-keyword">if</span> x % <span class="hljs-number">15</span> == <span class="hljs-number">0</span> {       <span class="hljs-comment">// 15で割り切れる（15で割った余りが0）</span><br>	  <span class="hljs-built_in">println!</span>(<span class="hljs-string">"FizzBuzz"</span>);<br>	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> x % <span class="hljs-number">3</span> == <span class="hljs-number">0</span> { <span class="hljs-comment">// 3で割り切れる（3で割った余りが0）</span><br>	  <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Fizz"</span>);<br>	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> x % <span class="hljs-number">5</span> == <span class="hljs-number">0</span> { <span class="hljs-comment">// 5で割り切れる（5で割った余りが0）</span><br>	  <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Buzz"</span>);<br>	} <span class="hljs-keyword">else</span> {               <span class="hljs-comment">// それ以外の場合は数字を直接出力</span><br>	  <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, x);<br>    }<br><br>    x += <span class="hljs-number">1</span>; <span class="hljs-comment">// xに1を加算</span><br>  }<br>}<br></code></pre></td></tr></tbody></table></figure>
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=d761b62e11b5f019ee0cba90f6edaf80" title="" target="_blank">Run<i class="fas fa-external-link-alt fa-fw"></i></a>

<p>　<br>まず、1行目は<code>fn</code>で始まる関数宣言です。<strong>fizz_buzz1</strong>という関数を定義しています。関数名はこのようにアンダースコア(<code>_</code>)で区切った小文字の<strong>スネークケース</strong>で書くのがRustのコーディング規約になっています。この関数は引数を持っていませんが戻り値は一応あります。戻り値は<strong>ユニット</strong><code>()</code>になります。ユニットは意味を持たない値の代表として用いられます。</p>
<p>2行目の<code>let</code>で始まる文は<strong>宣言文</strong>と呼ばれており、関数のスコープに変数<code>x</code>を導入して整数1に束縛しています。<code>mut</code>キーワードは<code>mutable</code>の略であり、この変数が再代入可能であることを示しています。再代入が可能になるとプログラムの挙動の把握が難しくなるので<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>、不必要な箇所では<code>mut</code>をつけないことがRustの基本です。</p>
<p>さらに、2行目は型推論により変数の型が省略されています。省略せずに書くと以下のようになります。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">x</span>: <span class="hljs-type">i32</span> = <span class="hljs-number">1</span>;<br></code></pre></td></tr></tbody></table></figure>

<p>「i32」は32ビットの符号付き整数を意味しています。またRustは静的型付言語なので全ての変数には「型」がついていますが、型推論のおかげて必要以上の型を記述せずにすみます。ちなみに再代入可能な変数であっても変数の型は変更できません。つまり以下のようになります。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">x</span>: <span class="hljs-type">i32</span> = <span class="hljs-number">1</span>;<br>x = <span class="hljs-number">10</span>;  <span class="hljs-comment">// OK (i32型の数値の再代入)</span><br>x = <span class="hljs-number">3.5</span>; <span class="hljs-comment">// NG (コンパイルエラー： i32型の変数にf64型の数値の再代入)</span><br></code></pre></td></tr></tbody></table></figure>
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=9ea9449eb2f5e43a2bf2c9920ad7954f" title="" target="_blank">Run<i class="fas fa-external-link-alt fa-fw"></i></a>
<p>　<br>ちなみに以下のようにletを用いて同じ変数を再初期化してあげれば異なる型の数値への束縛が可能です。この機能は<strong>シャドーイング</strong>と呼ばれています<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">x</span>: <span class="hljs-type">i32</span> = <span class="hljs-number">1</span>;<br>x = <span class="hljs-number">10</span>;  <span class="hljs-comment">// OK (i32型の数値の再代入)</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">x</span> = <span class="hljs-number">3.5</span>; <span class="hljs-comment">// OK (f64型の数値の再宣言)</span><br>x = <span class="hljs-number">10</span>;  <span class="hljs-comment">// NG (コンパイルエラー：f64型の数値にi32型の数値の再代入)</span><br></code></pre></td></tr></tbody></table></figure>
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=4cea6611bcfc709cd6f6cc3602011bd0" title="" target="_blank">Run<i class="fas fa-external-link-alt fa-fw"></i></a>
<p>　<br>次に<code>while</code>と<code>if</code>ですがこれの機能は他の言語と同等の機能をもっています。<code>while</code>は条件付き繰り返しで、<code>if</code>は条件分岐です。付け加えるとするならこれらは両方とも<code>式</code>であり、評価された値を持ちます。<code>while</code>は必ずユニット<code>()</code>値を返します。<code>if</code>は条件分岐の評価結果を返します。このあとで説明する<code>println!(...)</code>は全てユニット値を返すので、この関数内で使われている<code>if</code>もユニット値を返します。</p>
<p>次の要素は「<code>println!</code>」マクロです。関数っぽく見えますが名前の最後の「<code>!</code>」がマクロであることを示しています。Rustの関数には可変長引数がないのでマクロを使って実現されています<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>。呼び出し側は呼び出し先が関数かマクロかはあまり気を使う必要がないので、入門の段階では気にしなくても問題はありません。println!マクロでは表示する文字列に変数を埋め込むことができます。「<code>{}</code>」はプレースホルダになっていて以下のように複数利用することもできます。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">from</span> = <span class="hljs-string">"FizzBuzz"</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">lang</span> = <span class="hljs-string">"Rust"</span>;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"Re:{} Starting Life in {} World!"</span>, from, lang); <span class="hljs-comment">// 「Re:FizzBuzz Starting Life in Rust World!」と表示される。</span><br></code></pre></td></tr></tbody></table></figure>
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=3fc5a8f22c6c1525190d576946583a50" title="" target="_blank">Run<i class="fas fa-external-link-alt fa-fw"></i></a>
<p>　<br> 1日目の最後の説明は<code>x += 1</code>についてです。この式は他の言語と同じく<code>x = x + 1</code>のシンタックスシュガーです。つまり再代入の処理になります。Rustでは再代入は<code>mut</code>をつけて宣言された変数にしか許可されませんが、<code>x</code>は<code>mut</code>付きで宣言されているのでこのように再代入が可能です。ちなみにRustにはインクリメント演算子(<code>++</code>)は用意されていません。</p>
<h3 id="2日目-〜FizzBuzzでforとrangeに出会う〜"><a href="#2日目-〜FizzBuzzでforとrangeに出会う〜" class="headerlink" title="2日目 〜FizzBuzzでforとrangeに出会う〜"></a>2日目 〜FizzBuzzでforとrangeに出会う〜</h3><p>1日目のプログラムで<code>FizzBuzz</code>は問題なく動作します。しかし、<code>while</code>の条件判定と<code>x += 1</code>を組み合わせてループを行うのは些か面倒です。でもご安心ください。Rustにはループの強い味方、<code>for</code>とレンジ(範囲)があります。</p>
<figure class="highlight rust"><figcaption><span>fizz_buzz2(rust)</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">fizz_buzz2</span>() {<br>  <span class="hljs-keyword">for</span> <span class="hljs-variable">x</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span> .. <span class="hljs-number">101</span> { <span class="hljs-comment">// 1から100まで繰り返す</span><br>    <span class="hljs-keyword">if</span> x % <span class="hljs-number">15</span> == <span class="hljs-number">0</span> {<br>      <span class="hljs-built_in">println!</span>(<span class="hljs-string">"FizzBuzz"</span>);<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> x % <span class="hljs-number">3</span> == <span class="hljs-number">0</span> {<br>      <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Fizz"</span>);<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> x % <span class="hljs-number">5</span> == <span class="hljs-number">0</span> {<br>      <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Buzz"</span>);<br>    } <span class="hljs-keyword">else</span> {<br>      <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, x);<br>    }<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure>
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=e86db7a58f89d96fd8fd39e7e8afcc95" title="" target="_blank">Run<i class="fas fa-external-link-alt fa-fw"></i></a>
<p>　<br><code>for a in b</code>の構文は<code>b</code>で<strong>「イテレータ」</strong>を受け取り、「イテレータ」が返す値を順番に直後のブロック内において<code>a</code>という変数で利用可能にします。イテレータは <code>.next()</code> メソッドを繰り返し呼び出すことができ、その都度順番に値を返します。</p>
<p><code>a .. b</code>はレンジであり、<code>a</code>以上<code>b</code>未満を表しています。上記のプログラムでは<code>1 .. 101</code>になっているので1以上101未満になります。「未満」なので終端の数字は含まないことに注意してください。終端を含めたい場合、つまり<code>a</code>以上<code>b</code>以下を表したい場合は<code>a ..= b</code>とします。レンジはイテレータにもなっているので、<code>for</code>で用いることができます。</p>
<h3 id="3日目-〜FizzBuzzでmatchにときめく〜"><a href="#3日目-〜FizzBuzzでmatchにときめく〜" class="headerlink" title="3日目 〜FizzBuzzでmatchにときめく〜"></a>3日目 〜FizzBuzzでmatchにときめく〜</h3><p>2日目のプログラムで<code>for</code>を導入して大分いい感じになりましたが、まだ冗長な点が目に止まります。<code>if</code>式です。<code>else if</code>を繰り返し書いているのでもう少し短く書きたいものです。そこで登場するのが<code>match</code>です。</p>
<figure class="highlight rust"><figcaption><span>fizz_buzz3(rust)</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">fizz_buzz3</span>() {<br>  <span class="hljs-keyword">for</span> <span class="hljs-variable">x</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span> ..= <span class="hljs-number">100</span> {<br>    <span class="hljs-keyword">match</span> x % <span class="hljs-number">15</span> {   <span class="hljs-comment">// パターンマッチを利用してxの15による剰余を分類</span><br>      <span class="hljs-number">0</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"FizzBuzz"</span>),     <span class="hljs-comment">// 単式パターン</span><br>      <span class="hljs-number">3</span> | <span class="hljs-number">6</span> | <span class="hljs-number">9</span> | <span class="hljs-number">12</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Fizz"</span>), <span class="hljs-comment">// 複式パターン</span><br>      <span class="hljs-number">5</span> | <span class="hljs-number">10</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Buzz"</span>),<br>      _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, x),        <span class="hljs-comment">// ワイルドカードパターン</span><br>    }<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure>
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c4b493bb208a03883d8ccd1d4cb19672" title="" target="_blank">Run<i class="fas fa-external-link-alt fa-fw"></i></a>
<p>　<br><code>match a {b}</code>の構文では、<code>a</code>の式を評価した結果を<code>b</code>のパターンで網羅的に分類できます。<code>b</code>のパターンは<code>p =&gt; v</code>の形式(これはアームとも呼ばれます)でカンマ<code>,</code>で区切って複数並べることができ、上から順番に<code>p</code>のパターンにマッチングするか検査されます。マッチングが成立すると<code>v</code>が実行されてその評価値が<code>match</code>式の評価値となります。</p>
<p><code>p</code>のパターンでは一つの値だけではなく<code>|</code>で区切って、複数の値にマッチングさせることもできます。例えば上記でいけば<code>3 | 6 | 9 | 12</code>は「3または6または9または12」の意味になります。またパターンにアンダースコア<code>_</code>を用いると<strong>ワイルドカードパターン</strong>になり、全ての値にマッチングします。パターンは上のほうが優先順位が高いのでワイルドカードパターンは通常一番下に置かれます。</p>
<p>上記の例だけ見ると<code>match</code>は単に<code>if</code>のシンタックスシュガーのように見えてしまいますが、実は大きく異なります。そのひとつに<code>match</code>では網羅性検査が行われる点があります。例えば以下のようにワイルドカードパターンを<code>99</code>に置き換えてコンパイルしてみます。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">match</span> x % <span class="hljs-number">15</span> {   <span class="hljs-comment">// パターンマッチを利用してxの15による剰余を分類</span><br>  <span class="hljs-number">0</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"FizzBuzz"</span>),<br>  <span class="hljs-number">3</span> | <span class="hljs-number">6</span> | <span class="hljs-number">9</span> | <span class="hljs-number">12</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Fizz"</span>),<br>  <span class="hljs-number">5</span> | <span class="hljs-number">10</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Buzz"</span>),<br>  <span class="hljs-number">99</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, x),  <span class="hljs-comment">// `_` から `99`に変更</span><br>}<br></code></pre></td></tr></tbody></table></figure>

<p>するとコンパイルエラーになり、以下のように色付きでわかりやすくエラーが表示されます。</p>
<img src="/cats-cats-cats/gallery/daily/others/non-exhaustive-patterns.png" class="">
<p>　<br>「non-exhaustive patterns」はパターンが網羅的でないというエラーです。パターンの網羅性はマッチング対象の型の値域を網羅しているかどうかで判断されます。この場合<code>x</code>はi32型で符号付き32ビット整数なので値域はstd::i32::MIN(−2,147,483,648)〜std::i32::MAX(2,147,483,647)になります。<code>std::i32::MIN</code>と<code>std::i32::MIN</code>はRustで定義されている定数で符号付き32ビット整数の最小値と最大値を表しています。</p>
<p>「patterns <code>std::i32::MIN..=-1i32</code>, <code>1i32..=2i32</code>, <code>4i32</code> and 3 more not covered」は、std::i32::MINから-1までと1から2までと４がカバーされておらず、さらに3つ以上カバーされていないものがあると言っています。このようにRustはエラーメッセージが丁寧で具体的にカバーできていない範囲をエラーメッセージが教えてくれます。</p>
<h3 id="4日目-〜FizzBuzzでガードを覚える〜"><a href="#4日目-〜FizzBuzzでガードを覚える〜" class="headerlink" title="4日目 〜FizzBuzzでガードを覚える〜"></a>4日目 〜FizzBuzzでガードを覚える〜</h3><p>3日目のプログラムで<code>if</code>を<code>match</code>でスマートに置き換えることに成功しました。しかし、また別の不満が出てきました。”3 | 6 | 9 | 12”のように3の倍数を列挙するのではなく、2日目のプログラムのように”x % 3 == 0”といた形で「余りが0」で３の倍数を表現したいのです。そこで<strong>パターンガード</strong>の出番です。</p>
<figure class="highlight rust"><figcaption><span>fizz_buzz4(rust)</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">fizz_buzz4</span>() {<br>  <span class="hljs-keyword">for</span> <span class="hljs-variable">x</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span> ..= <span class="hljs-number">100</span> {<br>    <span class="hljs-keyword">match</span> x {<br>      e <span class="hljs-keyword">if</span> e % <span class="hljs-number">15</span> == <span class="hljs-number">0</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"FizzBuzz"</span>), <span class="hljs-comment">// 変数パターンとパターンガードを用いたパターン</span><br>      e <span class="hljs-keyword">if</span> e % <span class="hljs-number">3</span> == <span class="hljs-number">0</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Fizz"</span>),<br>      e <span class="hljs-keyword">if</span> e % <span class="hljs-number">5</span> == <span class="hljs-number">0</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Buzz"</span>),<br>      e =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, e),<br>    }<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure>
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=68c79429a1ea68fb01500006e1580ade" title="" target="_blank">Run<i class="fas fa-external-link-alt fa-fw"></i></a>
<p>　<br>上記のプログラムの<code>e if e % 15 == 0</code>において<code>e</code>は変数パターンと呼ばれていて、任意の値にマッチして指定した変数を値に束縛します。変数名自体は<code>e</code>でなくても何でも構いませんが、アーム内でシャドーイングが起こることだけ注意してください。<code>if e % 15 == 0</code>がパターンガートよ呼ばれるもので、条件を満たす場合だけこのアームがマッチします。</p>
<p>パターンガードがない変数パターンはワイルドカードパターンと似ていて何にでもマッチするので、通常パターンの一番最後におこかれます。両者の違いは変数を束縛するか否かの違いだけです。</p>
<h2 id="第二章-Rust生活-中級編"><a href="#第二章-Rust生活-中級編" class="headerlink" title="第二章 Rust生活:中級編"></a>第二章 Rust生活:中級編</h2><p>いよいよ中級編に突入です。ここからは少し関数型プログラミングの要素が強くなっていきますが、テーマは相変わらずFizzBuzzなので焦らずにまったりと生活を楽しんでください。</p>
<h3 id="5日目-〜FizzBuzzでタプルに馴染む〜"><a href="#5日目-〜FizzBuzzでタプルに馴染む〜" class="headerlink" title="5日目 〜FizzBuzzでタプルに馴染む〜"></a>5日目 〜FizzBuzzでタプルに馴染む〜</h3><p>4日目のプログラムでパターンガードで素直に剰余で分類できるようになりましたが、やはりパターンガードの記述は冗長に思えます。そこで<strong>タプル</strong>を用いてシンプルかつエレガントに書き換えて見ましょう。</p>
<figure class="highlight rust"><figcaption><span>fizz_buzz5(rust)</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">fizz_buzz5</span>() {<br>  <span class="hljs-keyword">for</span> <span class="hljs-variable">x</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span> ..= <span class="hljs-number">100</span> {<br>    <span class="hljs-title function_ invoke__">match</span> (x % <span class="hljs-number">3</span>, x % <span class="hljs-number">5</span>) {<br>      (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"FizzBuzz"</span>), <span class="hljs-comment">// xを3で割った余りと5で割った余りが両方0</span><br>      (<span class="hljs-number">0</span>, _) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Fizz"</span>),     <span class="hljs-comment">// xを3で割った余りが0</span><br>      (_, <span class="hljs-number">0</span>) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Buzz"</span>),     <span class="hljs-comment">// xを5で割った余りが0</span><br>      _      =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, x),<br>    }<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure>
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=2d3e161ce37482ba288191090502d940" title="" target="_blank">Run<i class="fas fa-external-link-alt fa-fw"></i></a>
<p>　<br>「タプル」は異なる型の値の集合であり、括弧<code>()</code>を用いて生成します。例えば<code>(1, 2, 3)</code>は<code>(i32, i32, i32)</code>型のタプルであり、<code>(5, 3.1, "hoge")</code>は<code>(i32, f64, &amp;str)</code>型のタプルになります。<code>ｆ64</code>は64ビット浮動小数点型で<code>&amp;str</code>は「文字列スライス」と呼ばれています。ちなみに一日目に出てきたユニット<code>()</code>は実は要素を持たないタプルでした。要素が一つのタプルはあまり利用する場面がありませんが、作りたい場合は<code>(1,)</code>のように１つ目の要素のあとにカンマ<code>,</code>をつけます。こうすることで式をまとめるための丸カッコと区別することができます。</p>
<p>文字列スライスについて少し説明します。文字列スライスは文字列の一部を切り出したもので、固定長文字列を表す型を持ちます。具体的にはUTF8バイトシーケンスへの参照になっています。今まで何気なく使っていた<code>println!("FizzBuzz")</code>の<code>"FizzBuzz"</code>という表記は<strong>文字列リテラル</strong>と呼ばれ、型としては文字列スライスとして表されます<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup>。また、可変長文字列はヒープと呼ばれるメモリ空間に配置され、<code>String</code>型として区別されます<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup>。</p>
<p>Rustは性能に気を使う言語なので、静的領域に確保されたのか、スタックに確保されたのか、ヒープに確保されたのかを型を用いて表現します。一般的にRustのプログラムはオーバーヘッドが少ないスタック領域を優先的に使うようにして、必要なときにヒープが使えるようにデザインされています。</p>
<p>少し話が脱線しましたが話を上記のプログラムに戻すと、<code>(x % 3, x % 5)</code>は変数<code>x</code>の値をそれぞれ3と5で割った余りをタプルにしていて、型は<code>(i32, i32)</code>になります。パターンマッチのアームの中ではこのタプルのパターンに応じて分類を行っています。</p>
<p><code>(0, 0)</code>というパターンは文字通り<code>(0, 0)</code>というタプル値と等しい場合にマッチングします。<code>(0, _)</code>というパターンはタプルの一つ目の要素が0で２つ目の要素は何でもマッチングします。<code>_</code>はワイルドカードパターンになっていて、このようにタプルのマッチングにも利用可能です。</p>
<p>パターンマッチはこのように内部構造を持ったデータ型に対して特に強力です。パターンマッチに関しては以前に記事を書いたので、さらに詳細について知りたい方は御覧ください。</p>
<div class="blog-card"><div class="hbc-link-wrap"><a class="hbc-link" href="https://hinastory.github.io/cats-cats-cats/2019/04/30/understanding-pattern-matching/"><div class="hbc-card"><div class="hbc-info"><img class="hbc-favicon" src="http://favicon.hatena.ne.jp/?url=https%3A%2F%2Fhinastory.github.io%2Fcats-cats-cats%2F2019%2F04%2F30%2Funderstanding-pattern-matching%2F"><div class="hbc-site-name">cats cats cats</div></div><div class="hbc-contents"><div class="hbc-thumbnail"><img src="https://hinastory.github.io/cats-cats-cats/gallery/daily/algorithm/pattern-match/pattern-01.png"></div><div class="hbc-text"><div class="hbc-title">全プログラマに捧ぐ！図解「パターンマッチ」</div><div class="hbc-url">https://hinastory.github.io/cats-cats-cats/2019/04/30/understanding-pattern-matching/</div><div class="hbc-description">パターンマッチを使い始めてかなりの時間が経ちました。最初は関数型言語の一機能として触り始めましたが、徐々に関数型言語のユーザだけの玩具にしておくのは勿体ないと思うようになってきました。プログラミングにおいて、パターンマッチほど有用であるにもかかわらず普及が遅れている言語機能は他に…</div></div></div></div></a></div></div>



<h3 id="6日目-〜FizzBuzzでmatchが式であることを認識する〜"><a href="#6日目-〜FizzBuzzでmatchが式であることを認識する〜" class="headerlink" title="6日目 〜FizzBuzzでmatchが式であることを認識する〜"></a>6日目 〜FizzBuzzでmatchが式であることを認識する〜</h3><p>5日目のプログラムでタプルによるパターンマッチを身につけましたが、今度は<code>println!</code>マクロが冗長に思えてきました。どうにかして<code>println!</code>を一箇所にまとめられないでしょうか？ もちろん可能です。そのためには<code>match</code>が<strong>式</strong>であることを理解する必要があります。</p>
<figure class="highlight rust"><figcaption><span>fizz_buzz6(rust)</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">fizz_buzz6</span>() {<br>  <span class="hljs-keyword">for</span> <span class="hljs-variable">x</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span> ..= <span class="hljs-number">100</span> {<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-title function_ invoke__">match</span> (x % <span class="hljs-number">3</span>, x % <span class="hljs-number">5</span>) {<br>      (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) =&gt; <span class="hljs-string">"FizzBuzz"</span>.<span class="hljs-title function_ invoke__">to_string</span>(),<br>      (<span class="hljs-number">0</span>, _) =&gt; <span class="hljs-string">"Fizz"</span>.<span class="hljs-title function_ invoke__">to_string</span>(),<br>      (_, <span class="hljs-number">0</span>) =&gt; <span class="hljs-string">"Buzz"</span>.<span class="hljs-title function_ invoke__">to_string</span>(),<br>      _      =&gt; x.<span class="hljs-title function_ invoke__">to_string</span>(),<br>    };<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, s)<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure>
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=608daddcd6b38498275b7f4e406752c0" title="" target="_blank">Run<i class="fas fa-external-link-alt fa-fw"></i></a>
<p>　<br><code>match</code>が式であるとはつまり、評価した結果の値があるということです。そして変数は値に束縛できるので、その値を<code>println!</code>で表示することで<code>println!</code>を一箇所に集約することができます。しかし、以下のように単に変数<code>s</code>を<code>match</code>の評価値に束縛しようとするとコンパイルエラーになってしまいます。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-title function_ invoke__">match</span> (x % <span class="hljs-number">3</span>, x % <span class="hljs-number">5</span>) {<br>    (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) =&gt; <span class="hljs-string">"FizzBuzz"</span>,<br>    (<span class="hljs-number">0</span>, _) =&gt; <span class="hljs-string">"Fizz"</span>,<br>    (_, <span class="hljs-number">0</span>) =&gt; <span class="hljs-string">"Buzz"</span>,<br>      _    =&gt; x.<span class="hljs-title function_ invoke__">to_string</span>(), <span class="hljs-comment">// 整数を文字列に変換</span><br>};<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, s)<br></code></pre></td></tr></tbody></table></figure>
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=68fef1a8f210830180c02f663d648f16" title="" target="_blank">Run<i class="fas fa-external-link-alt fa-fw"></i></a>
<p>　<br>具体的なエラーは以下のようになっています。<strong>「incompatible types」</strong>とあるので型が合わずにエラーになっているようです。</p>
<img src="/cats-cats-cats/gallery/daily/others/incompatible-types.png" class="">
<p>　<br>Rustは静的型付言語なので動的型付言語よりも<strong>型について強い一貫性</strong>が求められます。例えば今回のケースのように<code>match</code>の中のアームの評価値は全て同じ型にする必要があります。そのことは理解していたつもりで最後のアームで<code>x.to_string()</code>として整数型を文字列型にしましたが、それでもエラーになってしまいました。</p>
<p>ここで5日目の出来事を思い出してください。そこでは文字列には固定長文字列の型(文字列スライスの型)である<code>&amp;str</code>と可変長文字列の型である<code>String</code>があることを述べました。つまり上記のエラーは文字列リテラルの型は<code>&amp;str</code>であり、<code>.to_string()</code>で作成した文字列は<code>String</code>型なので、型が異なりエラーとなっている訳です。</p>
<p>ここではどちらかに型を寄せることでエラーを解決します。Rustで苦労するのはこの型合わせだと思いますが、エラーメッセージは比較的わかりやすいので一度理解してしまえば修正自体はそれほど難しくはありません。<code>fizz_buzz6()</code>では文字列リテラル(“FIzBuzz”等の文字列)を<code>.to_string()</code>で<code>String</code>型に変更することで対応しました。実は可変長文字列も<code>&amp;</code>をつけて文字列スライスを切り出すことは可能ですが、それは7日目に説明します。</p>
<h3 id="7日目-〜FizzBuzzで所有権と借用を意識する〜"><a href="#7日目-〜FizzBuzzで所有権と借用を意識する〜" class="headerlink" title="7日目 〜FizzBuzzで所有権と借用を意識する〜"></a>7日目 〜FizzBuzzで所有権と借用を意識する〜</h3><p>6日目のプログラムで<code>println!</code>を一箇所にまとめることができたのですが、また新たに問題抱え込んでしまいました。これまで文字列リテラルとして静的に確保していた文字列を<code>.to_string()</code>で可変長文字列に変換しているので、毎回ヒープメモリへ文字列を確保することになってしまいました。100回くらいのループになら問題ないかもしれませんが、回数が多くなるほど性能に影響がでることは目に見えています。そこで今回はなるべく<code>.to_string()</code>を使わない方法を考えることにしました。</p>
<figure class="highlight rust"><figcaption><span>fizz_buzz7(rust)</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">fizz_buzz7</span>() {<br>  <span class="hljs-keyword">for</span> <span class="hljs-variable">x</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span> ..= <span class="hljs-number">100</span> {<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">tmp</span>; <span class="hljs-comment">// 値のスコープを広げるための変数</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-title function_ invoke__">match</span> (x % <span class="hljs-number">3</span>, x % <span class="hljs-number">5</span>) {<br>      (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) =&gt; <span class="hljs-string">"FizzBuzz"</span>,<br>      (<span class="hljs-number">0</span>, _) =&gt; <span class="hljs-string">"Fizz"</span>,<br>      (_, <span class="hljs-number">0</span>) =&gt; <span class="hljs-string">"Buzz"</span>,<br>      _      =&gt; {tmp = x.<span class="hljs-title function_ invoke__">to_string</span>(); &amp;tmp}, <span class="hljs-comment">// `tmp`を`x.to_to_string()`に束縛して参照をとる</span><br>    };<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, s);<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure>
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=1997fc49b0129ddf4ab00363e95a72ac" title="" target="_blank">Run<i class="fas fa-external-link-alt fa-fw"></i></a>
<p>　<br>上記の方法は、Rustの所有権と借用を正しく理解していないと思いつくことはできません。そして所有権と借用の概念はRustの際立った特徴になっているので、快適なRustライフを送るためにもこれらを理解できるようになりましょう。所有権の規則は以下のとおりです。</p>
<ol>
<li>Rustの各値は、<strong>所有者と呼ばれる変数</strong>と対応している。</li>
<li>いかなる時も<strong>所有者は一つ</strong>である。</li>
<li><strong>所有者がスコープから外れたら、値は破棄</strong>される。</li>
</ol>
<p>以下で具体的に確認してみます。まずは<strong>「常に所有権はひとつ」</strong>というルールを守るための<strong>ムーブセマンティクス</strong>について説明します。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-string">"Rust Life"</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, s1); <span class="hljs-comment">// OK</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s1; <span class="hljs-comment">// ムーブセマンティクス：所有権が`s1`から`s2`に移動している</span><br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, s2); <span class="hljs-comment">// OK</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, s1); <span class="hljs-comment">// コンパイルエラー： 所有権は`s2`に移動しているので`s1`にアクセス不可</span><br></code></pre></td></tr></tbody></table></figure>
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=03f339692a92699fd8721c9eb11fb652" title="" target="_blank">Run<i class="fas fa-external-link-alt fa-fw"></i></a>
<p>　<br>「ムーブセマンティクス」とは簡単にいえば<strong>所有権の移動という意味</strong>であり、上記の例では<code>s2</code>へ<code>s1</code>を代入することにより所有権が移動しています。エラーメッセージは以下のようになりどこで所有権が移動し、どこで利用しようとしてエラーになったのかひと目で分かるようになっています。</p>
<img src="/cats-cats-cats/gallery/daily/others/borrow-of-moved-value.png" class="">
<p>　<br>次に代入以外でムーブセマンティクスが有効になる例を紹介します。それは<strong>関数の引数と戻り値</strong>になります。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_print</span>(msg: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> {<br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{} in test_print"</span>, msg);<br>  msg <span class="hljs-comment">// `msg`をそのまま返却</span><br>}<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-string">"Rust Life"</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = <span class="hljs-title function_ invoke__">test_print</span>(s1);<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"{} after test_print /s2"</span>, s2);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"{} after test_print /s1"</span>, s1); <span class="hljs-comment">// コンパイルエラー: 所有権は`s1`にはない</span><br></code></pre></td></tr></tbody></table></figure>
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=9680cf0e534db35211d7b0d38eb99e15" title="" target="_blank">Run<i class="fas fa-external-link-alt fa-fw"></i></a>
<p>　<br>上記ではまず作成された文字列の所有者は<code>s1</code>になり、<code>test_print()</code>が呼び出され、文字列の所有者は<code>s1</code>からtest_print内の<code>msg</code>になります。次に<code>msg</code>はfn test_printの戻り値としてそのまま返却されます。このとき所有権も移動して、呼び出し元の<code>s2</code>が新たな所有者になります。つまり所有者は<code>s1</code> -&gt; <code>msg</code> -&gt; <code>s2</code>と移動しており、単一所有者の原則が守られていることが分かると思います。</p>
<p>ちなみにRustの関数は<strong>最後に評価された式もしくは文の評価値が戻り値</strong>になる仕様です。文の評価値は常にユニット<code>()</code>になります。そしてセミコロン<code>;</code>は式を強制的に文（正確には式文）に変えるようになっています。そのため、例えば上記の<code>test_print</code>関数の最後の行を<code>msg;</code>としてセミコロンをつけてしまうと、<code>式</code>が<code>式文</code>に変換されてしまい、ユニット<code>()</code>が戻り値となりますが、そうすると関数宣言で<code>String</code>が戻り値になっていることと矛盾するのでコンパイルエラーになります。<br>　<br>このように所有権を明確にすることでリソースの多重解放によるエラーをコンパイル時に検出することができるようになります。また、リソースの利用に関するある種の競合をコンパイル時に検出してエラーにすることができます。この所有者は一つという性質は例えばC++の<code>unique_ptr</code>でも実現できますが、<code>unique_ptr</code>の利用がオプションなので、変数に対する不正なアクセスを防ぎ切ることはできません。その点Rustは<strong>言語レベルで所有権の規則を徹底しているので、不正な変数へのアクセスをコンパイル時に確実に防いでくれます。</strong></p>
<p>ただ毎回、所有権を移動させてしまうと不便なケースもあります。例えば上記の例で言えば<code>s1</code>の値を<code>test_print</code>関数で利用したあとに<code>s1</code>と同じスコープで再利用したい場合には、必ず<code>test_print</code>関数の戻り値として所有権を移動させて、元に戻す動作にする必要があります。こういうケースではRustの<strong>「参照」</strong>の機能を利用すると便利です。参照はアンパサンド<code>&amp;</code>を変数名につけることで作成できます。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_print</span>(msg: &amp;<span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">String</span> {<br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{} in test_print"</span>, msg); <span class="hljs-comment">// `msg`は`s1`の値を借用している</span><br>  &amp;msg <span class="hljs-comment">// `msg`をそのまま返却</span><br>}<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-string">"Rust Life"</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = <span class="hljs-title function_ invoke__">test_print</span>(&amp;s1); <span class="hljs-comment">// 所有者は`s1`のままで値を`s2`は値を借用しているだけ</span><br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"{} after test_print /s2"</span>, s2);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"{} after test_print /s1"</span>, s1); <span class="hljs-comment">// 所有権は移動していないのでコンパイルエラーにはならない</span><br></code></pre></td></tr></tbody></table></figure>

<p>参照は型名でも区別され、<code>String</code>型の参照は<code>&amp;String</code>型になります。この参照を利用して、所有権を移動させずに定期間だけ値をレンタルすることを<strong>借用</strong>と呼びます。借用には以下のルールがあります。</p>
<ul>
<li>参照は値よりも長く生存してはならない<ul>
<li>参照が有効なスコープは<strong>ライフタイム</strong>と呼ばれる</li>
</ul>
</li>
<li>値が共有されている間は値の変更を許さない</li>
</ul>
<p>上記のルールを守ることによりデータの競合を防ぎつつ、安全な共有を実現できます。次に、スコープと値の破棄について説明します。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust">{                         <span class="hljs-comment">// sはまだ宣言されていないので有効ではない</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">"Rust Life"</span>;  <span class="hljs-comment">// sここから有効になる</span><br><br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, s);   <span class="hljs-comment">// OK</span><br>}                        <span class="hljs-comment">// このスコープは終わり。もうsは有効ではない</span><br><span class="hljs-title function_ invoke__">println</span>(<span class="hljs-string">"{}"</span>, s); <span class="hljs-comment">// コンパイルエラー： sは破棄されており無効</span><br></code></pre></td></tr></tbody></table></figure>
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=2a63891e31213be6255e30137d9ecdf5" title="" target="_blank">Run<i class="fas fa-external-link-alt fa-fw"></i></a>
<p>　<br>コメントのとおり、変数<code>s</code>のスコープは変数が宣言されてから中括弧の終わり<code>}</code>までなので、「コンパイルエラー」とコメントされた行では<code>s</code>は破棄されておりアクセスできません。この「所有者がスコープから外れたら、値は破棄される」という性質は他の一部の言語でも見ることができます。この機能はよく<strong>「ローンパターン」</strong>と呼ばれており、C++のRAII、Javaのtry-with-resources、C#のusing、ScalaのUsing、Goのdefer等がそれにあたります。</p>
<p>ようやく、ここまでの説明で<code>fizz_buzz7()</code>を説明する下地が整いました。まずfizz_buzz7を一部切り出して変更した以下の例はコンパイルエラーになりますが、エラーの理由を考えてみてください。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-title function_ invoke__">match</span> (x % <span class="hljs-number">3</span>, x % <span class="hljs-number">5</span>) {<br>  (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) =&gt; <span class="hljs-string">"FizzBuzz"</span>,<br>  (<span class="hljs-number">0</span>, _) =&gt; <span class="hljs-string">"Fizz"</span>,<br>  (_, <span class="hljs-number">0</span>) =&gt; <span class="hljs-string">"Buzz"</span>,<br>    _    =&gt; &amp;x.<span class="hljs-title function_ invoke__">to_string</span>(), <span class="hljs-comment">// ここで参照を作成</span><br>};<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, s);<br></code></pre></td></tr></tbody></table></figure>
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=981f0bcad665ac399c00a38d541bc7d3" title="" target="_blank">Run<i class="fas fa-external-link-alt fa-fw"></i></a>
<p>　<br>「型があっていないから」、と答えた方は残念ながら不正解です。<code>&amp;x.to_string()</code>において<code>x.to_string()</code>は<code>String</code>型であり、アンパサンド<code>&amp;</code>をつけて参照をとると<code>&amp;String</code>型になります。そして”FizzBuzz”のような文字列リテラルは<code>&amp;str</code>型になるので確かに型はあっていません。しかし、それはRustの<strong>「型強制」</strong>という仕組みで<code>&amp;String</code>型は<code>&amp;str</code>型に変換されてしまうので型の問題はなくなるのです。</p>
<p>型の問題ではないとすると何が問題かというと<strong>「ライフタイム」</strong>の問題となります。つまり<code>x.to_string()</code>で<code>String</code>型の値が作成されますが、その値が有効なスコープは<code>match</code>のアームの中だけなので値はそこで破棄されます。しかし、<code>&amp;x.to_string()</code>でその破棄されたはずの値の参照を返そうとしているので<strong>「参照は値よりも長く生存してはならない」</strong>というルールに反してエラーになるのです。単純に<code>.to_string()</code>した値を返すだけならムーブセマンティクスが働いてそのまま値がムーブされますが参照は所有権を移動しないのでこのような挙動になります。</p>
<p>この問題は以下のようにより広いスコープを持つ変数に束縛させてから参照をとることで解決できます。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">tmp</span>; <span class="hljs-comment">// 値のスコープを広げるための変数</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-title function_ invoke__">match</span> (x % <span class="hljs-number">3</span>, x % <span class="hljs-number">5</span>) {<br>  (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) =&gt; <span class="hljs-string">"FizzBuzz"</span>,<br>  (<span class="hljs-number">0</span>, _) =&gt; <span class="hljs-string">"Fizz"</span>,<br>  (_, <span class="hljs-number">0</span>) =&gt; <span class="hljs-string">"Buzz"</span>,<br>  _      =&gt; {tmp = x.<span class="hljs-title function_ invoke__">to_string</span>(); &amp;tmp}, <span class="hljs-comment">// `tmp`を`x.to_to_string()`に束縛して参照をとる</span><br>};<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, s);<br></code></pre></td></tr></tbody></table></figure>

<p>このようにすることで、参照<code>&amp;tmp</code>のライフタイムは変数<code>s</code>と同じであり、それは変数<code>tmp</code>の有効スコープ内であるので、借用ルールの制約をみたすことができます。</p>
<p>思ったより長かったですがこれで<code>fizz_buzz7</code>を理解することできるようになったと思います。恐らくこの所有権と借用がRust中級者の一番のハードルだと思われるのでしっかりと理解を深めるようにしてください。</p>
<h3 id="8日目-〜FizzBuzzで高階関数とクロージャに目覚める〜"><a href="#8日目-〜FizzBuzzで高階関数とクロージャに目覚める〜" class="headerlink" title="8日目 〜FizzBuzzで高階関数とクロージャに目覚める〜"></a>8日目 〜FizzBuzzで高階関数とクロージャに目覚める〜</h3><p>7日目のプログラムで性能を犠牲にしないFizzBuzzになりましたが、直感的には分かりづらくなりました。それは元のFizzBuzzを表示するというロジックとは関係ない性能の都合上の<code>tmp</code>変数を導入したことに原因があります。この辺はトレードオフの問題ですが、やはりメンテナンス性を重視した設計がしたくなりました。そこで唐突に天から啓示を受けました。<strong>高階関数とクロージャに目覚めよ</strong>と。</p>
<figure class="highlight rust"><figcaption><span>fizz_buzz8(rust)</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">fizz_buzz8</span>() {<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">fz</span> = |x: <span class="hljs-type">i32</span>| {       <span class="hljs-comment">// クロージャの定義</span><br>    <span class="hljs-title function_ invoke__">match</span> (x % <span class="hljs-number">3</span>, x % <span class="hljs-number">5</span>) {<br>      (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) =&gt; <span class="hljs-built_in">format!</span>(<span class="hljs-string">"FizzBuzz"</span>),<br>      (<span class="hljs-number">0</span>, _) =&gt; <span class="hljs-built_in">format!</span>(<span class="hljs-string">"Fizz"</span>),<br>      (_, <span class="hljs-number">0</span>) =&gt; <span class="hljs-built_in">format!</span>(<span class="hljs-string">"Buzz"</span>),<br>          _  =&gt; x.<span class="hljs-title function_ invoke__">to_string</span>(),<br>  }};<br><br>  (<span class="hljs-number">1</span> ..= <span class="hljs-number">100</span>).<span class="hljs-title function_ invoke__">map</span>(fz).<span class="hljs-title function_ invoke__">for_each</span>(|x| <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, x)); <span class="hljs-comment">// 高階関数とクロージャの利用</span><br>}<br></code></pre></td></tr></tbody></table></figure>
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=a1242cc0802345c0ff405d9a4c7a8e3f" title="" target="_blank">Run<i class="fas fa-external-link-alt fa-fw"></i></a>
<p>　<br>まずは関数とクロージャの違いについて説明します。クロージャ以下のとおり関数と見た目と機能はよく似ていますが違いがいくつかあります。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">two</span> = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">double_func</span>(x: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> { x * <span class="hljs-number">2</span> } <span class="hljs-comment">// 引数を２倍にする関数</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">double_closure</span> = |x| { x * two };   <span class="hljs-comment">// 引数を2倍にするクロージャ</span><br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, <span class="hljs-title function_ invoke__">double_func</span>(<span class="hljs-number">2</span>));  <span class="hljs-comment">// result: 4</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, <span class="hljs-title function_ invoke__">double_closure</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// result: 4</span><br></code></pre></td></tr></tbody></table></figure>
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=2d397bc26aacf0676898ac63b4b0bf2f" title="" target="_blank">Run<i class="fas fa-external-link-alt fa-fw"></i></a>
<p>　<br>１つ目の違いは、関数は引数の型や戻り値の型を省略できませんが、クロージャは<strong>大抵は</strong>省略できることです。「大抵」と書いたのは型推論に失敗してコンパイラに型を書けと怒られる場合もあるからです。</p>
<p>２つ目はクロージャは外部の変数を利用できることです。上記の例では<code>double_closure</code>ではクロージャ本体の外側の変数<code>two</code>を利用しています。このときクロージャは変数を<strong>環境としてキャプチャ</strong>しているので、クロージャの中で利用可能になっています。関数は環境をキャプチャできないので外部の変数は利用できません<sup id="fnref:8"><a href="#fn:8" rel="footnote">8</a></sup>。</p>
<p>3つ目は関数には<strong>「名前」</strong>があり、クロージャには<strong>「名前がない」</strong>ということです。クロージャには名前がないので変数に束縛して利用するか、そもそも名前が必要がない箇所で用いられます。名前が必要ない箇所とは定義して即時実行する場合や「高階関数」の引数や戻り値として利用する場合です。</p>
<p>最後の違いはクロージャの波括弧<code>}</code>後にはセミコロン<code>;</code>が必要なことです。これはクロージャというよりも<code>let</code>宣言と関数の違いになります。</p>
<p>Rustのクロージャは他の言語では<strong>「無名関数」</strong>、<strong>「匿名関数」</strong>、<strong>「ラムダ」</strong>と呼ばれる場合がありますが、基本的には同じ役割を果たしていると考えて差し支えありません。ただし一般的な<strong>「クロージャ」</strong>という用語は<strong>「環境をキャプチャする」</strong>という側面を強調していることは頭の片隅に留めておくべきかもしれません<sup id="fnref:9"><a href="#fn:9" rel="footnote">9</a></sup>。</p>
<p>次に、高階関数について説明します。高階関数は<strong>関数を引数にとるか、関数を戻り値として返す関数</strong>です。つまり<strong>「関数」を「値」としてやりとりする関数</strong>です。ここでいう「値としての関数」にはクロージャも含みます。以下は高階関数の<code>map</code>と<code>for_each</code>の使用例です。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">double</span> = |x| { x * <span class="hljs-number">2</span> };<br><br>(<span class="hljs-number">1</span> ..= <span class="hljs-number">5</span>).<span class="hljs-title function_ invoke__">map</span>(double).<span class="hljs-title function_ invoke__">for_each</span>(|x| <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, x))<br></code></pre></td></tr></tbody></table></figure>

<p>上記の例ではレンジ(1 ..= 5)に対して<code>map</code>を呼び出しており、レンジの各要素に<code>double</code>を適用しています。<code>double</code>は引数を２倍にするので各要素は[2,4,6,8,10]になり<code>map</code>はそれをイテレータとして返します。そしてイテレータに対して<code>for_each</code>を呼び出すとイテレータが返す各要素に対して受け取った関数を適用します。上記の例ではクロージャを適用しています。クロージャの中身は<code>println!</code>の適用なので、結果的に出力は以下のようになります。</p>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">2<br>4<br>6<br>8<br>10<br></code></pre></td></tr></tbody></table></figure>

<p><code>map</code>も<code>for_each</code>も動作はよく似ていますが、違う点は戻り値として<strong>イテレータを返すかどうか</strong>です。<code>map</code>はイテレータを返すので何回も<code>map</code>を続けることができますが、<code>for_each</code>はユニット<code>()</code>を返すのでその後に<code>map</code>や<code>for_each</code>を続けることはできません。つまり<code>map</code>は中間で使われることを意図しており、<code>for_each</code>は終端で使われることを意図してます。Rustではこの使い分けを明確にしており、<code>map</code>は<strong>イテレータアダプタ</strong>と呼ばれており、<code>for_each</code>は<strong>コンシューマ</strong>と呼ばれています。イテレータおよびイテレータアダプタの作用は基本的に怠惰(<code>lazy</code>)であり<sup id="fnref:10"><a href="#fn:10" rel="footnote">10</a></sup>、コンシューマが消費するまで作用しません。このことは以下を実行してみるとよく分かると思います。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">double</span> = |x| { <span class="hljs-built_in">println!</span>(<span class="hljs-string">"in map {}"</span>, x); x * <span class="hljs-number">2</span> };<br><br>(<span class="hljs-number">1</span> ..= <span class="hljs-number">5</span>).<span class="hljs-title function_ invoke__">map</span>(double).<span class="hljs-title function_ invoke__">for_each</span>(|x| <span class="hljs-built_in">println!</span>(<span class="hljs-string">"in for_each {}"</span>, x))<br></code></pre></td></tr></tbody></table></figure>
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=be08763d45967811c1bdf397457926d4" title="" target="_blank">Run<i class="fas fa-external-link-alt fa-fw"></i></a>
<p>　<br>上記の実行結果は以下のようになります。構文上は<code>map</code>が<code>for_each</code>よりも先なので<code>map</code>が先に呼ばれそうですが、<code>map</code>は怠惰なので<code>for_each</code>で必要になったときに処理を実行するようになっているので、結果的に<code>in map</code>と<code>in for_each</code>が交互に出力されるようになります。</p>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">in map 1<br>in for_each 2<br>in map 2<br>in for_each 4<br>in map 3<br>in for_each 6<br>in map 4<br>in for_each 8<br>in map 5<br>in for_each 10<br></code></pre></td></tr></tbody></table></figure>

<p>ここまでの説明で<code>fizz_buzz8</code>はほぼ理解できるようになるのですが、最後に一点だけ<code>format!</code>マクロについて補足します。このマクロはprintln!マクロと似ていますが結果を画面に出力するのではなく<code>String</code>型の文字列で返します。単純な文字列なら<code>.to_string()</code>でも良いですが２つ以上の変数から文字列を作成したい場合に重宝します。</p>
<h3 id="9日目-〜FizzBuzzで畳み込みを実践する〜"><a href="#9日目-〜FizzBuzzで畳み込みを実践する〜" class="headerlink" title="9日目 〜FizzBuzzで畳み込みを実践する〜"></a>9日目 〜FizzBuzzで畳み込みを実践する〜</h3><p>8日目のプログラムでクロージャと高階関数に目覚めてしまった訳ですが、他にもFizzBuzzで利用できそうな高階関数がないかと探してみると面白そうなものが見つかりました。それが<code>fold</code>であり<strong>畳み込み</strong>と呼ばれる処理を実現します。</p>
<figure class="highlight rust"><figcaption><span>fizz_buzz9(rust)</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">fizz_buzz9</span>() {<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span> =  (<span class="hljs-number">1</span> ..= <span class="hljs-number">100</span>)<br>      .<span class="hljs-title function_ invoke__">fold</span>(<span class="hljs-built_in">format!</span>(<span class="hljs-string">""</span>),|buf, x| { <span class="hljs-comment">// 文字列の畳み込みを行う</span><br>        <span class="hljs-title function_ invoke__">match</span> (x % <span class="hljs-number">3</span>, x % <span class="hljs-number">5</span>) {<br>          (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) =&gt; <span class="hljs-built_in">format!</span>(<span class="hljs-string">"{}FizzBuzz\n"</span>, buf),<br>          (<span class="hljs-number">0</span>, _) =&gt; <span class="hljs-built_in">format!</span>(<span class="hljs-string">"{}Fizz\n"</span>, buf),<br>          (_, <span class="hljs-number">0</span>) =&gt; <span class="hljs-built_in">format!</span>(<span class="hljs-string">"{}Buzz\n"</span>, buf),<br>              _  =&gt; <span class="hljs-built_in">format!</span>(<span class="hljs-string">"{}{}\n"</span>, buf, x),<br>  }});<br><br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, res);<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>まずは簡単な例で<code>fold</code>を確認してみたいと思います。以下の例は<code>fold</code>を用いて1から5の和を求めるコードです。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">init</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">sum</span> = (<span class="hljs-number">1</span> ..= <span class="hljs-number">5</span>).<span class="hljs-title function_ invoke__">fold</span>(init, |acc, x| acc + x);  <span class="hljs-comment">// (((((O + 1) + 2) + 3) + 4) + 5)</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, sum)<br></code></pre></td></tr></tbody></table></figure>
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=e398530e60b9ec98f53f8c68cc7268e5" title="" target="_blank">Run<i class="fas fa-external-link-alt fa-fw"></i></a>
<p>　<br><code>fold</code>の挙動はイテレータから順番に値を取り出して、前回の計算結果と取り出した結果を元に出した計算結果を次回に繰り越すことを繰り返し、一番最後の計算結果が<code>fold</code>の値になります。一番最初の計算には「前回の計算結果」がないので初期値を与えます。上記のプログラムでは具体的には<code>(((((O + 1) + 2) + 3) + 4) + 5)</code>のような数式で計算していることになります。</p>
<p><code>fold</code>で行われるような処理は一般的は<strong>畳み込み</strong>と呼ばれますが、Rustの<code>fold</code>は<strong>左畳み込み</strong>となっており、先頭から順に要素を取り出して計算を行います。これとは別に<strong>右畳み込み</strong>というものもあり、要素を逆順で取り出して処理します。</p>
<p>以上により<code>fizz_buzz9</code>では<code>fold</code>内では簡易な式で表現すると以下のような順序で文字列が結合されて、最終的には<code>println!</code>表示されます。</p>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">(((((("" + "1\n") + "2\n") + "Fizz\n") + "4\n") + "Buzz\n") ...)<br></code></pre></td></tr></tbody></table></figure>

<h2 id="第三章-Truth-of-Rust"><a href="#第三章-Truth-of-Rust" class="headerlink" title="第三章 Truth of Rust"></a>第三章 Truth of Rust</h2><p>ここからはRustの上級者向けの章になります。これまでは詳細な説明を加えていましたが、ここからはヒントと簡単な説明のみになります。上級者になるには調べる力も必須になってくるのでぜひチャレンジして理解できるようになりましょう。以下は参考になるリンクです。</p>
<ul>
<li><a href="https://doc.rust-jp.rs/book/second-edition/" title="" target="_blank">The Rust Programming Language<i class="fas fa-external-link-alt fa-fw"></i></a></li>
<li><a href="https://doc.rust-jp.rs/" title="" target="_blank">Rustの日本語ドキュメント<i class="fas fa-external-link-alt fa-fw"></i></a></li>
<li><a href="https://cheats.rs/" title="" target="_blank">Rust Language Cheat Sheet<i class="fas fa-external-link-alt fa-fw"></i></a></li>
<li><a href="https://doc.rust-lang.org/std/index.html" title="" target="_blank">Comprehensive guide to the Rust standard library APIs<i class="fas fa-external-link-alt fa-fw"></i></a></li>
</ul>
<h3 id="10日目-〜FizzBuzzでコレクションとジェネリクスに気付く〜"><a href="#10日目-〜FizzBuzzでコレクションとジェネリクスに気付く〜" class="headerlink" title="10日目 〜FizzBuzzでコレクションとジェネリクスに気付く〜"></a>10日目 〜FizzBuzzでコレクションとジェネリクスに気付く〜</h3><p>9日目のプログラムで<code>fold</code>の魅力に気づきましたが、文字列を<code>+</code>演算子で結合していくやり方は自由度が高すぎてFizzBuzzではやりすぎなのではと思うようになりました。そこで<code>fold</code>で行っていた文字列結合をもっとシンプルに行う処理そ探していたら<code>join</code>を見つけました。</p>
<figure class="highlight rust"><figcaption><span>fizz_buzz10(rust)</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">fizz_buzz10</span>() {<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fz</span>(x: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> {<br>    <span class="hljs-title function_ invoke__">match</span> (x % <span class="hljs-number">3</span>, x % <span class="hljs-number">5</span>) {<br>      (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) =&gt; <span class="hljs-built_in">format!</span>(<span class="hljs-string">"FizzBuzz"</span>),<br>      (<span class="hljs-number">0</span>, _) =&gt; <span class="hljs-built_in">format!</span>(<span class="hljs-string">"Fizz"</span>),<br>      (_, <span class="hljs-number">0</span>) =&gt; <span class="hljs-built_in">format!</span>(<span class="hljs-string">"Buzz"</span>),<br>          _  =&gt; x.<span class="hljs-title function_ invoke__">to_string</span>(),<br>  }};<br><br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span> =  (<span class="hljs-number">1</span> ..= <span class="hljs-number">100</span>).<span class="hljs-title function_ invoke__">map</span>(fz).collect::&lt;<span class="hljs-type">Vec</span>&lt;_&gt;&gt;().<span class="hljs-title function_ invoke__">join</span>(<span class="hljs-string">"\n"</span>);<br><br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, res);<br>}<br></code></pre></td></tr></tbody></table></figure>
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=3b0dfdbf0761ee362154eee883e2a2df" title="" target="_blank">Run<i class="fas fa-external-link-alt fa-fw"></i></a>
<p>　<br>上記のプログラムの理解のポイント以下になります。</p>
<ul>
<li>コンシューマである<code>collect</code></li>
<li>配列型のコレクションである<code>Vec</code></li>
<li><code>Vec</code>とセットでついてくるジェネリクスの理解</li>
<li><code>join</code>による結合処理</li>
</ul>
<h3 id="11日目-〜FizzBuzzでレムとの邂逅〜"><a href="#11日目-〜FizzBuzzでレムとの邂逅〜" class="headerlink" title="11日目 〜FizzBuzzでレムとの邂逅〜"></a>11日目 〜FizzBuzzで<strong>レム</strong>との邂逅〜</h3><p>10日目のプログラムでなんとなく<code>fz</code>関数を眺めていると引数の型が<code>i32</code>型に固定されていることに気づきました。せっかくジェネリクスを覚えたので<code>fz</code>をジェネリックにして<code>u32</code>型や<code>i64</code>型にも対応できるようにしたくなりました。</p>
<figure class="highlight rust"><figcaption><span>fizz_buzz11(rust)</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">fizz_buzz11</span>() {<br>  <span class="hljs-keyword">use</span> std::ops::Rem;<br><br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fz</span>&lt;T&gt;(x: T, div_a: T, div_b: T, zero: T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span><br>  <span class="hljs-keyword">where</span> T: Rem&lt;T, Output=T&gt; + <span class="hljs-built_in">Eq</span> + <span class="hljs-built_in">Copy</span> + <span class="hljs-built_in">ToString</span> {<br>    <span class="hljs-title function_ invoke__">match</span> (x % div_a == zero , x % div_b == zero) {<br>      (<span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>) =&gt; <span class="hljs-built_in">format!</span>(<span class="hljs-string">"FizzBuzz"</span>),<br>      (<span class="hljs-literal">true</span>, _) =&gt; <span class="hljs-built_in">format!</span>(<span class="hljs-string">"Fizz"</span>),<br>      (_, <span class="hljs-literal">true</span>) =&gt; <span class="hljs-built_in">format!</span>(<span class="hljs-string">"Buzz"</span>),<br>          _  =&gt; x.<span class="hljs-title function_ invoke__">to_string</span>(),<br>  }};<br><br>  (<span class="hljs-number">1</span> ..= <span class="hljs-number">100</span>).<span class="hljs-title function_ invoke__">map</span>(|x: <span class="hljs-type">u32</span>| <span class="hljs-title function_ invoke__">fz</span>(x, <span class="hljs-number">3</span>,<span class="hljs-number">5</span>, <span class="hljs-number">0</span>)).<span class="hljs-title function_ invoke__">for_each</span>(|x| <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, x));<br>}<br></code></pre></td></tr></tbody></table></figure>
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c6ba1fe760a694dab2c74f7de33cf2d3" title="" target="_blank">Ram<i class="fas fa-external-link-alt fa-fw"></i></a>
<p>　<br>上記のでRunが<strong>Ram</strong>になっているのは<strong>仕様です</strong>。どうしても<strong>Rem</strong>と一緒に登場させたかったのです。優しくスルーして頂けると幸いです。</p>
<p>上記のプログラムのポイントは以下です。難易度が跳ね上がりましたが、どうか挫けずに次の日の朝を迎えられるよう頑張ってください。</p>
<ul>
<li>ジェネリック関数の実装</li>
<li>トレイト境界</li>
<li>FizzBuzzで必要な演算（剰余（<code>Rem</code>）、0との比較(<code>Eq</code>)）</li>
<li><code>Copy</code>トレイトと<code>ToString</code>トレイトの役割</li>
</ul>
<h3 id="12日目-〜FizzBuzzでトレイトと戯れる〜"><a href="#12日目-〜FizzBuzzでトレイトと戯れる〜" class="headerlink" title="12日目 〜FizzBuzzでトレイトと戯れる〜"></a>12日目 〜FizzBuzzでトレイトと戯れる〜</h3><p>11日目のプログラムでトレイトの存在に気づき、トレイトを生かしてFizzBuzzを実装してみたくなりました。</p>
<figure class="highlight rust"><figcaption><span>fizz_buzz12(rust)</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FizzBuzz</span>&lt;T&gt; {<br>  div_a: T,<br>  div_b: T,<br>  zero: T,<br>}<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; FizzBuzz&lt;T&gt; {<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(div_a: T, div_b: T, zero: T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> {<br>    FizzBuzz {div_a, div_b, zero}<br>  }<br>}<br><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">ToFzStr</span>&lt;T&gt; {<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">to_str</span>(&amp;<span class="hljs-keyword">self</span>, x: T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>}<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">ToFzStr</span>&lt;<span class="hljs-type">i32</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">FizzBuzz</span>&lt;<span class="hljs-type">i32</span>&gt; {<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">to_str</span>(&amp;<span class="hljs-keyword">self</span>, x: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> {<br>    <span class="hljs-title function_ invoke__">match</span> (x % <span class="hljs-keyword">self</span>.div_a == <span class="hljs-keyword">self</span>.zero , x % <span class="hljs-keyword">self</span>.div_b == <span class="hljs-keyword">self</span>.zero) {<br>      (<span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>) =&gt; <span class="hljs-built_in">format!</span>(<span class="hljs-string">"FizzBuzz"</span>),<br>      (<span class="hljs-literal">true</span>, _) =&gt; <span class="hljs-built_in">format!</span>(<span class="hljs-string">"Fizz"</span>),<br>      (_, <span class="hljs-literal">true</span>) =&gt; <span class="hljs-built_in">format!</span>(<span class="hljs-string">"Buzz"</span>),<br>          _  =&gt; x.<span class="hljs-title function_ invoke__">to_string</span>(),<br>  }}<br>}<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">fizz_buzz12</span>() {<br>  (<span class="hljs-number">1</span> ..= <span class="hljs-number">100</span>).<span class="hljs-title function_ invoke__">map</span>(|x| FizzBuzz::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>).<span class="hljs-title function_ invoke__">to_str</span>(x)).<span class="hljs-title function_ invoke__">for_each</span>(|x| <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, x))<br>}<br></code></pre></td></tr></tbody></table></figure>
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=62ddc4f444c1dc9052a2f60ff0ddb06f" title="" target="_blank">Run<i class="fas fa-external-link-alt fa-fw"></i></a>
<p>　<br>上記のプログラムのポイントは以下です。RustのトレイトはHaskellの型クラスに相当するものです。Javaのような継承ベースのオブジェクト指向言語から来た方には理解が難しいかもしれませんが、一度慣れると多くのメリットに気づけると思います。</p>
<ul>
<li>構造体の定義と実装</li>
<li>メソッド定義と関連関数</li>
<li>トレイトの定義と構造体への実装</li>
</ul>
<h3 id="13日目-〜FizzBuzzをアドホックに改造する〜"><a href="#13日目-〜FizzBuzzをアドホックに改造する〜" class="headerlink" title="13日目 〜FizzBuzzをアドホックに改造する〜"></a>13日目 〜FizzBuzzをアドホックに改造する〜</h3><p>12日目のプログラムでは<code>ToFzStr</code>は<code>i32</code>型にしか実装していませんでしたが、他の型にも実装したくなりました。</p>
<figure class="highlight rust"><figcaption><span>fizz_buzz13(rust)</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ops::Rem;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">common_fz_str</span>&lt;T&gt;(x: T, div_a: T, div_b: T, zero: T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span><br><span class="hljs-keyword">where</span> T: Rem&lt;T, Output=T&gt; + <span class="hljs-built_in">Eq</span> + <span class="hljs-built_in">Copy</span> + <span class="hljs-built_in">ToString</span> {<br>  <span class="hljs-title function_ invoke__">match</span> (x % div_a == zero , x % div_b == zero) {<br>    (<span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>) =&gt; <span class="hljs-built_in">format!</span>(<span class="hljs-string">"FizzBuzz"</span>),<br>    (<span class="hljs-literal">true</span>, _   ) =&gt; <span class="hljs-built_in">format!</span>(<span class="hljs-string">"Fizz"</span>),<br>    ( _  , <span class="hljs-literal">true</span>) =&gt; <span class="hljs-built_in">format!</span>(<span class="hljs-string">"Buzz"</span>),<br>         _       =&gt; x.<span class="hljs-title function_ invoke__">to_string</span>(),<br>}}<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">ToFzStr</span>&lt;<span class="hljs-type">i64</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">FizzBuzz</span>&lt;<span class="hljs-type">i64</span>&gt; {<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">to_str</span>(&amp;<span class="hljs-keyword">self</span>, x: <span class="hljs-type">i64</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> {<br>    <span class="hljs-title function_ invoke__">common_fz_str</span>(x, <span class="hljs-keyword">self</span>.div_a, <span class="hljs-keyword">self</span>.div_b, <span class="hljs-keyword">self</span>.zero)<br>  }<br>}<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">ToFzStr</span>&lt;<span class="hljs-type">u32</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">FizzBuzz</span>&lt;<span class="hljs-type">u32</span>&gt; {<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">to_str</span>(&amp;<span class="hljs-keyword">self</span>, x: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> {<br>    <span class="hljs-title function_ invoke__">common_fz_str</span>(x, <span class="hljs-keyword">self</span>.div_a, <span class="hljs-keyword">self</span>.div_b, <span class="hljs-keyword">self</span>.zero)<br>  }<br>}<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">fizz_buzz13</span>() {<br>  (<span class="hljs-number">1</span> ..= <span class="hljs-number">100</span>).<span class="hljs-title function_ invoke__">map</span>(|x: <span class="hljs-type">i64</span>| FizzBuzz::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>).<span class="hljs-title function_ invoke__">to_str</span>(x)).<span class="hljs-title function_ invoke__">for_each</span>(|x| <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, x))<br>}<br></code></pre></td></tr></tbody></table></figure>
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=58cfd062333e55b04dfb6b4ad07daf31" title="" target="_blank">Run<i class="fas fa-external-link-alt fa-fw"></i></a>
<p>　<br>上記のプログラムは12日目と被る定義は省略しています。プログラムの全体は「Run」のリンク先を見てください。<br>ポイントは以下になります。</p>
<ul>
<li>トレイトを複数の型への実装してアドホック多相性を確認する</li>
</ul>
<h3 id="14日目-〜FizzBuzzで無限列に畏怖する〜"><a href="#14日目-〜FizzBuzzで無限列に畏怖する〜" class="headerlink" title="14日目 〜FizzBuzzで無限列に畏怖する〜"></a>14日目 〜FizzBuzzで無限列に畏怖する〜</h3><p>13日目のプログラムまでは1から100までのFizzBuzzに対応してきましたが、もっと大きなFizzBuzzも試してみたくなりました。</p>
<figure class="highlight rust"><figcaption><span>fizz_buzz14(rust)</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">fizz_buzz14</span>(end: <span class="hljs-type">usize</span>) {<br>  (<span class="hljs-number">1</span> ..).<span class="hljs-title function_ invoke__">take</span>(end).<span class="hljs-title function_ invoke__">map</span>(|x| FizzBuzz::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>).<span class="hljs-title function_ invoke__">to_str</span>(x)).<span class="hljs-title function_ invoke__">for_each</span>(|x| <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, x))<br>}<br></code></pre></td></tr></tbody></table></figure>
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=8d99fec95b8ad338dda60a1d95dc7264" title="" target="_blank">Run<i class="fas fa-external-link-alt fa-fw"></i></a>
<p>　<br>上記のプログラムは以前と被る定義は省略しています。プログラムの全体は「Run」のリンク先を見てください。<br>ポイントは以下になります。</p>
<ul>
<li>無限の数値列の生成<code>(1..)</code></li>
<li><code>take</code>による切り出し</li>
</ul>
<h3 id="15日目-〜FizzBuzzで再帰的に死に戻る〜"><a href="#15日目-〜FizzBuzzで再帰的に死に戻る〜" class="headerlink" title="15日目 〜FizzBuzzで再帰的に死に戻る〜"></a>15日目 〜FizzBuzzで再帰的に死に戻る〜</h3><p>14日目のプログラムで無限の奥深さに惹かれました。そしてとうとう無限を表現する禁忌の手段、<strong>再帰の沼</strong>にハマってしまったのです。こうなるともう元の生活に戻るのは困難でしょう。終わりの始まりです。</p>
<figure class="highlight rust"><figcaption><span>fizz_buzz15(rust)</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">fizz_buzz15</span>(end: <span class="hljs-type">u32</span>) {<br>  <span class="hljs-keyword">if</span> end &gt; <span class="hljs-number">1</span> { <span class="hljs-title function_ invoke__">fizz_buzz15</span>(end - <span class="hljs-number">1</span>) }<br><br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, FizzBuzz{div_a: <span class="hljs-number">3</span>, div_b: <span class="hljs-number">5</span>, zero: <span class="hljs-number">0</span>}.<span class="hljs-title function_ invoke__">to_str</span>(end))<br>}<br></code></pre></td></tr></tbody></table></figure>
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=17c8a453c54809e59cca5bd4f28d46e3" title="" target="_blank">Run<i class="fas fa-external-link-alt fa-fw"></i></a>
<p>　<br>ポイントは以下になります。</p>
<ul>
<li>再帰を理解する<ul>
<li>末尾再帰最適化について調べ始める・・・<sup id="fnref:11"><a href="#fn:11" rel="footnote">11</a></sup></li>
<li><strong>素直にイテレータを使ったほうが幸せだと気付く</strong></li>
</ul>
</li>
</ul>
<h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>Rustは学習曲線が急峻だと言われています。学ぶべきコンポーネントが多く個々が密接に関連していて、ラスボス感漂う借用チェッカーまでいるからです。そのため約束した朝は遠く、絶望という病に侵されるかもしれません。<strong>脳が震える</strong>かもしれません。でも<strong>FizzBuzz</strong>がいます。どんなに辛く苦しいことがあって負けそうになってしまっても、世界中の誰も信じてくれなくて、自分自身を信じられなくなってしまっても、FizzBuzzが側にいます。ここから始めましょう。イチから、いいえ、<strong>FizzBuzz</strong>から。</p>
<ul>
<li><code>while</code>, <code>if</code></li>
<li><code>for</code>とレンジ</li>
<li>パターンマッチ</li>
<li>タプル</li>
<li>所有権と借用</li>
<li>高階関数とクロージャ</li>
<li>畳み込み</li>
<li>コレクションとジェネリクス</li>
<li>トレイトとトレイト境界</li>
<li>アドホック多相性</li>
<li>無限列</li>
<li>再帰</li>
</ul>
<p>Rust生活をFizzBuzzから始めることで上記の学びが少しずつ得られると信じています。そして絶望に抗う賭けに勝ち、鬼がかった未来を手に入れましょう。</p>
<blockquote><p>君を見てる。<br>君が見てる。<br>だから俯かない。<br>ここから、FizzBuzzからはじめよう。<br>プログラマの物語を。<br>– FizzBuzzから始める、Rust生活を。</p>
</blockquote>

<p>(本記事は、某ラノベ<sup id="fnref:12"><a href="#fn:12" rel="footnote">12</a></sup>のパロディとして書かれており、設定およびセリフの一部を改変して借用しています。ちなみに本記事の初出は<strong>4/1</strong>であり、お察し頂ければと思います。)</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">ブラウザのFirefoxの開発を支援している非営利団体です。</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">ここではC/C++と比較しています。またJavaと比べてもnullやキャストのチェックが厳しいです。もちろん<code>unsafe</code>という魔法は使わないことが大前提ですが・・・</span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">再代入が許可されない場合、変数が指す値がプログラム中で変わることを考慮しなくて済むのでプログラムが理解しやすくなります。詳しくは「参照透過性」というキーワードで調べてみてください。</span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;">「シャドーイング」は「隠蔽する」という意味です。Rustのシャドーイングに関しては、<a href="https://doc.rust-jp.rs/book/second-edition/ch03-01-variables-and-mutability.html#a%E3%82%B7%E3%83%A3%E3%83%89%E3%83%BC%E3%82%A4%E3%83%B3%E3%82%B0" title="" target="_blank">ここ<i class="fas fa-external-link-alt fa-fw"></i></a>をご覧ください。</span><a href="#fnref:4" rev="footnote"> ↩</a></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">5.</span><span style="display: inline-block; vertical-align: top;">可変長引数はマクロを使う理由の一つであり、マクロで実現可能なことは他にも多くありますが高度な内容になるので本記事ではこれ以上は触れません。Rustのマクロは「衛生的」と言われており、比較的にカジュアルに使われている印象です。</span><a href="#fnref:5" rev="footnote"> ↩</a></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">6.</span><span style="display: inline-block; vertical-align: top;">文字列リテラルは正確には<code>&amp; 'static str</code>型を持ちます。<code>'static</code>はライフタイムと呼ばれており、プログラム初期化時に静的にアロケートされることを示しています。</span><a href="#fnref:6" rev="footnote"> ↩</a></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">7.</span><span style="display: inline-block; vertical-align: top;">可変長文字列から固定長の文字列を切り出して文字列スライスに変換することは可能です。</span><a href="#fnref:7" rev="footnote"> ↩</a></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">8.</span><span style="display: inline-block; vertical-align: top;">関数内で外部の変数は利用できませんが、外部の定数は利用可能です。定数は<code>const</code>を用いて宣言します。</span><a href="#fnref:8" rev="footnote"> ↩</a></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">9.</span><span style="display: inline-block; vertical-align: top;">原理主義的な考え方をすれば環境をキャプチャしないものはクロージャとは呼べないのかもしれませんが、少なくともRustではクロージャの構文で書かれたものはクロージャと呼びます。</span><a href="#fnref:9" rev="footnote"> ↩</a></li><li id="fn:10"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">10.</span><span style="display: inline-block; vertical-align: top;">「アナタ、怠惰デスね？」 (プログラマ的には褒め言葉)</span><a href="#fnref:10" rev="footnote"> ↩</a></li><li id="fn:11"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">11.</span><span style="display: inline-block; vertical-align: top;">末尾再帰および末尾再帰最適化については沼なので、深入りはオススメしません。それでもどうしても沼にハマりたい人は自己責任でお願いします（笑）。</span><a href="#fnref:11" rev="footnote"> ↩</a></li><li id="fn:11"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">11.</span><span style="display: inline-block; vertical-align: top;">タイトルを見てわからなかった人のために一応補足しておくと「Re:ゼロから始める異世界生活」です。</span><a href="#fnref:11" rev="footnote"> ↩</a></li></ol></div></div></div><div class="a2a_kit a2a_kit_size_32 a2a_default_style"><a class="a2a_dd" target="_blank" rel="noopener" href="https://www.addtoany.com/share"></a><a class="a2a_button_facebook"></a><a class="a2a_button_twitter"></a><a class="a2a_button_hatena"></a><a class="a2a_button_reddit"></a></div><script async src="https://static.addtoany.com/menu/page.js"></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/cats-cats-cats/2020/06/13/rust-influences/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Rustに影響を与えた言語たち</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/cats-cats-cats/2020/03/15/gijyutushoten_oensai/"><span class="level-item">技術書典 応援祭を応援してみる</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--><div><div class="popular-posts-box"><div class="popular-posts-box-title">article.related_posts</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-img"><a href="/cats-cats-cats/2022/12/12/2022-12-rust-practicality/" title="Rustの実用性が理解できる図を作成してみた 〜C/C++/Java/JS/Python/Go/TS/Elixirとの比較〜" rel="bookmark"><img src="/cats-cats-cats/gallery/daily/illustrated-rust/illustrated-rust.png" /></a></div><div class="popular-posts-title"><h3><div class="popular-posts-date">2022-12-12</div><a href="/cats-cats-cats/2022/12/12/2022-12-rust-practicality/" title="Rustの実用性が理解できる図を作成してみた 〜C/C++/Java/JS/Python/Go/TS/Elixirとの比較〜" rel="bookmark">Rustの実用性が理解できる図を作成してみた 〜C/C++/Java/JS/Python/Go/TS/Elixirとの比較〜</a></h3></div></li><li class="popular-posts-item"><div class="popular-posts-img"><a href="/cats-cats-cats/2021/12/23/sagemaker-studio-lab-rust/" title="無料でRustのJupyterLab機械学習環境を作る in AWS" rel="bookmark"><img src="/cats-cats-cats/gallery/thumbnails/rust-sagemaker-studio-lab.png" /></a></div><div class="popular-posts-title"><h3><div class="popular-posts-date">2021-12-23</div><a href="/cats-cats-cats/2021/12/23/sagemaker-studio-lab-rust/" title="無料でRustのJupyterLab機械学習環境を作る in AWS" rel="bookmark">無料でRustのJupyterLab機械学習環境を作る in AWS</a></h3></div></li><li class="popular-posts-item"><div class="popular-posts-img"><a href="/cats-cats-cats/2020/06/13/rust-influences/" title="Rustに影響を与えた言語たち" rel="bookmark"><img src="/cats-cats-cats/gallery/daily/others/rust-influences.png" /></a></div><div class="popular-posts-title"><h3><div class="popular-posts-date">2020-06-13</div><a href="/cats-cats-cats/2020/06/13/rust-influences/" title="Rustに影響を与えた言語たち" rel="bookmark">Rustに影響を与えた言語たち</a></h3></div></li><li class="popular-posts-item"><div class="popular-posts-img"><a href="/cats-cats-cats/2020/12/06/7_reasons_rust_lambda/" title="RustとLambdaの相性が良い7つの理由 〜RustでLambdaをやっていく〜" rel="bookmark"><img src="/cats-cats-cats/gallery/thumbnails/rust_heart_lambda.png" /></a></div><div class="popular-posts-title"><h3><div class="popular-posts-date">2020-12-06</div><a href="/cats-cats-cats/2020/12/06/7_reasons_rust_lambda/" title="RustとLambdaの相性が良い7つの理由 〜RustでLambdaをやっていく〜" rel="bookmark">RustとLambdaの相性が良い7つの理由 〜RustでLambdaをやっていく〜</a></h3></div></li><li class="popular-posts-item"><div class="popular-posts-img"><a href="/cats-cats-cats/2020/12/31/2020-last/" title="2020年の技術的な振り返り" rel="bookmark"><img src="/cats-cats-cats/gallery/thumbnails/pose_furikaeru_man.png" /></a></div><div class="popular-posts-title"><h3><div class="popular-posts-date">2020-12-31</div><a href="/cats-cats-cats/2020/12/31/2020-last/" title="2020年の技術的な振り返り" rel="bookmark">2020年の技術的な振り返り</a></h3></div></li></ul></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最近の記事</h3><article class="media"><figure class="media-left"><a class="image" href="/cats-cats-cats/2023/03/12/ten-key/"><img src="/cats-cats-cats/gallery/events/ten-key-4/tenkey-vol4.png" alt="3年ぶりに開催された天下一キーボードわいわい会 Vol.4に参加してきました"></a></figure><div class="media-content"><p class="date"><time dateTime="2023-03-11T22:28:45.000Z">2023-03-12</time></p><p class="title"><a href="/cats-cats-cats/2023/03/12/ten-key/">3年ぶりに開催された天下一キーボードわいわい会 Vol.4に参加してきました</a></p><p class="categories"><a href="/cats-cats-cats/categories/Tech/">Tech</a> / <a href="/cats-cats-cats/categories/Tech/Event/">Event</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/cats-cats-cats/2023/02/07/sap-on-aws/"><img src="/cats-cats-cats/gallery/daily/cloud/aws/sap-on-aws.png" alt="新しいAWS認定「SAP on AWS - 専門知識」は異質だが役に立つという話 〜合格体験談〜"></a></figure><div class="media-content"><p class="date"><time dateTime="2023-02-06T22:28:45.000Z">2023-02-07</time></p><p class="title"><a href="/cats-cats-cats/2023/02/07/sap-on-aws/">新しいAWS認定「SAP on AWS - 専門知識」は異質だが役に立つという話 〜合格体験談〜</a></p><p class="categories"><a href="/cats-cats-cats/categories/Tech/">Tech</a> / <a href="/cats-cats-cats/categories/Tech/CloudNative/">CloudNative</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/cats-cats-cats/2023/01/22/2022-last/"><img src="/cats-cats-cats/gallery/thumbnails/hofukuzenshin.png" alt="2022年の技術的な振り返り"></a></figure><div class="media-content"><p class="date"><time dateTime="2023-01-21T22:28:45.000Z">2023-01-22</time></p><p class="title"><a href="/cats-cats-cats/2023/01/22/2022-last/">2022年の技術的な振り返り</a></p><p class="categories"><a href="/cats-cats-cats/categories/Tech/">Tech</a> / <a href="/cats-cats-cats/categories/Tech/Miscellaneous/">Miscellaneous</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/cats-cats-cats/2022/12/12/2022-12-rust-practicality/"><img src="/cats-cats-cats/gallery/daily/illustrated-rust/illustrated-rust.png" alt="Rustの実用性が理解できる図を作成してみた 〜C/C++/Java/JS/Python/Go/TS/Elixirとの比較〜"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-12-11T22:28:45.000Z">2022-12-12</time></p><p class="title"><a href="/cats-cats-cats/2022/12/12/2022-12-rust-practicality/">Rustの実用性が理解できる図を作成してみた 〜C/C++/Java/JS/Python/Go/TS/Elixirとの比較〜</a></p><p class="categories"><a href="/cats-cats-cats/categories/Tech/">Tech</a> / <a href="/cats-cats-cats/categories/Tech/Language/">Language</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/cats-cats-cats/2022/02/22/cats-cats-cats/"><img src="/cats-cats-cats/gallery/profile/cats-cats-cats-logo.png" alt="スーパー猫の日なのでUI/UXのLT登壇したり、発信力を計ったりしてみた"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-02-21T22:28:45.000Z">2022-02-22</time></p><p class="title"><a href="/cats-cats-cats/2022/02/22/cats-cats-cats/">スーパー猫の日なのでUI/UXのLT登壇したり、発信力を計ったりしてみた</a></p><p class="categories"><a href="/cats-cats-cats/categories/Tech/">Tech</a> / <a href="/cats-cats-cats/categories/Tech/Miscellaneous/">Miscellaneous</a></p></div></article></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">リンク</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://zenn.dev/hinastory" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Zenn - hinastory</span></span><span class="level-right"><span class="level-item tag">zenn.dev</span></span></a></li><li><a class="level is-mobile" href="https://qiita.com/hinastory" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Qiita - hinastory</span></span><span class="level-right"><span class="level-item tag">qiita.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">カテゴリ</h3><ul class="menu-list"><li><a class="level is-mobile" href="/cats-cats-cats/categories/DIY/"><span class="level-start"><span class="level-item">DIY</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/cats-cats-cats/categories/DIY/Keyboard/"><span class="level-start"><span class="level-item">Keyboard</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/cats-cats-cats/categories/Tech/"><span class="level-start"><span class="level-item">Tech</span></span><span class="level-end"><span class="level-item tag">60</span></span></a><ul><li><a class="level is-mobile" href="/cats-cats-cats/categories/Tech/Book/"><span class="level-start"><span class="level-item">Book</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/cats-cats-cats/categories/Tech/CloudNative/"><span class="level-start"><span class="level-item">CloudNative</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/cats-cats-cats/categories/Tech/ComputerScience/"><span class="level-start"><span class="level-item">ComputerScience</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/cats-cats-cats/categories/Tech/Event/"><span class="level-start"><span class="level-item">Event</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/cats-cats-cats/categories/Tech/Language/"><span class="level-start"><span class="level-item">Language</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/cats-cats-cats/categories/Tech/MachineLearning/"><span class="level-start"><span class="level-item">MachineLearning</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/cats-cats-cats/categories/Tech/Miscellaneous/"><span class="level-start"><span class="level-item">Miscellaneous</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/cats-cats-cats/categories/Tech/Web/"><span class="level-start"><span class="level-item">Web</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">アーカイブ</h3><ul class="menu-list"><li><a class="level is-mobile" href="/cats-cats-cats/archives/2023/03/"><span class="level-start"><span class="level-item">2023-03</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/cats-cats-cats/archives/2023/02/"><span class="level-start"><span class="level-item">2023-02</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/cats-cats-cats/archives/2023/01/"><span class="level-start"><span class="level-item">2023-01</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/cats-cats-cats/archives/2022/"><span class="level-start"><span class="level-item">2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/cats-cats-cats/archives/2021/"><span class="level-start"><span class="level-item">2021</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/cats-cats-cats/archives/2020/"><span class="level-start"><span class="level-item">2020</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/cats-cats-cats/archives/2019/"><span class="level-start"><span class="level-item">2019</span></span><span class="level-end"><span class="level-item tag">35</span></span></a></li><li><a class="level is-mobile" href="/cats-cats-cats/archives/2018/"><span class="level-start"><span class="level-item">2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">タグ</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/AWS/"><span class="tag">AWS</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/AdventCalendar/"><span class="tag">AdventCalendar</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/Algorithm/"><span class="tag">Algorithm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/Azure/"><span class="tag">Azure</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/Blog/"><span class="tag">Blog</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/Book/"><span class="tag">Book</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/CDK/"><span class="tag">CDK</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/CategoryTheory/"><span class="tag">CategoryTheory</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/Cats/"><span class="tag">Cats</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/Certification/"><span class="tag">Certification</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/Compiler/"><span class="tag">Compiler</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/Container/"><span class="tag">Container</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/Diet/"><span class="tag">Diet</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/Dotty/"><span class="tag">Dotty</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/Environment/"><span class="tag">Environment</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/ErgoDash/"><span class="tag">ErgoDash</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/Event/"><span class="tag">Event</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/Exam/"><span class="tag">Exam</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/FizzBuzz/"><span class="tag">FizzBuzz</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/Flourish/"><span class="tag">Flourish</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/GCP/"><span class="tag">GCP</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/Game/"><span class="tag">Game</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/Git/"><span class="tag">Git</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/Go/"><span class="tag">Go</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/IaC/"><span class="tag">IaC</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/Interpreter/"><span class="tag">Interpreter</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/Jupyter/"><span class="tag">Jupyter</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/Keras/"><span class="tag">Keras</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/Keyboard/"><span class="tag">Keyboard</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/Keymap/"><span class="tag">Keymap</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/M1/"><span class="tag">M1</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/MLOps/"><span class="tag">MLOps</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/Mac/"><span class="tag">Mac</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/MachineLearning/"><span class="tag">MachineLearning</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/MakerFaire/"><span class="tag">MakerFaire</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/Mind/"><span class="tag">Mind</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/Minikube/"><span class="tag">Minikube</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/OGP/"><span class="tag">OGP</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/Qiita/"><span class="tag">Qiita</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/ReView/"><span class="tag">ReView</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/Ruby/"><span class="tag">Ruby</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/Rust/"><span class="tag">Rust</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/SEO/"><span class="tag">SEO</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/Scala/"><span class="tag">Scala</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/Serverless/"><span class="tag">Serverless</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/Snowflake/"><span class="tag">Snowflake</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/StepFunctions/"><span class="tag">StepFunctions</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/TensorFlow/"><span class="tag">TensorFlow</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/TypeScript/"><span class="tag">TypeScript</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/UI-UX/"><span class="tag">UI/UX</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/WFH/"><span class="tag">WFH</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/Web/"><span class="tag">Web</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/WebAnalytics/"><span class="tag">WebAnalytics</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/gRPC/"><span class="tag">gRPC</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/html5/"><span class="tag">html5</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/k8s/"><span class="tag">k8s</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/npm/"><span class="tag">npm</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/oEmbed/"><span class="tag">oEmbed</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/cats-cats-cats/tags/pulumi/"><span class="tag">pulumi</span><span class="tag">1</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div class="level"><figure class="level-item image is-64x64 mx-auto"><img class="avatar is-rounded" src="https://www.gravatar.com/avatar/1d029a154310d0edb970e8caaf5dc5ec?s=128" alt="hinastory"></figure><div class="level-item"><div><p class="title is-size-4 is-block ml-1" style="line-height:inherit;display:block;">hinastory</p><p class="is-size-6 is-flex justify-content-center ml-3"><i class="fas fa-map-marker-alt mr-1"></i><span>Kanagawa, Japan</span></p></div></div></div></div></nav><nav class="level is-mobile"><p class="is-size-6 is-block">The more you reason the less you create</p></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">投稿</p><a href="/cats-cats-cats/archives"><p class="title">64</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">カテゴリ</p><a href="/cats-cats-cats/categories"><p class="title">11</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">タグ</p><a href="/cats-cats-cats/tags"><p class="title">60</p></a></div></div></nav><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/hinastory/"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/hinastory999"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/cats-cats-cats/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">カタログ</h3><ul class="menu-list"><li><a class="level is-mobile" href="#はじめに"><span class="level-left"><span class="level-item">1</span><span class="level-item">はじめに</span></span></a></li><li><a class="level is-mobile" href="#前提知識"><span class="level-left"><span class="level-item">2</span><span class="level-item">前提知識</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#FizzBuzzプログラムとは"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">FizzBuzzプログラムとは</span></span></a></li><li><a class="level is-mobile" href="#Rustとは"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">Rustとは</span></span></a></li></ul></li><li><a class="level is-mobile" href="#第一章-Rust生活-初級編"><span class="level-left"><span class="level-item">3</span><span class="level-item">第一章 Rust生活:初級編</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1日目-〜FizzBuzzでwhileとifに再会する〜"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">1日目 〜FizzBuzzでwhileとifに再会する〜</span></span></a></li><li><a class="level is-mobile" href="#2日目-〜FizzBuzzでforとrangeに出会う〜"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">2日目 〜FizzBuzzでforとrangeに出会う〜</span></span></a></li><li><a class="level is-mobile" href="#3日目-〜FizzBuzzでmatchにときめく〜"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">3日目 〜FizzBuzzでmatchにときめく〜</span></span></a></li><li><a class="level is-mobile" href="#4日目-〜FizzBuzzでガードを覚える〜"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">4日目 〜FizzBuzzでガードを覚える〜</span></span></a></li></ul></li><li><a class="level is-mobile" href="#第二章-Rust生活-中級編"><span class="level-left"><span class="level-item">4</span><span class="level-item">第二章 Rust生活:中級編</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#5日目-〜FizzBuzzでタプルに馴染む〜"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">5日目 〜FizzBuzzでタプルに馴染む〜</span></span></a></li><li><a class="level is-mobile" href="#6日目-〜FizzBuzzでmatchが式であることを認識する〜"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">6日目 〜FizzBuzzでmatchが式であることを認識する〜</span></span></a></li><li><a class="level is-mobile" href="#7日目-〜FizzBuzzで所有権と借用を意識する〜"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">7日目 〜FizzBuzzで所有権と借用を意識する〜</span></span></a></li><li><a class="level is-mobile" href="#8日目-〜FizzBuzzで高階関数とクロージャに目覚める〜"><span class="level-left"><span class="level-item">4.4</span><span class="level-item">8日目 〜FizzBuzzで高階関数とクロージャに目覚める〜</span></span></a></li><li><a class="level is-mobile" href="#9日目-〜FizzBuzzで畳み込みを実践する〜"><span class="level-left"><span class="level-item">4.5</span><span class="level-item">9日目 〜FizzBuzzで畳み込みを実践する〜</span></span></a></li></ul></li><li><a class="level is-mobile" href="#第三章-Truth-of-Rust"><span class="level-left"><span class="level-item">5</span><span class="level-item">第三章 Truth of Rust</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#10日目-〜FizzBuzzでコレクションとジェネリクスに気付く〜"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">10日目 〜FizzBuzzでコレクションとジェネリクスに気付く〜</span></span></a></li><li><a class="level is-mobile" href="#11日目-〜FizzBuzzでレムとの邂逅〜"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">11日目 〜FizzBuzzでレムとの邂逅〜</span></span></a></li><li><a class="level is-mobile" href="#12日目-〜FizzBuzzでトレイトと戯れる〜"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">12日目 〜FizzBuzzでトレイトと戯れる〜</span></span></a></li><li><a class="level is-mobile" href="#13日目-〜FizzBuzzをアドホックに改造する〜"><span class="level-left"><span class="level-item">5.4</span><span class="level-item">13日目 〜FizzBuzzをアドホックに改造する〜</span></span></a></li><li><a class="level is-mobile" href="#14日目-〜FizzBuzzで無限列に畏怖する〜"><span class="level-left"><span class="level-item">5.5</span><span class="level-item">14日目 〜FizzBuzzで無限列に畏怖する〜</span></span></a></li><li><a class="level is-mobile" href="#15日目-〜FizzBuzzで再帰的に死に戻る〜"><span class="level-left"><span class="level-item">5.6</span><span class="level-item">15日目 〜FizzBuzzで再帰的に死に戻る〜</span></span></a></li></ul></li><li><a class="level is-mobile" href="#まとめ"><span class="level-left"><span class="level-item">6</span><span class="level-item">まとめ</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/cats-cats-cats/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/cats-cats-cats/"><img src="/cats-cats-cats/gallery/profile/cats-cats-cats-logo.png" alt="cats cats cats" height="28"></a><p class="is-size-7"><span>&copy; 2023 hinastory</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("ja");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/cats-cats-cats/js/column.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><a id="back-to-top" title="トップに戻る" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/cats-cats-cats/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "このウェブサイトはあなたの経験を改善するためにCookieを使用しています。",
          dismiss: "了解しました",
          allow: "Cookiesを許可する",
          deny: "拒否する",
          link: "もっと詳しく知る",
          policy: "Cookieポリシー",
          href: "https://hinastory.github.io/cats-cats-cats/about/#%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9%E8%A7%A3%E6%9E%90%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="/cats-cats-cats/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="何かを入力してください..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/cats-cats-cats/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/cats-cats-cats/content.json"}, {"hint":"何かを入力してください...","untitled":"(無題)","posts":"投稿","pages":"ページ","categories":"カテゴリ","tags":"タグ"});
        });</script></body></html>