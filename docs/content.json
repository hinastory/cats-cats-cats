{"pages":[{"title":"お探しのページは見つかりませんでした。","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/cats-cats-cats/404.html"},{"title":"about","text":"当サイトについてhinastoryのブログです。興味のある技術を中心に記録していきます。 1. hinastoryについて2. リンクについて3. アクセス解析について4. 商品リンクについて5. 免責事項6. 著作権について7. 匿名で質問を投げる8. お問い合わせ 1. hinastoryについて10の質問風に答えてみます。 好きな言語ベスト5 Scala(バランスがいい) Ruby(書いていてきもちいー) JavaScript(ES2015以降はわりとまともになったので好き) C(システムプログラミングの雄) Haskell(いろいろな発想を学べる) 嫌いな言語ベスト5 機械語/アセンブリ言語(特に命令長が変わるCISCはツライ) C(ポインタやメモリ管理が面倒) C++(ごちゃ混ぜ感がある。テンプレートが吐くエラーで更に嫌いになった) BASIC(GOSUB,GOTOでスパゲッティ)(VBやVBAも好きではない・・・) Python(バージョン非互換がなければ・・・、あと特殊属性や特殊メソッドのアンダースコアも違和感) 5KL以上のソフトウェアを書いたことがある言語 C, Ruby, Scala, JavaScript, C++, C#, BASIC(N88 BASIC, Visual Basic, VBA), (HTML/CSS1) 1KL以上のソフトウェアを書いたことのある言語 Go, Python, lua, Lisp(Common Lisp/Emacs Lisp), Scheme, Java, シェルスクリプト, Haskell, アセンブリ(GAS) 写経したことがある言語 Perl, Tcl, Swift, R, AWK, OCaml, D, Delphi, Elixir, Erlang, TypeScript, Rust, Idris, Julia, Elm, Clojure, PowerShell 好きなエディタ・開発環境ベスト5 Emacs(キーバインドが忘れられない) IntelliJ IDEA(Scalaを書くにはこれ一択。が重い・・・) VisualStudio Code(そこそこ軽くて万能) VisualStudio(重いが機能は優秀) BoostNote(Markdownでメモを取るときのお供) 好きなOSベスト5 MacOS(毎日お世話になっております) iOS(あなたがいないと生活できません) Linux(Linux Mintが好き。もともとはVine Linux派だった・・・) Windows(一応実用的。プログラマーからすれば地獄。セキュリティ周りとか、UACとかどうしてこうなった・・・) 自作OS(昔某書籍の影響でチャレンジした覚えがある。いい思い出になった) 持っているキーボード メイン ErgoDash mini Iris サブ Ergo42 Planck Light 布教用/観賞用 Mint60 お世話になったもの FKB8579 ProgresTouch RETRO TINY 行ったことがある勉強会/カンファレンス/イベント RubyKaigi, 大江戸Ruby会議, ScalaMatsuri, GTC Japan, AWS Summit Tokyo, Developers Summit, Erlang & Elixir Fest, JapanContainerDays, Kubernetes Meetup Tokyo, プログラマのための圏論勉強会, 天下一キーボードわいわい会, 技術書典, Maker Faire Tokyo, コミケ…2 最近の興味、力を入れている分野 クラウドネイティブ, 機械学習, 圏論, 量子コンピューティング、自作キーボード 2. リンクについて当ブログはリンクフリーです。正規に公開されている箇所であればどこにリンクを貼って頂いても構いません。 3. アクセス解析について当ブログでは、アクセス解析ツールとしてGoogle アナリティクスおよびGoogle Search Consoleを利用しています。 これらはトラフィックデータの収集のためにCookieを使用しています。このトラフィックデータは匿名で収集されており、個人を特定するものではありません。この機能はCookieを無効にすることで収集を拒否することが出来ますので、お使いのブラウザの設定をご確認ください。 4. 商品リンクについて当ブログは、商品リンクをクリックすることで本ブログが紹介料を獲得できる手段を提供することを目的としたアフィリエイトサービス(もしもアフィリエイト)を利用しています。商品画像とともに設置された「Amazonで見る」や「楽天市場で見る」といったリンク画像が対象です。 5. 免責事項当ブログの記事は、記事公開時点で正しい情報を記載するように努めております。ただし、この記事が提供する情報、リンク先などによりいかなる損失、被害が発生したとしても責任は負いかねますので、ご了承ください。また、当ブログの記事は予告なく修正、追加、削除されることがあります。 また、本ブログの運営者である「hinastory」の「hinastory」名義の活動は全て個人の趣味としての活動であり、所属する組織および団体とは関係ありません。 6. 著作権について本ブログの著作権は、引用元が他所と分かる文章と画像を除いて、hinastoryが保持しています。本ブログ内のhinastoryが著作権を有する記事と画像(cats cats catのロゴ画像を除く)はCC BY 4.0()で公開されています。 cats cats catsのロゴ画像は本ブログのシンボルですので、本ブログを引用元として明示したい場合にご利用できます。それ以外の用途での利用はご遠慮ください。 7. 匿名で質問を投げる本ブログは記事に関する匿名の質問をマシュマロで受け付けています。 記事に対する質問や指摘があれば、気軽にマシュマロをお投げください3。 8. お問い合わせ本ブログに関するお問い合わせは以下へのメールでお願いします。 1.一応入れましたがプログラミング言語かと言われれば微妙です。 ↩2.ここ2、3年で行ったものです。小さいものは他にもあります。 ↩3.マシュマロの仕様により「ネガティブな内容、性的な内容、スパム等はAIがこっそり削除しちゃうので届きません」ということなので、該当するものは届いていないかもしれません。 ↩ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/cats-cats-cats/about/index.html"},{"title":"hexo-oembed demo page","text":"AboutThis is hexo-oembed plugin demo page. https://github.com/hinastory/hexo-oembed 1. oEmbed derivery compatible site demo1.1. YouTubeHexo tag1{% oembed https://www.youtube.com/watch?v=SX_ViT4Ra7k %} 1.2. TwitterHexo tag1{% oembed https://twitter.com/hinastory999/status/1089514744174632960 %} Kubernetes Meetup Tokyo #15 - KubeCon 2018 Recap に初参加 - cats cats cats https://t.co/O3ScDbSriz— hinastory (@hinastory999) January 27, 2019 1.3. Speaker DeckHexo tag1{% oembed https://speakerdeck.com/ladicle/recap-kubecon-plus-cloud-nativecon-north-america-2018-overview %} 1.4. SlideShareHexo tag1{% oembed https://www.slideshare.net/Odersky/preparing-for-scala-3 %} Preparing for Scala 3 from Martin Odersky 1.5. VimeoHexo tag1{% oembed https://vimeo.com/311121738 %} 1.6. pixivHexo tag1{% oembed https://www.pixiv.net/member_illust.php?mode=medium&illust_id=73112765 %} 1.7. TEDHexo tag1{% oembed https://www.ted.com/talks/susan_etlinger_what_do_we_do_with_all_this_big_data %} 1.8. Hatena BlogHexo tag1{% oembed https://rheb.hatenablog.com/entry/rhel8-python %} 2. oEmbed compatible (not support derivery) site demo2.1. flickrHexo tag1{% oembed https://www.flickr.com/photos/blueocean64/23831182193/in/photolist-CiT3cB-8Xbpns-quxdK6-cxB7vf-81BAtk-qC3LMs-bsndSq-81BAtt-wMHSBN-968ZuJ-7QdcHk-db2PFA-nZej15-7eQU7R-81BAti-egYg7p-dXL2hM-eUzjBM-81BAsx-2aVgqBo-4v2775-8DZJiq-aNfwDM-6M32zM-8HfqGw-mW86ZG-8DLjGC-4Yuujs-8Xbpa3-7FwpTe-52Vouq-5FT3Xr-cfXkk7-4YnhUK-9uhCgE-pTVRrq-aNJhs4-rYiKwt-7CjqHW-4jj4cZ-85EEX3-cr4wTW-ns4uE2-WjeQmQ-bJQyaM-fPTxwt-7TH4Dc-cr4wpG-oWgvSG-8X8oux %} endpoint configuration123flickr: match: flickr url: http://www.flickr.com/services/oembed/ 2.2. InstagramHexo tag1{% oembed https://www.instagram.com/p/BCOEogDOmpO/ %} endpoint configuration123instagram: match: instagram url: http://api.instagram.com/oembed/ View this post on Instagram The Famous Registan Square, the Heart of Gorgeous Samarkand City, Uzbekistan Winter 2014 🌙 (PHOTO By @hurshidnarimov ) ° ° ° ° ° #tourbeen_tour_and_adventures #withthebestguide @hurshidnarimov #greattour #friendstravel #travellingthroughtheworld #thetravellingfriends #withthebestguide #bestjourney #art #uzbekart #bestdestinations #uzbekculture #worldheritage #silkroad #friendstravel #travellingthroughtheworld #thetravellingfriends #bestjourney #art #uzbekart #bestdestinations #uzbekculture #worldheritage #silkroad #symbols #architecture #architecturephotography #bestblue #tourbeen_tour_and_adventures #bestphotographer #bestphotogram #bestphoto #gorgeousheritage #heritage #bestlandscape A post shared by 🧿TOURBEE’N VIAGGI🏆 (@tourbeen_tours_and_adventures) on Feb 25, 2016 at 10:48am PST 2.3. GyazoHexo tag1{% oembed https://gyazo.com/1fe1c370e1e82957b4f10b174fa02fef %} endpoint configuration123gyazo: match: gyazo url: https://api.gyazo.com/api/oembed/ 3. More infomationhexo-oembed related posts(Japanese) HexoのoEmbedプラグインをnpmに公開した話(前編) HexoのoEmbedプラグインをnpmに公開した話(後編) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/cats-cats-cats/hexo-oembed-demo/index.html"}],"posts":[{"title":"ようこそキーマップ沼へ","text":"以下のErgodash miniの記事では書ききれなかったキーマップについて紹介します。 サイレントでホットスワップなErgoDash miniを制作(前編) サイレントでホットスワップなErgoDash miniを制作(後編) 目次1. そうだ、キーマップをいじろう！2. QMK Firmware辛い問題3. 僕が考えた最強のキーマップ 1. そうだ、キーマップをいじろう！自作キーボードを始めた理由の一つがキーマップを自由にいじりたいという動機からでした。もともと英語キーボードが好きでしかも「A」の横がCtrlしか許せない派だったので色々と苦労していました。キー配置を自由にできたらと何度夢見たことか・・・ しかし、自作キーボードを手に入れたことで状況は一変しました。QMK Firmwareというものを使えばキーマップを自由にイジり放題だと言うのです。思えばCtrl以外にもいろいろと入れ替えたいキーがあるのでぜひ色々と試してみたいとQMK Firmwareを触りはじめました・・・ツライ・・・ 2. QMK Firmware辛い問題まず、簡単にキーマップを書き換えるために何をすればいいか簡単に説明すると、前述のQMK Firmwareの主にkeymap.cを書き換えて、ビルドと転送を行います。これだけだと簡単に聞こえるかもしれませんが、修正しなければイケナイのはC言語ファイルなんですよね・・・ちょっと記述を間違えると謎のコンパイルエラーに出くわして頭を抱えたりします。あと、最初はQMK Firmware独自の概念に悩まされたりします。レイヤーとかレイヤーとかレイヤーとか・・・ 例えばErgodash miniで光っているLEDを消したいとしましょう。どうすればいいのかというとQMK Firmwareには特殊キーが定義してあってそのキーを押すとシフトキーみたいにキー全体の定義を変更させる機能があります。これがレイヤーと呼ばれていてこのレイヤーは複数定義できるので単純なキー数の何倍もの定義が必要になったりします。Ergodash miniには初期設定でQwertyとRaiseとLowerとAdjustの4つが定義されていて、デフォルトのレイヤーはQwertyになります。話を元に戻すと、LEDを消すためににはAdjustレイヤーの「RGB ON」とコメント書かれているキーを押さないといけないのですが、このレイヤーを出現させるためには何とLowerキーとRaiseキーの同時押しが必要になります。完全に初見殺しですね。しかも、これはQMK Firmware標準機能というわけではなく一部のキーボートで採用されている方式です。keymap.cの後ろの方にさり気なくC言語の関数で実現されています。 もう何というか、何とかして欲しいですね・・・自作キーボードなんだから自分で何とかするのが筋なのは分かっていますが、ちょこっとキーを修正したい場合にいちいちCファイルを修正してビルドと転送を繰り返すのはかなり面倒です。Ergodash miniの場合は自分が見てきたkeymap.cの中では比較的見やすい方でしたが、レイヤーを自分好みにするために全面的に書き換えたのでかなり大変でした・・・一応QMK ConfiguratorというWebベースのツールもあるみたいですが、まだまだ機能が足りていないというかそもそもErgodashのような物理キーの変更はどうするのかとか課題がありそうです。自分はレイアウトの確認のみに利用しています。 3. 僕が考えた最強のキーマップ前置きが長くなってしまって申し訳ございません。以下が「僕が考えた最強のキーマップ」です(笑)。 以下がキーマップのポイントです レイヤーは４つ Qwertyレイヤーは通常配列 Lowerレイヤーはカーソル移動 RaiseレイヤーはNum Padと記号 AdjustレイヤーはBacklight調整とファンクションキー スペース、エンター、バックスペース、シフトを親指で押す 左手親指でレイヤー切り替えて、右手でキー入力 日本語入力切り替えはMacスタイル(英数キーでIMEオフ/かなキーでIMEオン) Adjustレイヤーは同時押しが嫌だったので専用キーを割り当てて、ここにファンクションキーも押し込んでいます。LowerとRaiseの使い方特殊で基本的に左手親指でレイヤー切り替えのキーを押して右手でキーを打つスタイルです。Lowerレイヤーの出し方も特殊でスペースキーの長押しかEnterキーの長押しで出すようにしています。Enterキーにも割り当てた理由は右手だけでカーソル移動ができるようにするためです。そして自作キーボード界隈では親指酷使スタイルです。このスタイルになれると小指の負担が軽減されてキータイプしやすくなったと感じています。 自分は他にもErgo42やIrisやPlanckキーボードも持っていますが、直行配列のキーボードは大体こんな感じのレイアウトで統一しています。以下にキーマップを公開しているので気になる人は参考にしてみてください。 hinastory/qmk_firmwarekeyboard controller firmware for Atmel AVR and ARM USB families - hinastory/qmk_firmware document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/cats-cats-cats/2019/01/12/keymap/"},{"title":"GitHubのプライベートリポジトリに移行した話","text":"新年そうそうビッグニュースが流れてきました。GitHubがプライベートリポジトリをタダで使わせてくれるってよ! GitHub、無料ユーザーもプライベートリポジトリを使い放題にGitHubが、無料ユーザーもプライベートリポジトリを無制限に使えるようにした（共有は3人まで）。料金体系は変わらないが、有料プランの名称も少し変わった。 目次1. これまで2. なんでそんな運用にしていたのか？3. 現在3.1. 移行方法3.2. 注意点4. まとめ 1. これまでこれまではパブリックなリポジトリはGitHubにおいて、プライベートなリポジトリは自宅のKubernetes上にGitBucketを立てて、そこに置いていました。 gitbucket/gitbucketA Git platform powered by Scala with easy installation, high extensibility & GitHub API compatibility - gitbucket/gitbucket 2. なんでそんな運用にしていたのか？Gitを使っているとなんでもGit管理したくなってきました。しかし、パブリックにおいても良いデータはGitHubで問題ありませんでしたが、どうしてもパグリックにしたくないデータもGit管理しようとすると困りました。GitHubは当時プライベートリポジトリを使うために月$7も必要だったのです。払えないわけではないですが、流石にちょっとしたデータを管理するためには高すぎるなぁと感じて躊躇していました。それではGitLab等のプライベートリポジトリが無料で使える所にしようかとも考えましたが、さすがにパブリックなリポジトリをGitLabに移行すると色々とリンクが切れて面倒なので諦めました。 それではプライベートなリポジトリだけGitLab管理にすればいいかというと.gitconfigに登録してあるメールアドレスの切り替えが面倒でした。GitHub上に公開しているコミットログに実運用しているメールアドレスを残すのは嫌だったのでGitHubのnoreplyメールアドレス(1696779+hinastory＠users.noreply.github.com)を設定していましたが、それをGitLabではそれを切り替える必要があります1。最初はローカルのgitconfigで対応しようとしましたがリポジトリ毎に設定しければならず面倒すぎました。 そして結局、自宅にGitBucketを立てて運用するに至ったわけで、自宅のファイル管理の大体のニーズは満たせました。しかし、それでもやっぱりプライベートでリポジトリを作成して落ち着いてからパブリックにしたいとかはやりたいわけです。そんなこと考えながらここ数年もやもやしていましたが、ここに来てやっと素晴らしいニュースに巡り会いました。 3. 現在GitBucketにあったリポジトリを全てGitHubのプライベートリポジトリに移行しました2。 3.1. 移行方法移行については簡単で、GitHubの画面右上の+ボタンからNew Repositoryを選択するとリポジトリの作成画面が表示されます。そしてその画面でPrivateを選択します。このときInitialize this repository with a READMEを選択しないでください。これを選択すると既存のレポジトリのpushができなくなります。 上記の画面でCreate repositoryを実行すると以下の画面が表示されるので、あとは既存のリポジトリ上で赤枠で囲った手順を実行するだけで移行は完了です。 3.2. 注意点一応注意点を上げるとすれば、プライベートなデータを上げる場合、最低限2段階認証は有効にしておくべきです3。2段階認証用のアプリには自分はGoogle Authenticatorを利用しています。あとFreeプランでは「Protected branches」、「Code ownedrs」、「Pages and wikis」、「Repository insights」の機能がプライベートリポジトリで使えません。プライベートリポジトリのコラボレータも３名までとなっています4。これらが使いたくなったら素直にProプランに移行すべきですね。 4. まとめFreeプランでプライベートリポジトリが使えるようになり、GitHubにリポジトリを統一できて幸せになれました。Gitbucketからの移行も元がGitなので非常に楽です。GitHubがMicrosoftに買収されたときはどうなることやらと思いましたが、この決断はGood Jobと言わざるを得ません。恐らくGitLabへの対抗処置だとは思いますが、今後も競い合ってより良いサービスになってくれることを願って止みません5。 1.プライベートリポジトリだけなら気にしないという手もありますが、やはりGitLabにGitHubのnorelyメールアドレスが入るのは抵抗があるので、切り替える必要がありました・・・ ↩2.ついでにローカルのリポジトリも整理して、GitHubからクローンしたものをお行儀悪く直接修正したりしていたリポジトリを、ちゃんとフォークとリベースをしてGitHubにpushしました。こちらの作業の方が実は大変でした・・・ ↩3.プライベートなデータを上げなくてもセキュリティのために2段階認証はオススメです。 ↩4.パブリックリポジトリでは今までどおりの機能が使えてコラボレータも無制限です。詳細はGitHubの料金プランをご確認ください。 ↩5.いいサービスなら月500円までなら払いますが、$7はちょっと・・ ↩ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/cats-cats-cats/2019/01/13/github/"},{"title":"hexo-oembedを公開しました","text":"HexoにYouTubeなどのサイトを記事に埋め込むためのプラグインを作成して、npmに公開しました。この記事はそのプラグインの紹介記事です。 hexo-oembedembed oEmbed item on your Hexo article. プラグイン制作記事は以下に書きました。興味があればそちらも読んで頂けると嬉しいです。 HexoのoEmbedプラグインをnpmに公開した話(前編) HexoのoEmbedプラグインをnpmに公開した話(後編) 目次1. hexo-oembedについて2. インストール3. 使い方4. デモ4.1. YouTube4.2. Twitter4.3. Speaker Deck5. 設定5.1. className5.2. endpoints5.3. embedlyKey5.4. 設定サンプル6. リポジトリ 1. hexo-oembedについてhexo-oembedはブログ構築ツールHexoのプラグインで、投稿にYouTubeやSlideShareやSpeaker Deckやインスタグラム等さまざまなメディアをパーマリンクを指定するだけで埋め込むためのタグを提供します。埋め込みのための業界標準としてoEmbedというものがありますが、この仕様を利用しているためhexo-oembedという名前になっています。特徴は以下です。 oEmbed Discoveryのサポート YouTube, Vimeo, Twitter, SlideShare, Speaker Deck, CodePen, TED, pixiv等、oEmbed Discoveryに対応している様々なメディアを埋め込むことができます パーマリンクがoEmbed Discoveryに対応しているかどうかは、oEmbed Testerでしらべることができます oEmbedのエンドポイントを設定ファイルで指定可能 oEmbed Discoveryに対応していないサイトでも、oEmbedに対応していればoEmbedのエンドポイントを個別に設定ファイル(_config.yml)に指定することで埋め込めます Instagram, Gyazo, FlickrなどはoEmbedに対応しています エンドポイントはoEmbedのサイトから入手可能です 2. インストールnpmコマンドでインストールしてください。 1$ npm install hexo-oembed --save 3. 使い方埋め込みたいページのパーマリンクを指定するだけです。[maxwidth]と[maxheight]は埋め込みのオブジェクトに期待する最大幅と最大高を数値(ピクセル)で指定します。サイトが対応していればこの値を超えない埋め込みコンテンツを返してくれます。 1{% oembed permlink [maxwidth] [maxheight] %} 4. デモ貼ろうと思えば楽しくていくらでも貼れる感じですが重くなるので3つにしておきます。もっと見たい方は デモページをご覧ください。 4.1. YouTubeちょうどこれを書いているときに3億再生いきました。マトリョシカの頃から応援してたけどまさかここまで人気になるとは・・・1{% oembed https://www.youtube.com/watch?v=SX_ViT4Ra7k %} 4.2. Twitter1{% oembed https://twitter.com/hinastory999/status/1089514744174632960 %} Kubernetes Meetup Tokyo #15 - KubeCon 2018 Recap に初参加 - cats cats cats https://t.co/O3ScDbSriz— hinastory (@hinastory999) January 27, 2019 4.3. Speaker Deck1{% oembed https://speakerdeck.com/ladicle/recap-kubecon-plus-cloud-nativecon-north-america-2018-overview %} 5. 設定Hexoの設定ファイル(_config.yml)に以下の設定が可能です。 5.1. className埋め込まれたコンテンツに付与されるCSSクラスのベース名を指定できます。(デフォルト: oembed) 5.2. endpointsoEmbedプロバイダのエンドポイントを指定できます。(デフォルト: なし) oEmbedプロバイダは以下から取得できます。 https://oembed.com/#section7 oEmbedプロバイダのエンドポイントとしてmatchとurlが定義できます。パーマリンクのホスト名がmatchを含んでいた場合、そのエンドポイントが選択され,urlのアドレスでプロバイダに問い合わせます。 もしエンドポイントの定義にマッチしなかった場合は oEmbed Discoveryを利用してエンドポイントを探します。 例えばYouTubeはoEmbed Discoveryに対応しているのでendpointsにYouTubeの定義は必要ありません。 5.3. embedlyKeyもし、embedlyKeyを指定すればEmbed.lyにフォールバックします。 Embed.lyはoEmbedに対応していないサイトのoEmbed情報の提供も行っています。利用したい場合はサインアップして、APIキーの設定してください。 5.4. 設定サンプル_config.yml:12345678910111213oembed: className: oembed embedlyKey: endpoints: instagram: match: instagram url: http://api.instagram.com/oembed/ gyazo: match: gyazo url: https://api.gyazo.com/api/oembed/ flickr: match: flickr url: http://www.flickr.com/services/oembed/ 6. リポジトリ以下のリポジトリで開発しています。バグ報告、ご要望はIssuesへどうぞ。プルリクエストも歓迎です。 hinastory/hexo-oembedembed oEmbed item on your Hexo article. Contribute to hinastory/hexo-oembed development by creating an account on GitHub. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/cats-cats-cats/2019/02/07/hexo-oembed/"},{"title":"hexo-tag-detailsを公開しました","text":"HexoにHTML5の detailsタグ1を記事に埋め込むためのプラグインを作成して、npmに公開しました。この記事はそのプラグインの紹介記事です。 hexo-tag-detailsHTML5 details tag on your Hexo article 目次1. hexo-tag-detailsについて2. インストール3. 使い方4. 設定4.1. className4.2. open5. リポジトリ6. 最後に 1. hexo-tag-detailsについてhexo-tag-detailsはブログ構築ツールHexoのプラグインで、投稿にHTML5のdetailsタグを埋め込むためのタグを提供します。detailsタグを使うと以下のようなUIを追加できます。 猫は好きですか？ 好き 大好き 愛している 2. インストールnpmコマンドでインストールしてください。 1$ npm install hexo-tag-details --save 3. 使い方要約文と詳細文を書くだけです。ページを表示したしたときに詳細文を開いておく場合には、mode:openを指定します。指定しない場合は詳細文は閉じて表示されます。mode:closeは後で説明する設定でデフォルトを詳細文を開くにした場合に利用します。 123{% details [mode:open/close] summary text %}detail text{% enddetails %} 例1: 123{% details あなたの出身はどこですか? %}私は地球出身です。 水の惑星です!{% enddetails %} 上の例は以下のようなHTMLを生成します。1234 あなたの出身はどこですか?summary> 私は地球出身です。 水の惑星です!details> 表示は以下のようになります。あなたの出身はどこですか?私は地球出身です。 水の惑星です! 例2(mode:openを指定した場合): 12345{% details mode:open あなたの好きな食べ物は何ですか? %}1. お寿司2. 天ぷら3. すき焼き{% enddetails %} 上の例は以下のようなHTMLを生成します。12345678 あなたの好きな食べ物は何ですか?summary> お寿司li> 天ぷらli> すき焼きli> ol>details> 表示は以下のようになります。あなたの好きな食べ物は何ですか? お寿司 天ぷら すき焼き 4. 設定4.1. classNameclassName はCSSクラス名を指定します。 (デフォルト: なし) 4.2. openopenは最初から詳細文を開いておくかどうかを指定します(デフォルト: false) _config.yml123tag_details: className: open: false 5. リポジトリ以下のリポジトリで開発しています。バグ報告、ご要望はIssuesへどうぞ。プルリクエストも歓迎です。 hinastory/hexo-tag-detailsHTML5 details tag on your Hexo article. Contribute to hinastory/hexo-tag-details development by creating an account on GitHub. 6. 最後にこのタグを作ったきっかけは「10の質問」をこのサイトでやってみようと思ったことです。 10の質問をやろうと思うと質問の解答が質問よりボリュームが多くて全体的に見づらくなることが分かりました。そこで質問の解答部分を折り畳めるようにしようとおもったのですが、HTML5のdetailsタグを直接HexoのMarkdownに埋め込むとうまく動作しないことが分かりました。改行を有効にしていたので途中でが入ってしまったのです。 もしかしたら、すでにdetailsのタグプラグインを作っている人がいるかも知れないと思って探して見ましたが、なかったので自分で作ってしまいました。大したことないタグですが、使って頂ければ幸いです。 1.流石に今どきHTML5のタグをサポートしていないブラウザなんてないと思っていましたが、IEとEdgeはだめなようです・・・もちろん表示されないわけではなく、タグが無視されて表示されるので見れないわけではないです。誰もIEやEdgeなんて使っていないですよね？少なくともこのブログのアクセス解析の結果、賢明な読者様の中にはそういう方はいらっしゃらなかったようなので遠慮なくdetailsタグを使えました。まぁ、IEはすでに非推奨ですしEdgeもChromeベースになるらしいので将来的にはdetailsタグの互換性を気にする必要はなくなるはずです。 ↩ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/cats-cats-cats/2019/03/09/hexo-tag-details/"},{"title":"技術書典6に一般参加した話","text":"技術書典に一般参加してきました。なにげに第1回から皆勤賞です。天候に恵まれない印象が強いですが、今日はなんとか雨に降られずに済みました。そのおかげもあってか1万人以上の参加者が来場した模様です。 技術書典6技術書の祭典が2019年04月14日（日）＠池袋サンシャインシティ2F 展示ホールD（文化会館ビル2F）で開催決定！ 目次1. 日時と場所2. 開場前3. いざ戦場へ4. 戦利品5. 感想 1. 日時と場所日時と場所は以下のとおりです。池袋駅から徒歩で10分ほどで到着しました。 日時 2019年4月14日 (日) 11:00〜17:00 場所 池袋サンシャインシティ2F 展示ホールD （文化会館ビル2F） 2. 開場前サンシャインシティの展示ホールには10時少し前に着きましたが、すでにかなり長い待機列ができていました。待っている間に かんたん後払いアプリを導入しておきます。導入時に注意しておくべきことは認証用のSMSの確認コードが「海外の電話番号」から届くことです。自分は海外の電話番号のSMSを拒否する設定になっていたので通知が届かず少し焦りましたが、なんとかこのページを見て問題は解決しました。 後払いアプリは以下のような感じで、「購入する」ボタンを押すとカメラが立ち上がります。そしてブースに表示されているQRコードを読み込むと物販の選択肢が表示されて購入ボタンを押すと購入ができます。購入後に表示された画面を販売者に見せると購入した物が渡されます。右側のキャプチャ画像は購入したもの一覧です。これは非常に便利で以前にやらかした2度買いを防げそうです・・・ このようにキャッシュレスは非常に楽でいい感じです。これがコミケだと常に1000円札や500円玉の残りを意識しなければいけないので、購入者も販売者も面倒くさいことこの上ないです1。ただ一つの難点は想定以上に買いすぎてしまうことです。なので、買った合計金額の表示と予算設定ができるようになるともっと使いやすくなるのではと思いました。 また、今回から「一般参加は11時〜13時の2時間のみ有料（雨天時は無料)」というルールに変わったようで、待機列で待っている間に1000円でチケットを購入しました。そして入場時にはチケットを掲げて入るという、「伝統の確認方法」で入場しました(笑)。 #技術書典 一般参加の待機列にこれからお並びの方は、入口向かって左側の通路を突き当たりまでお進みください。一般入場券は待機列のそばで販売しております。入場の際は入場券を高くかかげてお進みください。また会場前の入口付近では公式ファンブック「技術季報」も販売しています。 pic.twitter.com/D9cllWiI2u— 技術書典公式アカウント (@techbookfest) April 14, 2019 3. いざ戦場へとにかく会場の込み具合は半端ない感じでした。まぁ、1万人も詰めかければそうなるでしょうね・・・ #技術書典 にお越しの皆さまにお知らせします。ただいま会場内が大変混雑しております。場内に入られましたらゆっくりと歩いてお進みください。 pic.twitter.com/fb4Q8suHOZ— 技術書典公式アカウント (@techbookfest) April 14, 2019 自分は目一杯楽しんで13時過ぎに離脱しました。というか体力の限界です。看板を横目に買い忘れたものがあるのではないかという不安を抱えながら立ち去りました・・・ #技術書典 一般入場は予定どおり11時開始となります。お時間になりましたら待機列の皆さんを順次ご案内してまいりますので、どうぞ走らずゆっくりとお進みください。 pic.twitter.com/BVF4PjJK1V— 技術書典公式アカウント (@techbookfest) April 14, 2019 4. 戦利品さて、早速ですが戦利品のご紹介です。といってもほとんど読めていないので書影だけで失礼いたします2。中には Boothで購入できるものもあるので、気になるカバーがあれば調べてみてください。 ネタ枠は２つあって一つはオライリーです。かるたとコーディングマグネットを手が滑って購入してしまいました。 もう一つは自戒の意味を込めて購入しました。Fat Projectというカードゲームです3。胃が痛くなりそうなゲームです。過労死はヤバイ・・・ 5. 感想今回はあまり買わなかったな・・・とか思っていましたが、広げてみると結構ありました(笑)。薄い本でもこんなにたくさんの人が執筆するなんて本当に凄いと思います。自分は興味がとっちらかっているのでなかなか集中して一冊の本を書くのは難しそうだなと感じていますが、それでもいつかはチャレンジしてみたいと思いました。 技術書典はエンジニアのモチベーションを高めてくれる素晴らしいイベントだと思うので、まだ参加されていないエンジニアの方はぜひ一度現場に足を運んでみてください。エンジニアの熱量や一体感、新しい技術の波が肌で感じられるはずです。 記事は以上になりますが、最後に主催者、参加者の皆様、本当にお疲れ様でした！ 次回もあればぜひ参加して、あの熱気、あの息吹をまた感じたいと思います。1.販売者になったことはないので想像です・・・ ↩2.書影は自分がカメラで撮影したものです。光の関係で実物と印象が異なるものもあるかもしれませんがご容赦ください。 ↩3.写真は拡張パックのカードも含みます。俺たちは魔法使いじゃない！ ↩ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/cats-cats-cats/2019/04/14/tech-book-fest6/"},{"title":"あの頃の自分に読ませたい「怖くないQiita」をQiitaに書きました","text":"Qiitaって怖い・・・そう思っていたあの頃の自分に読ませたい最高のQiita入門記事をQiitaに書きました。恐らくこのクオリティならあの頃の自分に満足してもらえると思っています1。 怖くないQiita (2019年度版) - Qiita誰しもが最初は初心者です。分からないことに怯え、知らないことに恐怖します。**「Qiitaが怖い」**と思うのはQiitaに対して何かしらの**「壁」**を感じているからであり、その壁の正体を知り、正しく理解することが**「怖くないQ... ただ一つの懸念点としてはこの記事の内容が若干Qiita向けではないことですね・・・まぁ読んで頂ければ理由はわかりますが。ただ、初心者向けの記事なのでなるべく検索流入に期待できるQiitaに書いたほうがいいだろうという判断です。当然、文句を言われれば記事はこのブログに移しますが、内容自体はQiita自体のためになると思うので大目にみてもらえるのではないかと思っています。 1.「自分の中では」文句なく最高の入門記事ですが、当然全てのQiita初心者を満足させることができないことは理解しております。 ↩ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/cats-cats-cats/2019/07/17/unscared_qiita/"},{"title":"サイレントでホットスワップなErgoDash miniを制作(前編)","text":"2018年のキーボード納めとして、年末にErgoDash miniを組みました。ただ普通に作ったのでは成長がないので、以前よりやってみたかった静音化とキースイッチとProMicroのホットスワップ化に挑みます。 omkbd/ErgoDashkeyboard. Contribute to omkbd/ErgoDash development by creating an account on GitHub. 目次1. はじめに2. ErgoDash miniとは3. 制作工程3.1. 潤滑剤の塗布3.2. MogeMicro対策3.3. ダイオードの取り付け3.4. TRRSジャックとリセットスイッチの取り付け3.5. Undergrow LEDの取り付け3.6. 後編へと続く・・・ 1. はじめにこの記事は自作キーボード初心者から中級者向けの記事です。ただ「初めての自作キーボード制作」の場合、静音化とホットスワップ化は難易度が高い箇所があるので、まずはシンプルに一台目を組み上げて自信をつけてから挑戦することをオススメします1。実際の制作には公式のビルドガイドを熟読した上で進めてください。この記事は静音化とホットスワップ以外にもビルドガイドの行間とも言える一般的に躓きやすい箇所も説明を入れるように心がけました。これから作業する方の参考に少しでもなれば幸いです。 2. ErgoDash miniとは国内で購入可能なキーボードキットです。もともとErgoDashというものがあってそれよりもキーが一行少ないバージョンが今回制作したminiです。キーボードの特徴としては左右分離型で、一部の物理的なキー配置をカスタマイズすることができます。キー数は52～56キー（最下段をカスタマイズ可能、最大100パターン）です。ケースの関係上、親指あり/なしは購入時に選択する必要があります。 ErgoDash miniドキュメントより引用元 販売元 だっしゅきぃぼぉど - BOOTH ビルドガイド ErgoDash mini Build Guide 3. 制作工程実際に自分が行なった手順通りに書いていきます。前述のとおり公式のビルドガイドに含まれていない手順もあります。 3.1. 潤滑剤の塗布キーボードの静音化は主に以下の３つの対策があるようです。 静音用キースイッチを使う キースイッチ自体に静音化対策が施されています 潤滑剤を使う キースイッチを分解して、擦れる箇所に潤滑剤を塗布します スタビライザーを利用する場合は、スタビライザーにも塗布します O-ringを使う キーを強く打ったときの底打ちの音を抑えるものです 今回は上記の3つとも実施しました。まずはキースイッチを買うところからですが、今回はGateron Silent スイッチの赤軸を利用しました。Cherry MX互換のサイレントスイッチは他にも色々ありますが、とりあえず手っ取り早く入手できるものを選びました。今回キースイッチをホットスワップ化するので、まずは手持ちのキースイッチで初めて後で交換でも良いです。 次にキースイッチに潤滑剤を塗布します。lubeするとも言います。潤滑剤にも色々ありますが無色透明でプラスチックと金属に塗布可能なものから選択すれば良いです。どの潤滑剤がいいかは正直好みになります。音もそうですが打ち心地にも影響します。塗布箇所や塗布量によっても変わってくるのでいろいろなパターンで研究してみるのが一番いいかと思われます。今回は潤滑剤にKrytox GPL 105を使用しました。実際の塗布作業ですが、一つ一つキースイッチを分解して潤滑剤を筆で塗る作業です・・・長く・辛い作業です・・・しかしこの苦痛を軽減するために以下の素晴らしい治具の数々があります。キースイッチオープナーはほぼ必須ですが他も揃えておいたほうが断然楽です。自分の場合、以下の治具を使って2時間かかりました2。 キースイッチオープナー スイッチステムホルダー キースイッチオープナー用オプション スイッチ Lube Station 以下の写真は実際にlube作業中の風景です。キースイッチオープナーで必要なキースイッチの個数を分解して、パーツごとに選り分けておきます。その後スイッチの下側部分をLubeステーションにはめ込みます。あとは下側部分に一気に塗布した後、バネと軸を順番に塗布して下側部分に乗せて、最後に上部を戻して完成です。 3.2. MogeMicro対策これも公式ビルドガイドには書いていませんが、大事なことなので記載しておきます。キットに付属しているPro microはMogeMicroという蔑称を授けられるほど、USB端子部分が破損しやすいです。何も対策をしないと何回かケーブルを抜き差ししているうちにポロリと逝ってしまわれます。対策は自分の観測範囲で以下の4つがありました。今回は1.を実施しておきます。2.も合わせて購入しておけばさらに安心です。3.はお金に余裕がある人向けです。4.はここを読まれている方にはとりあえず無視してもらって構いません・・・気になる方は調べてみてください。 エポキシ系樹脂で固める 磁石で着脱可能なmicro USBケーブルにする Pro micro スイッチサイエンス版を買う BLE Micro Proを使って無線化する エポキシ系樹脂は２つの液剤を混ぜて使うタイプのものです。よく混ぜたらUSB端子の側面に盛って行きましょう。注意点としてはスルーホールに液剤が流れ込まないようにすることと、USB端子の上部に液剤を盛るとケースに干渉するので側面だけにしておくことです。もちろんUSB端子も塞いではいけません(笑)。液剤が固まるまでそこそこ時間がかかるのでMogeMicro対策は組み立て工程の最初に行っておくのがオススメです。 3.3. ダイオードの取り付けダイオードはキットに標準で付属するスルーホールに挿して使うタイプのものを使用します。表面実装タイプ(SMD)のものも利用できそうですが、はんだ付けの難易度がぐっと上がるので今回は見送りました。ダイオードを取り付ける前にダイオードの足を曲げる必要がありますが、正しい長さで曲げないとスルーホールにきちんと嵌らないので楽をしたいなら治具(リードベンダ ー)を使うことをオススメします。 ダイオードの足を曲げ終えたら一度PCBに全て挿してダイオードの向きが間違えていないか、挿し忘れがないか確認します。ここは本当に何回も見直したほうが良いです。はんだ付けしたあと間違いを見つけると心が折れてしまいます・・・あとErgoDashではダイオードの隣に抵抗のスルーホールがある箇所があるので差し間違いが容易に起こりえます。公式のビルドガイドの写真で色分けされているのでしっかりと確認しましょう3。ダイオードの確認時はツールクリッパーという治具が役立ちます。下の写真のように基盤をツールクリッパーで固定すればダイオードを挿す工程と確認工程が非常に楽です。電子工作をしていると時々腕が足りなくなるので、とりあえず持っておいて損はないと思います。 ダイオードの確認が終わったらマスキングテープでダイオードを仮止めしてからはんだ付けに入ります。上の写真ではマスキングテープの代わりにカプトンテープを使っています4。ここからはようやくはんだ付けの作業です。今回は有鉛はんだを用いました。鉛は有害なので作業中は煙をなるべく吸わないようにしてこまめに換気しながら作業しました。はんだ付けは温度が命と言われていますので温度調整機能付きのはんだごてを使用します。ただし標準のの小手先だと母材に熱が伝わりにくいため小手先をC型のものに変えました。はんだ付けのコツは母材を温めてからハンダをそっと近づけて溶かして流し込む感じなそうですが、言葉だけでは伝わりにくいので一度YouTube等ではんだ付けの動画を検索してみることをオススメします。 3.4. TRRSジャックとリセットスイッチの取り付けTRRSジャックとリセットスイッチの取り付けは公式のビルドガイドの通りに実施すれば問題ないはずです。基盤の裏側に取り付けることだけを気をつけていれば十分です5。公式のビルドガイドではこの手順の前にオプションとしてBacklight LED用のパーツ取り付けがありますが、今回はBacklight LEDは取り付けないのでスキップします。というのも、Backlight LEDはスイッチの上から挿さないといけないため、スイッチをホットスワップにするとLEDもホットスワップにしないといけませんが今回はそこまで手が回りませんでした6。 3.5. Undergrow LEDの取り付けBacklight LEDに関しては一旦保留にしましたが、やはり光らせたいという欲求はあるのでUndergrow LEDを実装します。今までテープ型や砲弾型のLEDは実装したことがありましたが、チップ単体での実装は初チャレンジです。チップは公式で案内されているとおりWS2812Bを電子工作の強い味方、秋月電子さんで購入しました。初期不良や取り付け途中で壊してしまうことも考慮して5セット分余分に購入しました。汎用LEDなので余った分は他の電子工作で使う予定です。 公式のビルドログのとおりUndergrowを有効にするにはマスター(USBを挿す方)を決めて、はんだでジャンパする必要があります。このはんだだけでジャンパさせる方法も最初は慣れませんでしたが、ショートさせたいランドの双方にはんだを盛った後(予備ハンダ)、はんだを供給しながら小手先で盛ったはんだを溶かして繋ぐように動かせばうまくいくようになりました。そしていよいよLEDのはんだ付けですが、意外とLEDが小さいので思ったよりは面倒でした。取り付けの際に注意したほうがいいと思ったのは以下の3点です。 LEDの方向に注意する LEDが浮かないように注意する LEDを熱で壊さないようにする LEDには方向があります。公式のビルドガイドを見て方向を間違わないようにしましょう。LEDは直列につながっていて、ErgoDash miniではマスターの内側から外側に向けてぐるっと回って、反対側の基盤の外側から内側に向けて繋がっている感じです。LEDの方向がわかったらマスキングテープでチップの片側を固定します。このときチップが浮かないように確認してください。チップが浮いてしまうと接続不良になる恐れがあります。マスキングテープは片側のはんだが終われば剥がして、もう片側をはんだします。また、LEDは非常に熱に弱いみたいです。有鉛はんだではんだ付けする場合340℃から360℃に温度を調整するのが一般的ですが、今回は260℃でなるべく短時間ではんだ付けするように意識しました7。はんだの方法はまず軽くランドを温めてはんだを盛った後、素早くチップの電極に触れてはんだを接着させました。電極にふれる時間はほんの一瞬です。 3.6. 後編へと続く・・・後編ではいよいよPro Microとキースイッチのホットスワップ化に挑みます。 サイレントでホットスワップなErgoDash miniを制作(後編)1.1台目はシンプルなものでも、いろいろ反省点や改善点が目に付きます。また、シンプルなものを知らないと何が良くなったのがわからないので、お楽しみは２台目以降にとっておきましょう。自分はこれで4台目ですが腕はまだまだです・・・ ↩2.アニメを見ながらだったので実際はもっと短く済むはずです・・・ ↩3.実際私は再確認で合計3箇所の間違いを発見しました・・・過信は禁物です。 ↩4.カプトンテープは絶縁にも使えるので持っておいて損はないです。 ↩5.基盤は右手側と左手側で裏表が逆になるので注意が必要です。 ↩6.公式のビルドガイドにありませんが、チップLEDにする方法もあるのでBacklight LEDに関しては後で検討します。。。 ↩7.ErgoDash miniのビルドガイドには、はんだ付けの推奨温度は書いてありませんでしたが、Helixのビルドガイドでは220℃を推奨していました。高い温度で行うとはんだが溶けやすく作業がしやすいのですが、LEDを熱で壊すリスクがあります。あくまで温度の調整は自己責任でお願いします。 ↩ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/cats-cats-cats/2019/01/06/ergodash-mini-1/"},{"title":"Kubernetes Meetup Tokyo　#15 - KubeCon 2018 Recap に初参加","text":"Kubernetes Meetup Tokyoに初参加しました。会場は六本木ヒルズのGoogle東京オフィスです。倍率2倍の抽選を潜り抜けて参加できることになりました。 Kubernetes Meetup Tokyo #15 - KubeCon 2018 Recap (2019/01/10 19:00〜)Kubernetes Meetup Tokyo #15を開催します！ コンテナをデプロイできる強力なシステム Kubernetes のことを詳しく聞く会です！ # 行動規範 (Code of Conduct) について Kubernetes Meetup Tokyoは、Kub… 目次1. Kubernetes Meetup Tokyo #15 - KubeCon 2018 Recapとは？2. 会場の様子3. 発表内容3.1. KubeCon + CloudNativeCon North America 2018 Overview - @ladicle3.2. Lightning Talk: Introduction to GitOps Deployment to Kubernetes - @sakajunquality3.3. Running VM Workloads Side by Side with Container Workloads - @amsy8103.4. Keynote: Developing Kubernetes Services at Airbnb Scale - @jyoshise3.5. Fly Your Containerized Environments by Joint Work of Harbor and Dragonfly - @capsmalt3.6. Securing Kubernetes With Admission Controllers - @tkusumi4. 食事5. 感想とまとめ 1. Kubernetes Meetup Tokyo #15 - KubeCon 2018 Recapとは？Kubernetes1 Meetup Tokyoは、東京都内で不定期に開催されるKubernetesに関する情報交換や交流を行うための勉強会で今回で15回目の開催です。Kubernetesに熱い情熱を捧げる有志の方々が運営されています。参加登録はconnpassから気軽に行えますが、ここ最近は人気が高く定員オーバーの状態が続いています。一般枠は激戦で参加できるかどうかは抽選なので運次第ですが、遠方枠や女性/LGBT枠は競争率が低いので条件を満たす人はオススメです。 今回のMeetupは「KubeCon 2018 Recap」という副題が示すとおり、昨年12月10〜13日にかけてシアトルで行われたKubeCon + CloudNativeConのおさらいです。KubeConは世界最大規模のKubernetesのカンファレンスで、前回は8000人を超える参加者と100を超えるスポンサーが集結しました。 2. 会場の様子実は六本木ヒルズ自体も初めてだったので、開場の10分前くらいに到着して周囲を散策していまいた。場所はその名の通り六本木駅でコンコースで直結されていたので、東京メトロの地下からエスカレータで地上に出ると眼前に六本木ヒルズがそびえ立っていました。 六本木ヒルズ1階入り口の入ってすぐ左に臨時受付があり、そこで入館証を貰ってからエスカレータで43階のGoogleオフィスにお邪魔しました。 開場は食堂だったようで中央にオープンキッチンがあってその周囲にテーブルや椅子が配置されていました。さすがGoogleだけあってスペースも広く、ガラス張りの展望も素晴らしいものでした。Google東京オフィスは今年中に渋谷ストリームに移転するらしいので、その前にこれて良かったです。 Google日本法人、19年に大規模移転 「渋谷ストリーム」22フロア占拠Google日本法人は、2019年に六本木ヒルズから渋谷にオフィスを移転する。 3. 発表内容今回の発表はKubeCon参加者が参加したセッションの中から一つ選んで、その概要、なぜそのセッションが面白いのか、自身の業務課題との関わりについて話すというものでした。 3.1. KubeCon + CloudNativeCon North America 2018 Overview - @ladicle最初の発表は今回のKubeKonの概要を説明するものでした。開場の雰囲気や注目ポイントを発表されていました。印象に残ったのはKubernetesが退屈(Boring)なものになったというものですね。Kubernetesのコアの技術は十分に成熟してメインストリームで使われるようになり、Kubernetes本体よりもその周辺技術や応用例、運用関連に話題の方向性がシフトしてきている感じです。 3.2. Lightning Talk: Introduction to GitOps Deployment to Kubernetes - @sakajunquality次の発表は実際にKubeConでLightning Talkをした方の発表でした。テーマはGitOpsでDevOpsを一歩先に進めた感じのものでした。簡単に言うとGit上のコード変更やプルリクエストをトリガーにしてKubernetesの操作やCI/CDを自動化するというもので、その取り組みに関して解説されていました。プルリクエストとも連動させるとなるといろいろと考えることがありそうでした。しかし、テーマ自体も面白かったのですが、やはり実際にKubeConで話すための一連の裏話的な内容がとてもおもしろかったです。実際にCFPを出す所から話されていたので、今後発表しようと言う方にオススメの内容でした。 3.3. Running VM Workloads Side by Side with Container Workloads - @amsy810VMもKubeVirtを利用してコンテナと同じようにKubernetesで管理するという話。これができると今までOpenStack上にKubernetesを構築してたものが、Kubernetes上でVMを立ててその上に本番用のKubernetesを立てる運用も可能になりそうでした。正直OpenStackは構築も運用も想像以上にツライのでこれは非常に魅力ある話です。ただもちろん現在ではまだそんなに簡単ではなくて少なくともストレージとネットワーキングには頭を悩ませそうな感じでした。 3.4. Keynote: Developing Kubernetes Services at Airbnb Scale - @jyoshiseAirbnbが「Kubernetesツライ」をどのように対処したのかの説明でした。Kubernetesの何がツライかと言うと、マイクロサービス一つ作るだけでも、開発、ステージング、本番環境の３つにデプロイが必要で、さらに一つの商用サービスをつくるためにはそのマイクロサービスを大量に作らないといけないため、そのたびに大量の設定(yamlファイル)を書き、大量のコマンド(kubectl)を打たなければならいからということでした。前者のことは「YAMLの壁」と呼ばれていました。 YAMLの壁をAirbnbがどう解決したかと言うと既存のツールはいまいちだったので独自の生成ツールを作ったとのことでした。また発表者の方がshowKsというサービスを作ったときには、テンプレートを作って変数を置換するようにしていたそうです。helm、kustomize、kapitan等のツールはAirbnbでは却下されていましたが、一般的にYAMLに押しつぶされそうになったらまずはこれらから検討するのが良さそうです。 後者のkubectlの問題は独自のラッパーを作って対処したそうです。ktoolと呼ばれていてk一文字のコマンド名ですが、これだけでも腱鞘炎が減りそうです(笑)。 3.5. Fly Your Containerized Environments by Joint Work of Harbor and Dragonfly - @capsmaltサイズが大きいコンテナイメージを大規模な分散環境で効率よく、スピーディーに配信するために、HarborとDragonflyがあるよという話。Harbarがイメージ管理で、Dragonflyがイメージ配布のOSSです。どちらもAlibabaで採用されていて中国を中心に流行っているみたいです。 3.6. Securing Kubernetes With Admission Controllers - @tkusumiKubernetesのセキュリティーポリシーをどうやって定義、管理するかという話でした。KubernetesにはデフォルトでAdmission Controllerというセキュリティの仕組みがあって、その拡張ポイントとしてValidatingAdmissionWebhookがあるけど独自でポリシーを作り込むのはツライから、Open Porlicy Agent(OPA)という汎用ポリシーエージェントを使っていこうというものです。OPAはRegoというDSLでポリシーを書けるので作り込みは楽そうでした2。実際にk8sと連携させるためにはkubernetes-policy-controllerが必要とのことです。 4. 食事鉄板のピザとビール。ノンアルもあるよ!ナポリの窯は初めて食べましたが、評判通り美味しかったです。 5. 感想とまとめ運用のツラさで感じることはみんな大体同じで、様々な取り組みやツールがエコシステムとして整備されつつあると感じました。まさしく「Kubernetesは退屈」だからこそ安心して取り組める、そう感じたMeetupでした。非常に有意義なMeetupだったのでまた機会があれば参加してみたいと思います。 Kubernetesは退屈 成熟してメインストリームで使われ始めた 運用面や周辺技術に関心がシフト GitOpsをk8sに適用 GitOps VM管理をk8sで行う KubeVirt YAMLの壁、kubectlの壁に立ち向かう helm, kustomize, kapitan, ktool イメージ管理とイメージ配信 Harbor, Dragonfly セキュリティ Open Porlicy Agent(OPA), kubernetes-policy-controller 1.Kubernetesはご存知かもしれませんが一応説明しておくと、もともとはGoogleが開発して2014年に公開して、現在はCloud Native Computing Foundationの管轄下にあるコンテナオーケストレーションシステムです。よくk8sと略されます。去年の段階で同様のツールやシステムを押さえてほぼ一強状態で、昨今の盛り上がりはすごく、これから到来すると予想されるクラウドネイティブ時代の中心的な役割を担っています。 ↩2.話を聞いた限り、Regoはいろいろとクセが強そうな印象を受けました。=が比較だったり代入だったりするなど・・・ ↩ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/cats-cats-cats/2019/01/20/k8s-meetup-tokyo-15/"},{"title":"Go Modulesとマルチモジュール構成でGo Homeする方法","text":"Go Modulesでマルチモジュールにする方法がわからなくて調べました。発端は単にgo.modがある別モジュールのパッケージをインポートしようとしても出来なかったことです。そこで、Go Modulesでマルチモジュールを実現するためのシナリオを説明してみたいと思います。 TL;DR Go Modulesは便利なので使っていこう Go Modulesでマルチモジュール構成にする場合はgo.modファイルでreplaceディレクティブを使おう マルチモジュール構成の採用には慎重になろう 1. 目次1. 目次2. Go Modulesとは3. Go Modulesで管理を始める3.1. まずは基本のおはようの挨拶から3.2. おはようの挨拶をパッケージにしてみる3.3. Go Homeしようとして失敗する3.4. replaceのおかげでGo Homeに成功する4. なぜ、マルチモジュール化したかったのか？5. まとめ6. 参考文献 2. Go Modulesとはとりあえず、Go Modules is 何？という方の為に簡単に説明します。ご存知の方はこの節を飛ばしてください。 Go ModulesはGo 1.11から試験的に導入され、Go 1.13からデフォルトで有効になる予定の新しいパッケージ依存関係の管理方法です。使ってみた実感としてはすでに充分実用的なので新規にプロジェクトを作成する場合はGo Modulesを使って作成することをオススメします。Go 1.12でGo Modulesを有効にするためには、GOPATH以外のパスで作業をするか以下で環境変数を設定します。 1export GO111MODULE=on この記事ではGo 1.12の前提で解説します。 3. Go Modulesで管理を始める基本はディレクトリを作成してgo mod init で始められます。 123$ mkdir go-multi-modules$ cd go-multi-modules$ go mod init go-multi-modules go.modというファイルが作成されています。これが依存関係を管理するファイルになります。 go.mod123module go-multi-modulesgo 1.12 3.1. まずは基本のおはようの挨拶から早速ですが、基本どおりHello Worldから初めて見ます。ただし、依存関係を入れるために go-figureを利用して挨拶をしてみます。ソースコードは以下の通りです。 main.go12345678910package mainimport( \"github.com/common-nighthawk/go-figure\")func main() { myFigure := figure.NewFigure(\"Hello World\", \"\", true) myFigure.Print()} go buildをすると依存関係があるパッケージがダウンロードされて、ビルドされます。事前にgo getする必要がないので、これだけでもGo Modulesの良さがわかります。./go-multi-modulesで実行して無事挨拶ができれば成功です。 12345678$ go buildgo: finding github.com/common-nighthawk/go-figure latest$ ./go-multi-modules _ _ _ _ __ __ _ _ | | | | ___ | | | | ___ \\ \\ / / ___ _ __ | | __| | | |_| | / _ \\ | | | | / _ \\ \\ \\ /\\ / / / _ \\ | '__| | | / _` | | _ | | __/ | | | | | (_) | \\ V V / | (_) | | | | | | (_| | |_| |_| \\___| |_| |_| \\___/ \\_/\\_/ \\___/ |_| |_| \\__,_| go.modファイルを見てみるとrequireの行が追加されて依存関係が追跡されているのが分かります。 go.mod12345module go-multi-modulesgo 1.12require github.com/common-nighthawk/go-figure v0.0.0-20190529165535-67e0ed34491a また、go.sumというファイルも生成されます。依存関係の管理はgo.modだけでもできますが、go.sumは検査用に必要なようです。詳しくは ここを参照してください。 go.sum12github.com/common-nighthawk/go-figure v0.0.0-20190529165535-67e0ed34491a h1:kTv7wPomOuRf17BKQKO5Y6GrKsYC52XHrjf26H6FdQU=github.com/common-nighthawk/go-figure v0.0.0-20190529165535-67e0ed34491a/go.mod h1:mk5IQ+Y0ZeO87b858TlA645sVcEcbiX6YqP98kt+7+w= 3.2. おはようの挨拶をパッケージにしてみるさて、挨拶は毎日するものです。せっかくなので再利用可能なようにパッケージとして分離してみます。pkgディレクトリを作成し1、その下にhello-worldディレクトリを作成して、その下にhello-world.goファイルを作成します。ディレクトリ構成は以下の通りです。今回はhelloworldというパッケージを作成します。 ディレクトリ構成12345678.├── go-multi-modules // `go build`で生成された実行ファイル├── go.mod // `go mod init` で生成されたモジュール管理ファイル├── go.sum // `go build`で生成されたモジュール管理ファイル（検査用）├── main.go // メインファイル└── pkg └── hello-world └── hello-world.go // 新規追加 hello-world.goファイルの中身は以下の通りです。 hello-world.go12345678910package helloworldimport( \"github.com/common-nighthawk/go-figure\")func HelloWorld() { myFigure := figure.NewFigure(\"Hello World\", \"\", true) myFigure.Print()} main.goファイルは以下のように書き換えます。 hello-world.go123456789package mainimport ( \"go-multi-modules/pkg/hello-world\")func main() { helloworld.HelloWorld()} go buildでビルドして./go-multi-modulesで実行して同じように挨拶ができたら成功です。 3.3. Go Homeしようとして失敗するさて、挨拶も済んだのでもう用はありません。帰宅したくなってきたとします。ただし、帰宅時間まで細かく管理されたくないので別モジュールで管理することを考えます。この場合、pkgディレクトリ配下にgo-homeディレクトリを作成して、go-homeディレクトリに移動してからgo mod init gohomeを実行します。ディレクトリ構成は以下のようになります。 ディレクトリ構成1234567891011.├── go-multi-modules // `go build`で生成された実行ファイル├── go.mod // `go mod init` で生成されたモジュール管理ファイル├── go.sum // `go build`で生成されたモジュール管理ファイル（検査用）├── main.go // メインファイル└── pkg ├── go-home // このディレクトリ配下は別モジュールになる │ ├── go.mod // `go mod init`で生成される │ └── home.go // 新規追加 └── hello-world └── hello-world.go // 挨拶パッケージ go-home配下のgo.modは以下のようになります。初期化しただけなのでrequireはありません。 go.mod123module gohomego 1.12 home.goは以下のようになります。 home.go1234567package gohomeimport(\"github.com/common-nighthawk/go-figure\")func GoHome() { figure.NewFigure(\"Go Home!\", \"basic\", true).Scroll(30000, 400, \"right\")} main.goは以下のように書き換えます。 main.go1234567891011package mainimport ( \"go-multi-modules/pkg/hello-world\" \"go-multi-modules/pkg/go-home\")func main() { helloworld.HelloWorld() gohome.GoHome()} これをトップディレクトリ(go-multi-modulesディレクトリ)でgo buildでビルドしようとしたところ以下のようなエラーが出てうまくいきませんでした。どうやらモジュールの読み込みに失敗したようです。 12$ go buildbuild go-multi-modules: cannot load go-multi-modules/pkg/go-home: cannot find module providing package go-multi-modules/pkg/go-home 3.4. replaceのおかげでGo Homeに成功する解決方法は簡単で親のgo.modに以下のreplaceディレクティブを記述することでした。 replace go-multi-modules/pkg/go-home => ./pkg/go-home replaceディレクティブを記述してgo buildをするとビルドが成功します。以下はgo build後のgo.modです。依存関係(require)が追加されています。 go.mod12345678910module go-multi-modulesgo 1.12require ( github.com/common-nighthawk/go-figure v0.0.0-20190529165535-67e0ed34491a go-multi-modules/pkg/go-home v0.0.0-00010101000000-000000000000)replace go-multi-modules/pkg/go-home => ./pkg/go-home //追加 さて、ビルドできたら./go-multi-modulesで実行してみましょう。一瞬Hello Worldが表示されてその後Go Home!が実行されます。 我々はようやく成し遂げたのです（笑）。 4. なぜ、マルチモジュール化したかったのか？さて、ここまででマルチモジュール化の方法が分かったわけですが、問題の発端のなぜ自分がマルチプロジェクトにしたかったのかをまだ説明していませんでした。 理由としてはC言語のライブラリをビルドしてcgoで呼び出すモジュールを書いたのですが、makeでビルドする必要があったのでgitのサブモジュールでローカルに取り込もうとして、必然的にマルチモジュール構成になりました。ただ本家のFAQでは一つのリポジトリに一つのモジュールをススメているので、一般的にはマルチモジュールの採用には慎重になったほうがいいと思われます。 5. まとめ本記事ではGo Modulesにおける「マルチモジュール構成」に焦点を当てて、以下についてストーリ仕立てで解説しました。 Go Modulesを使って依存関係を管理する方法 パッケージに分割して呼び出す方法 マルチモジュール構成にする方法 ただし安易にマルチモジュール構成にしないほうがよい Go Home! する方法2 またこの記事を書くために作成したコードは以下に置きました。 hinastory/go-multi-modulesContribute to hinastory/go-multi-modules development by creating an account on GitHub. この記事がGo Modulesを使ってモジュール管理を始めようという方、マルチモジュールで躓いた方の参考になれば幸いです。 6. 参考文献 Using Go Modules - The Go Blog (和訳) Modules · golang/go Wiki · GitHub Go Modules1.pkgディレクトリはGo Modulesを使う上で必須ではありませんが、ここではGoの標準レイアウトを採用しています。 ↩2.Go Homeはネタなので優しくスルーして頂けると幸いです。 ↩ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/cats-cats-cats/2019/07/07/go-multimodules/"},{"title":"gRPC UIを使ってみんなが触れるgRPCの遊び場を作りました","text":"gRPCは近年非常によく使われるようになったRPCフレームワーク1ですが、その柔軟なメッセージフォーマットに対応するリッチなGUIクライアントに欠けていました。REST APIでいうPostman的な存在です。このようなツールがなければgRPCを利用した開発が面倒なのですが、その問題は現在においてはほぼ払拭されたといっても過言ではありません。gRPC UIが登場したからです。 目次1. TL;DR2. はじめに3. gRPCとは4. gRPC UIについて5. gRPC UIで遊ぼう！ 〜 gRPC UI playground 〜6. grpcui-playgroundの作り方6.1. Dockerfileを書く6.2. GitHubでDockerfileを公開する6.3. Docker Hubでイメージをビルド & 公開する6.4. ArukasでDockerコンテナを公開する7. まとめ8. 参考文献 1. TL;DR gRPC UIで作成した遊び場はこちらです 👉 gRPC UI playground gRPC UIはgRPCサーバへの要求と応答がWebで簡単にできるので、今後のgRPCを利用した開発に広く使われるツールとなりそうです gRPC UI playgroundは以下のサービスを利用して、無料で立ち上げました。当面はみんなが遊べるようにしておくつもりです GitHub Docker Hub Arukas 2. はじめに本記事はgRPCのWeb UIであるgRPC UIの紹介記事です。gRPCに興味がある方、gRPCを利用している方を対象にしています。実際にgRPC UIを触れる遊び場も作ったのでgRPCに興味がある方は遊んでいってください。また本記事ではこの遊び場をどうやって作ったのかも簡単に解説します。 3. gRPCとはgRPCはGoogleが開発してオープンソースとして公開したRPCフレームワークです。IDL2としてProtocol Buffers3が利用可能です4。gRPCは基本的には以下の図ように単純で、クライアントから要求(Proto Request)を送ってサーバが応答(Proto Response)を返すというものです。クライアントやサーバの記述には、Protocol Buffersが対応している様々な言語(C++, Ruby, Java等)が利用可能です。 What is gRPCより引用 gRPCは上記のように単純な要求/応答型以外にも様々なやりとりに対応できます。具体的には以下の４つです。 Unary RPC(単純な要求/応答型) Server streaming RPC(サーバが複数の応答を返すことができる) Client streaming RPC(クライアントが複数の応答を返すことができる) Bidirectional streaming RPC(クライアントとサーバがそれぞれ複数の要求/応答ができる。一般的な双方向通信) 上記のような柔軟な呼び出しはHTTP/25の基盤に支えられて実現されています。 4. gRPC UIについてgRPC UIはgRPCサーバとブラウザでやりとりできるツールです。百聞は一見にしかず。以下の画面を御覧ください。 この画面を見て震えたのはやはり要求の入力画面(Request Form)の充実っぷりです。gRPCは自分でデータの型を定義して入れ子のようなメッセージを定義できますが、そのような入力も簡単にできます。上記の図のではtest.TestMessageというメッセージの中にperson(test.Personというメッセージの型)が内包されています。また複数のデータが入力可能なフィールドは「Add Item」で簡単に追加できます。その他の注目すべき点は赤字で説明を入れておいたので参考にしてください。基本的にはgRPC(Protocol Buffers)で定義されている入力形式はほぼ網羅されています。 また、驚いたのはgRPCには基本的なスカラ値(stringやint64等)以外にも「Well-Known Types」と呼ばれる型が定義されていますが、gRPC UIにはこれらにもリッチなインタフェースが提供されていたことです。以下の画面はtimestamp型に対するインタフェースです。 またリッチなフォームだけではなく、JSON形式でリクエストを投げることもできます。 JSON形式で便利なのはコピペが容易なところです。また省略されているフィールドは出力されないので見やすくなります。フォーム型の編集画面とも連動しているので、非常に使いやすいです。リクエストは「Invoke」ボタンを押すことでサーバに投げることができます。このボタンはフォーム型のリクエストにも一番下にあります。以下が「Invoke」を押して返ってきた応答になります。 この画面も特に説明がいらないくらい分かりやすいものになっています。gRPC UIで対応できないのは双方向の複雑なやり取りです。これは従来どおりCUI等を利用して行うしかありません。 5. gRPC UIで遊ぼう！ 〜 gRPC UI playground 〜さて、ここまで来たらgRPC UIで遊んでみたくなったと思います。以下にみんなが遊べるように「遊び場」を立ち上げたのでぜひいろいろ遊んでみてください。 gRPC UI playground gRPC UIはバックグラウンドで起動しているgRPC UIのテストサーバ(testsvr)とやりとりしています。プロトコルは「test.proto」、サーバの実装は「testsvr.go」に記述されています。実際にgRPC UIを動かしながらソースやIDLを読むとgRPCの理解が深まると思います。 メソッドに関しては「DoManyThings」が全部詰めになっていて、残りのメソッドはそれを機能単位で分割したものになっています。たぶん・・・ 6. grpcui-playgroundの作り方さて、ここからはおまけです。上記の遊び場(以降、grpcui-playgroundと記載)の構築方法の興味がある方を対象に簡単に説明したいと思います。grpcui-playgroundは3つのサービスを利用して無料で立ち上げました。以下がその構成になります。 上の図をざっくり説明すると、基本的にはDockerを使ってサービス提供しています。一つのコンテナの中にgPPC UIとgRPC Server(testsvr)という二つのプロセスが動いています。一つのコンテナに二つのプロセスはあまりお行儀がよくありませんが、今回は遊び場ということと無料で立ち上げることを重視したのでこのような構成になっています。利用したコンテナホスティングサービスはArukas6になります。今回はFreeプランを利用しています。Arukasにコンテナイメージを提供するためにはDocker Hubも利用しました。Docker HubにはGitHubと連携しておくとGitHubの変更を検知してコンテナをビルドする機能があるのでそれも利用しています。 6.1. Dockerfileを書くDockerfileを書くときの注意点は二つです。まず、ビルドイメージを小さくするためにAlpine Linux7をベースイメージにします。次にgRPC UIが提供しているテストサーバ(testsvr)はgoで書かれているのでgoのビルド環境が必要です。ただしgoのビルド環境は動作には必要ないのでマルチステージビルドを活用して、なるべく小さなイメージにするようにしましょう8。 Dockerfile12345678910111213141516171819202122FROM golang:1.12.7-alpine as build-envMAINTAINER hinastoryWORKDIR /testsvrCOPY testsvr /testsvrRUN apk update && apk add --no-cache gitRUN go buildRUN go get -x github.com/fullstorydev/grpcuiRUN go install -x github.com/fullstorydev/grpcui/cmd/grpcuiFROM alpineWORKDIR /COPY --from=build-env /testsvr/testsvr /bin/testsvrCOPY --from=build-env /go/bin/grpcui /bin/grpcuiCOPY start.sh /start.shEXPOSE 8080ENTRYPOINT [ \"/start.sh\" ] 6.2. GitHubでDockerfileを公開するここは特に説明はしませんが、GitHubに公開レジストリを作成し、Dockerfileとtestsvrのソースと起動スクリプトをpushします。pushした自分のリポジトリは以下になります。 hinastory/grpcui-playgroundPlayground for https://github.com/fullstorydev/grpcui - hinastory/grpcui-playground 6.3. Docker Hubでイメージをビルド & 公開するDocker Hubでイメージをビルドするのには、GitHubと連携しておいたほうが楽です。GitHubと連携しておけばGitHubのレポジトリをDocker HubのUIから選択できるようになり、GitHubにpushするだけでDockerfileをビルドしてくれるようになります。 注意すべき点はDockerイメージのタグの付け方です。デフォルトだとブランチを監視してlatestタグを付けるようになっていますが、Arukasはイメージをキャッシュする場合があるようなのでバージョンが入った適切なタグをつけることが望ましいです。そしてDockerのイメージタグはGitHubのタグと連動しているとよいと思われます。 Docker Hubでその設定をするのは簡単でDockerHubのリポジトリのBuildsの画面からビルドルールを設定でき、Source TypeをTagにして、SourceとDocker Tagを正規表現で記述することでお望みのタグが構成できると思います。またここでDockerfileの位置やビルドコンテキストも指定可能なので、少し複雑なリポジトリ構成でも対応出来ます。 ここの設定が終わったらGitHubにタグをpushしてビルドが始まるか確認します。基本的には検知はすぐに行われてIn Progressの状態にすぐに変わりますがビルドが終わるまでには時間がかかるので、コーヒーでも飲んでまったりと待ちましょう(笑)。自分のコンテナイメージは以下に公開してあります。 hinastory/grpcui-playground - Docker Hub 6.4. ArukasでDockerコンテナを公開する最後にArukasuでコンテナを公開します。FreeプランはO.1vCPUと128MB RAMの非力な環境ですが、今回のような遊び場には充分だと思われます。また「転送量課金」がないのでDDoSとかの心配がまったくいらないのも嬉しいところです。もちろん最悪サービスは落とされますが、料金に怯える心配は無いわけです。ちなみにFreeプランでも電話認証とクレジットカードの登録は必須です。このアカウント登録が最大の難関でコンテナの起動は驚くほどあっけなく終わりました。アプリ起動の詳細は「アプリの作成 – Arukas Help Center」を参照してください。以下は起動したコンテナの管理画面です。Endpointはアプリの再起動で変わることが無いURLです。Portはインスタンスの起動毎に変わります。ちなみにgRPC UIは8080ポートでHTTPでサービスを公開していますが、エンドポイントではHTTPSになっているので自動でArukasがHTTPSに包んでくれるみたいです。 7. まとめ本記事では、gRPCサーバとブラウザでやり取りできるgRPC UIを紹介しました。gRPC UIは非常に便利なので今後gRPC関連の開発で広く使われていくものと思われます。そして実際にgRPC UIを触れる遊び場を作成して以下に公開しました。 遊び場 gRPC UI playground プロトコルは「test.proto」、サーバの実装は「testsvr.go」 遊び場は当面は公開予定ですが、ある日突然告知なしで死ぬ可能性があるのでご容赦ください Dockerfile hinastory/grpcui-playground -GutHub コンテナイメージ hinastory/grpcui-playground - Docker Hub また、おまけとしてその遊び場の作り方を(無料でコンテナサービスを立ち上げる手順)を簡単に説明しました。本記事がgRPCを理解し、より便利に使えるようになるための一助になれば幸いです。 8. 参考文献 gRPC Documentation Developer Guide | Protocol Buffers RFC 7540 - Hypertext Transfer Protocol Version 2 (HTTP/2)(日本語訳) about Alpine Linux Docker Hub Documentation Arukas Help Center 遠隔手続き呼出し - Wikipedia インタフェース記述言語 - Wikipedia 1.RPC(Remote Procedure Call)は、簡単に言えばプログラムの中から内部の関数を呼ぶのと似たような感覚で、外部のネットワーク上の関数や手続きを呼べるようにする技術のことです。他のRPCにはSOAPやJSON-RPCなどがあります。 ↩2.IDLはインタフェース記述言語(Interface Description Language)のことです。簡単に言えば関数呼び出しの宣言部分を定義する際に使う言語です。 ↩3.Protocol BuffersはGoogleが開発したシリアライズフォーマットです。IDLは独自の言語でシンプルで分かりやすいのが特徴です。IDLのファイルは.protoの拡張子を持っており、protocというコンパイラを用いてIDLファイルからGo言語やRuby、Python、Java等様々な言語のバインディングを生成できます。現在のProtocol Buffersのバージョンは3になります。 ↩4.JSONも利用可能みたいですが、自分は使ったことはありません。 ↩5.HTTP2はHTTP/1.1の後継バージョンでRFC7540で定義されています。HTTP/1.1と比べてヘッダーの圧縮やバイナリメッセージ構造、双方向通信のサポート等様々な改善がなされています。 ↩6.Arukasはさくらインターネットが提供しているDockerのホスティングサービスです。Arukasを反対から読むと・・・ ↩7.Alpine Linuxは軽量、シンプル、セキュアをコンセプトにしたLinuxディストリビューションです。組み込み系で実績のあるmusl libcとbusyboxをベースにしています。その軽量さからコンテナのベースイメージとしてよく利用されています。 ↩8.最初は無邪気にベースイメージをstretchにしてシングルステージでビルドしたため、イメージのサイズが400MBを超えてしまいました・・・現在のサイズは 18MBです。特にパブリックなレジストリに登録する際はコンテナイメージのサイズに充分気を配り、リソースを無駄にしないように心掛けましょう(自戒)。 ↩ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/cats-cats-cats/2019/07/27/grpcui-playground/"},{"title":"Hexoでブログに再入門","text":"Advent Calendar用に久々にブログを立てて見ました。以前にパブリックに書いたのは多分10年以上前のような気がします。レンタルーサーバ借りてドメイン取ってRubyで動く何かを使って立てた気がするけど、よく思い出せません・・・ まぁ、過去のことは置いておいてせっかく立てたので、何か役立ちそうなことをメモしていきたいと思います。 目次1. Hexoとは2. 静的サイトジェネレータ3. 静的サイトジェネレータの長所4. 静的サイトジェネレータの短所5. なぜHexoを選んだのか？6. まとめ7. 補足 1. Hexoとはとりあえず今回このブログは、Hexo使って立ててみました1。Hexoはブログを書くためのフレームワークですが、WordPressのような従来型のブログサービスとの一番の違いは、静的にブログを生成するか、動的に生成するかです。 2. 静的サイトジェネレータHexoは静的サイトジェネレータというツールに分類されていて、あらかじめ用意したブログのテキストや画像等から、ブログの表示に必要なHTML,CSS,JavaScriptなどの静的ファイルを生成してくれます。Hexoがやってくれるのはここまでで、あとはHexoが生成したファイルをお好みのWebサーバに公開すればブログが表示されると言う仕組みです。WordPressはこれとは違い、Webにアクセスが来るごとにWebページをサーバサイドのプログラムが動的に生成してブラウザに返しています。 3. 静的サイトジェネレータの長所どちらにも一長一短があって、静的サイトジェネレータの良いところはローカルで確認してから、チェックが完了してからWeb公開できる点です。このローカルで確認できると言うのはすごい強みで、画像のアップロードも不要だし、テキストやCSSの修正も手元で直してすぐ確認できると言うのが非常に心地いいです。これが動的サイトだと一度サーバにアップロードして確認と言う手間が一つ入るため、色々と面倒臭くなります。 また、静的サイトジェネレータの場合、サイトの生成に必要なファイルは必然的に手元で管理することになるので、Gitなどのバージョン管理システムと相性が良いです。これは非常に安心感があって、こまめにコミットしておけば様々な理由による『ブログの消失』を未然に防ぐことができます。動的サイトの場合も手元にファイル等の形で残しておけば、バージョン管理することができますが、ちょこっとした修正をサーバにアップロードして、バージョン管理用ファイルに反映し忘れるという事故が起き易いです。 セキュリティ的に安心というのも魅力の一つですね。サーバサイドの処理がないので攻撃パターンが限られますし、特にWebサーバにホスティングサービスを使っている場合、自分ではほぼ何もセキュリティについて考えることはないです。少ない懸念点の一つとしてあげるならばJavaScriptを使ってる場合です。まぁ最近は大抵知らずのうちに使われてると思いますが、特に怪しいライブラリを使っている場合に勝手にマイニングされたり、踏み台にされる場合もあるので、気をつけた方が良いかもしれません2。 4. 静的サイトジェネレータの短所このようにHexoのような静的サイトジェネレータ型のブログツールには利点がたくさんあるのですが、もちろん欠点もあります。一番目立つのは、非エンジニアにとって利用するのにハードルが高いということです。例えば、Hexoのトップページには「Simple」と謳いながら、以下の導入時のコマンドが載っています。\u0010\u0010\u001012345$ npm install hexo-cli -g$ hexo init blog$ cd blog$ npm install$ hexo server これを見て「簡単そうだな、やってみようかな」と思える人は世の中に1%もいないと思います。もちろん現役のWebフロントエンドエンジニアなら、これを見てお湯を注いだカップラーメンができるより早くブログサイトを構築できるでしょう3。つまり、現在のところ静的サイトジェネレータはGitが分かるフロントエンドエンジニアにとって、非常に使い易いツールだけど、それ以外の人は、まぁ覚悟して取り組んでくださいとしか言いようがないですね。。。もちろん将来的にはシンプル詐欺などではなく本当に非エンジニアでも無理なく使えるツールが出てくるかもしれないので、この点は静的サイトジェネレータ固有の短所というよりもまだ成熟途中の技術の特徴ということになります。 あと当然ですが、静的サイトジェネレータ単体ではサーバサイドという概念がないのでRDBと連携して、大量データの検索とかテーブルの結合とかそういった処理も基本できません。カウンタやトラックバックやコメント機能などのブログにおなじみの機能もデフォルトではありません。このような場合はWebサービスと連携するのが常套手段ですが4、複雑になりそうなら最初から動的サイトやSPAやSSR等の構成5を検討した方が良いでしょう。逆に考えると静的サイトジェネレータの一番の使い道はこのような処理が基本的に不要な場合のプライベートなブログで、まさにHexoはこのサイトにうってつけなのでしょう。 5. なぜHexoを選んだのか？まさしく、前掲のコマンドを見て簡単そうに思えたからです(笑)。つまりそれをコピペして実行するだけで試せる環境と知識をすでに有していたからということになります。あとはHexoと言うより静的ジェネレータの利点の方が大きいですね。最初はVPSやパブリッククラウド上に、以前のように動的サイトを構築しようと考えていましたが、構築コストやセキュリティのことを考えるとだんだん気が重くなってきました。ブログサービスも検討しましたが、ソースは全てGit管理したかったのと手元で表示確認がすぐにできないので却下しました。つまりGit管理と親和性があって手元ですぐにサイトの表示が確認できて、セキュリティーの心配をあまり心配しなくてもいい記事投稿が簡単にできるブログツールを探していたということになります。その中で一番最初に目に付いたのがHexoだったというだけです。記事がMarkdownでかけるのもいいですね。なのでもっといいツールが見つかれば移行するかもしれませんが、しばらくはHexoと仲良くやって行こうと思っています。目下の悩みはテーマをどうするかです。デフォルトのlandscapeも拡張しやすくて悪くはなかったのですが、せっかくこれだけのテーマが公開されているので色々と試したいと思っています。6。 6. まとめまとめです。Hexoの箇所は静的サイトジェネレータに置き換えても大体合ってます。３行を目指しましたが、なかなか難しいですね。 Hexoは静的サイトジェネレータ型のブログツール Hexoはローカルで編集して、すぐに実際の表示が確認ができるので、心地よい Hexoはバージョン管理と相性が良く、こまめにコミットで安心できる Hexoはセキュリティ的に動的サイトに比べて安心 Hexoは非エンジニアに基本向かない Hexoではカウンタやコメント機能等、サーバサイドの処理が必要なものは基本使えない 7. 補足前述の通りでHexoを最初に選んだのは私にとって簡単そうに見えたからです。だけどそう見えたのは私の好みや経験という色眼鏡があったからなので、申し訳ないですがこのブログを読んでくれた方に当てはまるかどうかは分かりません。もちろん世の中にはHexo以外にも山のように静的サイトジェネレータがあるので、余力のある人にはぜひStaticGenを参考に自分にあった運命の静的サイトジェネレータを探し出して欲しいです。。。7 1.Hexoは「ヘキソ」と発音しています。正しいかどうかは分かりません。 ↩2.つい先日もnpmパッケージの「flatmap-stream」に仮想通貨を盗み出すコードが混入していて話題になりました。近年JavaScriptのセキュリティインシデントは増加傾向にあるので楽観視はできません。 ↩3.テーマを弄りはじめるとエンジニアでも頭を抱えそうですが・・・ ↩4.例えばコメント機能はDisqusと連携すれば実現できます。 ↩5.SPA = Single Page Application, SSR = Server Side Rendering ↩6.現在このブログで利用しているテーマはフッターを参照してください。テーマは今後変わる予定があるのであえて本文には記しません。 ↩7.願わくばこの記事を読んだ人が静的サイトジェネレータの旅に出て、ブログを書いてくれてそれが、私の目に止まりますように・・・ ↩ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/cats-cats-cats/2018/12/02/start-blog-hexo/"},{"title":"JapanContainerDays v18.12 に初参加","text":"12/4(火)にJapanContainerDays v18.12に初参加しました。このイベントは春に1回目を開催して今回で2回目の開催だそうですが1、会場には800人以上の人が詰め掛けたようで非常に盛況でした。 JapanContainerDays v18.12[12/3-5開催]コンテナ活用/クラウドネイティブの現状をひとまとめにした開発者のためのイベント - JapanContainerDays 目次1. 会場の様子2. キーノート3. 参加セッション一覧3.1. 24日参加セッション3.2. 25日参加セッション4. 食事5. 戦利品6. 感想とまとめ 1. 会場の様子会場は御茶ノ水のソラシティカンファレンスセンターでした。ここには以前にデブサミ夏や大江戸Ruby会議06に参加した時に来たことがあったので特に迷うことなく到着しました2。9:40開始だったのですが念の為30分早く会場入りしたのでキーノートの会場はまだ半分近く空いていました。 撮影：JapanContainerDays実行委員会引用元 撮影：JapanContainerDays実行委員会引用元 2. キーノートさすがにキーノート開始直前には満席近くになっていました。キーノートは会社やコミュニティの代表が順番に登壇する形式で2時間行われました。その中でなんといっても目玉はCNCFのCOOであるChris Aniszczykさんの発表だと思います。 撮影：JapanContainerDays実行委員会引用元 CNCFの歩みや今後の展望が語られていました。気になったのはIoTやEdgeにもKubernetesが進出するという話題でしょうか。KubeEdgeには注目していきたいと思います。あとはどんどんServerlessやNodelessに進んでいく方向性が強調されていました。virtual-kubeletの紹介もあり今後が非常に楽しみです。 kubeedge/kubeedgeKubernetes Native Edge Computing Framework (project under CNCF) - kubeedge/kubeedge virtual-kubelet/virtual-kubeletVirtual Kubelet is an open source Kubernetes kubelet implementation. - virtual-kubelet/virtual-kubelet あと、クラウドネイティブの定義も紹介されていました。今までクラウドネィティブとは何ぞやと思っていたので少しはもやもやが晴れたような気がします。 クラウドネイティブテクノロジは、パブリック、プライベート、およびハイブリッドクラウドなどの最新のダイナミックな環境でスケーラブルなアプリケーションを構築および実行するための組織の能力を強化します。コンテナ、サービスメッシュ、マイクロサービス、不変インフラストラクチャ、および宣言型APIは、このアプローチの例です。 これらの技術は、復元力があり、管理しやすく、観測可能な疎結合システムを可能にします。堅牢な自動化と組み合わせることで、エンジニアは頻繁に、そして予想通りに影響の少ない変更を最小限の労力で行うことができます。 クラウドネイティブコンピューティング基盤は、ベンダーに依存しないオープンソースのプロジェクトのエコシステムを促進し維持することによって、このパラダイムの採用を推進しようとしています。最先端のパターンを民主化し、これらのイノベーションを誰もが利用できるようにします。 クラウドネイティブの定義(Google翻訳を利用)引用元 あとはCNNFの歩き方や全体像も紹介されていました。 CNCF Cloud Native Interactive LandscapeFilter and sort by GitHub stars, funding, commits, contributors, hq location, and tweets. Updated: 2019-07-28 01:39:19Z Trail MapはともかくLandscapeは圧巻ですね・・・ まぁその中でもCNNFが直接ホスティングしているのはごく僅かです。これを見ると全部で30程ありますが、現時点では成熟度が最高のGraduatedになっているのはKubernetes、Prometheus、Envoyのわずか３つです3。これからクラウドネイティブが浸透していく中でこれらのプロジェクトがどの様になっていくのか注視していきたいと思います。 キーノートには他にも面白い発表がいくつもあったのですが、印象に残ったのはメルカリの発表でした。なぜコンテナオーケストレーションにKubernetesなのかという問いに対して拡張性とエコシステムを挙げていましたが、これと同じ答えはこの後に続くセッションでも繰り返し聞くことになりました。そしてこの答えがOSSで勝ち抜くための到達点なんだという気がしました。シンプルで直交的で整合性のとれた拡張性で素早くエコシステムを構築すること。言葉にすると短いですがこの状況をわずか数年で作り上げて決着までほぼつけてしまうとは、改めてKubernetesの成し遂げたことの凄さを実感しました。 撮影：JapanContainerDays実行委員会引用元 3. 参加セッション一覧とりあえず参加セッションを列挙してみます。メモったキーワードを記載していますが、あやふやな部分も多く含むためさらっと流していただけると幸いです。 3.1. 24日参加セッション keynote CNCF Microservices on Kubernetes at Mercari（Mercari） Kubernetesによる機械学習基盤への挑戦（Preferred Networks） LINEエンジニアを支えるCaaS基盤の今とこれから（LINE） Cloud Nativeの未来とIBMの取組み （IBM） クラウドネイティブで作る、新しいクルマの世界（デンソー） ZOZOTOWNシステムリプレイスにおけるKubernetes活用（ZOZOテクノロジーズ） コンテナネットワーキング（CNI）最前線 コンテナネットワーキングは闇が深い、動きが早い、スケーラビリティに注意 Kubernetes ネットワーキングのすべて Services, Ingress, NetworkPolicy 40 topic of Kubernetes in 40 minutes serviceでなくingressを使え、latestタグは使うな、DockerHubのイメージは信用するな、バージョンアップは容易にするな、ボリュームは使うな、全機能を使う必要はない、ingressはGAではない Ansible、Terraform、Packerで作るSelf-Hosted Kubernetes Kubernetesから始めるクラウドネイティブエンジニアへの道 〜 Kubernetesトレーニングと、CKA/CKAD資格取得に向けて 〜 構築ツールを使わずにやってみた(kubernetes the hard way)、k8sはCloud Nativeにおいてはスターティングポイント 2019年はコンテナよりもクラウドネイティブ!? Knativeのすべて コンテナ辛い！そこでknative, カナリアリリースが楽、riffもあるよ After Party & Booth Crawl !! 3.2. 25日参加セッション 2020年のコンテナはどうなる!? コンテナプラットフォームのこれまでとこれから マイクロサービスは組織論に行き着くので難しい k8sは拡張性の高いOSようなもの K8sは開発やPOCまではうまくいくが本番運用に課題あり istioがここまでくると思っていなかった。サービスメッシュはエンタープライズにこそ必要 cloudfoudry,istio,mesoss,open shift,rancher,rio, core os,kubeflow, knative マイクロサービスの高可用性：Ingress, サービスメッシュの世界におけるロードバランシング nginx社は実在する plusもあるよ 複雑になったWebを簡素化したい fablic modelではすべてのappにサイドカーとしてnginxが入る Dockerセキュリティ: 今すぐ役に立つテクニックから，次世代技術まで 鍵をイメージに入れるな、--ssh,--seacretを使え。使えない場合はスカッシュやマルチステージというワークアラウンドを使え イメージスキャナ - clair, aqua microscanner 誤検知もあるので信用しすぎるな dockerソケットに気をつけろ。dockerグループに入れるのは危険 コンテナ is namespace + capabilities + cgroups SELinux無効化するときは「石川さん、Walshさんごめんなさい 」と唱えてから実行 Kubernetesと暮らすRancherな生活 rancherはk8sのオーケストレーション層ではなくその上のストラテジー層 2.0でk8s一本になり、Pure Goになり、マネージドもOKになりカタログがHelmになった rioはおもしろそうだがまだかなり柔らかい。k8sを意識しない時代に・・・ MeetUpを活性化せよ！最強のリアルタイムQA投稿アプリをCloud_Nativeにつくってみた - Qicoo - 自演が可能です - eks,ec2,elastic cache, rds,cloud flront, route 53,cert manager, elb, travis ci, kustomize, hepioak, spinnaker,kanyeta,prometheousOperator, Halyard - Cloud Native Developers JP - Cloudcraft – Draw AWS diagrams コンテナ時代のOpenStack Kubernetes Meetup Tokyo 2年間の振り返りと未来 参加者の規模数がすごい 登壇者限定で濃い話をする会がある 登壇してください 自分が参加したセッション以外は以下にまとめがあるのであとで読みたいと思います。 JapanContainerDays v18.12 matomeJapanContainerDays v18.12 公式資料まとめ 4. 食事昼食はランチセッション中に配布されたサンドイッチやまい泉ヒレかつサンドを食しました。 撮影：JapanContainerDays実行委員会引用元 お菓子やドリンクも無料で楽しむ事ができました4。ContinerDaysのロゴが入ったマカロンが可愛かったです。 撮影：JapanContainerDays実行委員会引用元 After Partyではビールやワインや焼酎をの呑みながらワイガヤしてました。急遽決まったLT大会では個性あふれる様々な会社がHiringトークをしていました。 撮影：JapanContainerDays実行委員会引用元 5. 戦利品勢い余って電子書籍3冊も買ってしまいました。面白かったのはNGINXで配られたUSBケーブルです。正直そのタコ足のような発想はありませんでした(笑) 6. 感想とまとめ参加したことでCloudNativeがどこまできているか肌で実感できた気がしました。自宅ではminikubeからGPUを触れる環境を構築していますが、いまいち有効利用できていない気がしていたので、このイベントを機会に手を動かしながらいろいろとCloudNativeに近づけて見たいと思います。 Kubernetesの一人勝ち 今後はKubernetesのエコシステムの何処を占めるかの戦い サービスメッシュ(Istio)がかなり熱い Helmもデファクトになりそう knative, virtual-kubeは注視したい 機械学習のインフラとしても面白そう Kubernetesは本番運用に課題あり knative, OpenShift, Rancher等さまざまなアプローチで解決しようとしている 最終的にはNoOpsやサーバーレスやFaaSな未来に行き着くのだろう・・・（時期未定） 来年はCloudNative Days1.JapanContainerDaysは2回目にして、今回で最終回だそうです。次回からはCloudNative Daysに変わるそうですがCloud Native Days Tokyoとの関係性はよくわかりません・・・ ↩2.駅から徒歩1分なので、そもそも迷うほうが難しい気もします・・・ ↩3.というかPrometheusはCNNFだったとは初めて知りました・・・ ↩4.当日は本当に無料だと喜んだのですが、冷静に考えると参加費を払っているので無料でもなんでもなかったです・・・ しかし、チケットは最後までEarly Bird価格のまま安売りされていたけど主催者の想定した人数が集まらなかったから値下げしたのか、それとも早めに予定金額を調達できたから値下げしたのか真相がわからない ↩ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/cats-cats-cats/2018/12/06/container-days/"},{"title":"気が付いたら本棚がキーボード棚に変わっていた話","text":"この記事は自作キーボード #2 Advent Calendar 2018 12日目の記事です。自分はゆるふわでキーボードを楽しみたい勢なので、カジュアルにキーボードを楽しむ方法について書いてみたいと思います。ガチなモノ作りの記事はすでに多くの人が書かれていると思うので、その途中で箸休め的に読んでいただけると幸いです。 自作キーボード #2 Advent Calendar 2018 - Adventar書きたいのに枠がないという方のための2枚目です。 [その1](https://adventar.org/calendars/2954) [その3](https://adventar.org/calendars/3208) 「皆さん、EndGameしていますか？」 日本の自作… 目次1. 自作キーボード以前2. 自作キーボードに興味を持つ3. 発狂する4. 自作キーボードの門を叩く5. キーボード棚の作り方6. デコキーのすすめ7. 最後に 1. 自作キーボード以前キーボードにこだわりを持ち始めたのはコンパクトなキーボードを探し始めてからでした。もう15年以上昔の話ですが、その時出会ったのがぷらっとホームが販売していた以下のFKB8579です。 気持ち良い打鍵感で10年以上愛用していました。右側の画像はキートップを外したところですが、キースイッチはメンブレンシートです。最近はCherry MX互換やロープロのスイッチしか触っていなかったのでこういうのを見るとほっこりします。大切に使ってきたのでまだ使えますが、さすがに引退させてあげたいと思ったので次に飛びついたのがARCHISSのProgresTouch RETRO TINYです。メカニカルキーボードでコンパクトなタイプを探していたらちょうどこのキーボードが発売直後だったので購入しました1。 2. 自作キーボードに興味を持つProgresTouch RETRO TINYは打ち心地がよく気に入っていたのです、去年あたりから自作キーボードが盛り上がっていると言う噂を聞くようになりました。ただ、はんだ付けが面倒そうだったので様子見していましたが、キー配置のカスタマイズが自由にできるとういうのはやってみたいと思っていました。 しかしその瞬間は唐突に訪れました。去年の11月ごろMassdropからPlanck Lightが買えるという情報が流れてきたのです。もちろんこのときMassdropもPlanckキーボードのことも欠片も知りませんでしたが、以下の動画を見て一発でやられてしまいました。 やっぱり光るのずるいですね（笑）。あと完成品も販売してくれるとのことだったので、懸念だったはんだ付けも必要がないことも大きかったです。これで念願のキー配置を自由にいじれるということで即座にDropに参加しました。ただこれが過ちの第一歩だとは知らずに・・・発送予定は2018/5/18となっていて、このときまだ半年先だったので気長に待つことにしました・・・待つことにしたのですが、Massdropのやつは毎日のようにダイレクトメールを送りつけてきます。無視すればいいだけのことなのですが、ときどき GMK Red Samurai のような耐え難い誘惑があり、Dropに参加させられました・・・ 3. 発狂する5月初旬にMassdropから一通のメールが来ました。PCBの生産でトラブっていて発送が7月初旬になるということでした。楽しみにしていただけに落ち込みましたが、既に半年近く待っていたのであまり気にしない方向で精神を落ち着けました。ちなみにこのときはまだ自分がはんだ付けをすることになるとはまだ考えていませんでした。このときまでにQMK firmwareが動作する完成品を販売している場面を何回か見ていたのでこれが気に入らなかったら別のを買えばいいと考えていたからです。時が流れて6月に入り大分そわそわしてきたので、GitHubからQMK firmwareのリポジトリをフォークしてキーマップをいじり始めました。このキーマップを考えている瞬間は最高に幸せでした。。。 そしてとうとう7月に入り我が家にPlanck Lightがやってきました。Macにつないで打ってみて動作は問題なさそうでした。そして色々と光らせてこのときは大分テンションが上がりました。そして念願のQMK firmwareを書き込むときが来ました。しかし、不思議なことにfirmwareが書き込まれてくれないのです。何回も試しました。何回も、何回も・・・困り果ててMassdropのDiscussionを覗いて見ると、なんとブートローダを書き込むのを忘れたからキー配置をいじれないという旨が公式からアナウンスされていました・・・ 発狂しました 4. 自作キーボードの門を叩く選択肢はいくつかありました。幸いというか当然というか公式はISPフラッシャーを設計して送ると言っていました。しかしながらこのときは完全に疑心暗鬼になっていて楽観的に待つ気にはなれませんでした。実際に公式の対応は非道いもので、一週間何の音沙汰もないこともしばしばで毎週Discussionで誰かが進捗を尋ねていましたが無応答がほとんどで、罵声が飛ぶような殺伐としてた雰囲気でした2。２つ目の選択肢は自力でブートローダを書き込むことです。一応成功した人もいるようなので試してみる価値はありましたが3、いきなり壊したら立ち直れそうになかったので、諦めて今まで避けてきた第三の選択肢を取ることにしました。 ここに来てようやく自作キーボードの門を叩く決心をしました。本当に長くなってすいません・・・決心したら行動は早かったです。 Ergo42 を注文して4、秋葉原のマルツではんだごてやテスター等必要な道具を揃えて、届いたらすぐに組み立てはじめました。しかし結局動かなかったのでDiscordの自作キーボードのサーバーの初心者チャンネルで色々な人に助けてもらいながら何とか動作させることができました。このときの感動は何とも言い難いですね。あのとき善意で助けいて頂いた方々には本当に感謝しています。そして辛かったけど本当に乗り越えられてよかったです。 この後は数字キーが欲しくなってIrisに手をだしました。 上のキーボードがIrisで下のキーボードがErgo42です。両方共46キーだったのでこの写真は「46キー姉妹」というタイトルでDiscordに投稿しました。しかし何というかあれだけ欲しかった数字キーも慣れてくるといらなくなりました・・・結局手首をなるべくリストレストに固定して打つようになるため指が届きにくいキーは不要みたいな感じになりました。 このあとに作ったのはMint60です。Maker Faire Tokyoで買い損ねたので、コミケに始発で乗り込んでゲットしてきました。 オシャカワなキーボードが手に入ってとても嬉しかったのですが、残念ながらこの頃には指がOrtholinearに慣れてしまっていて、Row-StaggerdなMint60は既に打ちづらくなっていました・・・もう少し出会いが早ければ最高の相棒になったかもしれませんが、現在は布教担当として働いてもらっています。 だいたいここまでが自作キーボードを作り始めて1ヶ月くらいですが、一気にモノを増やしすぎたため置き場所に困るようになってきました。もちろんただ積み重ねるだけならできるのですが、キーキャップやスイッチ等は探しやすく見比べやすいようにしたい欲求が高まってきたのでキーボード棚を作ることにしました。 5. キーボード棚の作り方まずは本棚をご用意ください(笑)。いきなり落ちからはじめて申し訳ございません。実際に自分のキーボード棚は本棚の流用なのでこれ以上何も言うことはないのですが問題が一つありまして、もともとこの本棚には捨てられない本5がぎっしり詰まっていたのです。そこでひたすら 自炊を頑張りました。 一気に100冊程自炊したので大分消耗しました。上の写真は自炊道具で、どこのご家庭にもあると思わるごく普通の裁断機とスキャナです6 。ブログ先頭の写真は自作キーボードをはじめて2ヶ月経った頃の写真でキーボード棚を作った当初の写真です。現在は以下のようになっています。 下から2段目は道具を置いています。道具は他にもあるのですが収まりが悪いハンダゴテや腕を増やすツールとかを置いています。一番下の棚は非常に心苦しいのですがいわゆる積みキーボードというものです。今年中に何とか進捗を出そうと思っています。最初は実用重視で作ったキーボード棚ですが、実際に作ってみるとショーケースみたいな感じで毎日眺めていて楽しいので、キーボードの楽しみ方が一つ増えました。これはおすすめです。ちなみに本棚はあと6台あるので徐々にキーボード棚に変えて行こうと思っています。 6. デコキーのすすめこの記事の冒頭でカジュアルにキーボードを楽しむ方法について書きたいと述べましたが、その一つがデコキーです。デコキーとは「デコレーションされたキーボード」の略で、ここではシールや紙・布等を両面テープとでキーボードに貼り付けて飾ることを指しています。メイクと同じで盛りキーボードと言ってもよいかもしれません。 EndGameという言葉をよく耳にしますが、実際に打ち心地やキー配置はEndGameに近づけられても見た目は必ず飽きがくると思われます。もちろん際限なくキーキャップを変えたり、キーキャップやケーブルやケースやPCB等を自作できる時間と金銭と能力に余裕がある人はいいのですが、世の中の大半の人はそうでないと思われます。そこでデコキーでカジュアルにキーボードの見た目を変えてみようというのがここでの提案です。もちろんこのデコキーがしやすいキーボードには前提があってシールを貼る余白が必要です。現在の自作キーボードキットにはデコキーに必要な余白を持つものが非常に少ないのですが、Ergo42はその中では珍しくデコキーと相性が良いと思われます。 Ergo42の上部の台形部分にシールを貼るだけで印象はガラッと変わります。この写真では木目調のシールを貼っていますが。この手のシールや紙・布は100均で安く手に入り種類も豊富です。自分もちょっとした気分転換にキーキャップに合わせて気軽に盛り直していますが、簡単な割には満足度は高いです。 上のキーボードはRed Samuraiのキーキャップに合わせて台形部分と巻取り式ケーブルに畳縁を貼っており、ケース側面に畳シールを貼っています。一つ注意点を上げるとすればErgo42にデフォルトで付属しているのは鍋ネジなので、そのままだとシールが浮いてしまうので皿ネジに変える必要があります。また皿ネジにしてもそのままだとまだ少し浮くので適当なドリルでネジが平らになるようにアクリル板を少し凹ませる必要があります。 7. 最後に長々と書いてしまいましたが、自作キーボードの世界に飛び込んで後悔はしていません。最初は面倒だったり怖かったりしたものですが、すぐに助けてくれる気の良いコミュニティがあるので、余計な心配をせずにまずは手を動かしてみることが重要だと気づきました。そして新しく開けた扉の先には、モノを作る楽しさと感動がダイレクトに待っています。何より普段何気なく使っているキーボードに対して理解が増し、不便も解消され、愛着も得られると思います。ただ無理をしすぎると反動が来るので、自分にあったペースで自分にあった楽しみ方を見つけて行きたいという思いでこの記事を書きました。この記事がキーボードをカジュアルに楽しみたい方や自作キーボードに興味があるけどまだ手を出せていない方の一助になれば幸いです。 おいでよ、自作キーボードの世界へ この記事はErgo42 with DSA COFFEE HOUSE\" KEYSET & Cherry MX Redで書きました。1.軸は悩みましたがまずは無難に赤軸にしました。 ↩2.結局ISPフラッシャーはさらに2ヶ月も経って、諦めかけた頃に送られてきましが、firmwareの書き込みは無事成功しました。 ↩3.Quick and dirty guide to flashing your Planck Light bootloader : olkb ↩4.現在は後継のErgo42 Towelが販売されています。 ↩5.決して怪しい本ではないです。 ↩6.スキャナはScanSnap S1500Mです。 ↩ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/cats-cats-cats/2018/12/12/keyboard/"},{"title":"サイレントでホットスワップなErgoDash miniを制作(後編)","text":"2018年のキーボード納めとして、年末にErgoDash miniを組みました。この記事はその後編にあたります。前編は以下になります。 サイレントでホットスワップなErgoDash miniを制作(前編) 目次1. 制作工程1.1. Pro Micro用のコンスルーの取り付け1.2. ホットスワップ用ベリリウムの取り付け1.3. スタビライザー、キースイッチ、Pro Microの取り付け1.4. Pro MicroにQMK Firmwareの書き込み1.5. 動作確認1.6. ケースの組み立て1.7. キーキャップの取り付け 〜O-ringによる静音化〜1.8. 完成!2. トラブルシューティング3. ホットスワップ化の長所と短所4. まとめ 1. 制作工程前回はUndergrow LEDの取り付けまで行いました。今回はいよいよPro Microとキースイッチのホットスワップ化に挑みます。 1.1. Pro Micro用のコンスルーの取り付けPro Microのホットスワップ化1ですが、これはなるべく行っておいたほうがよいです。理由は前述のとおりモゲる心配もありますし、初期不良でPro Microが動作しないこともあります。基盤にはんだ付けすると後で剥がすのが非常に大変です。Pro Microのホットスワップ化の方法は主に２つあって、コンスルー(スプリングピンヘッダ)を用いる方法と、ソケットを用いる方法です。今回はコンスルーを利用しました。コンスルーはピンの部分がバネのような構造になっており、基盤部分にはんだ付けしなくてもスルーホールと密着する仕組みになっています。ただし、コンスルーとPro Microのはんだ付けは必要なようです。コンスルー利用時の注意点としては、コンスルー自体に向きがあることです。 Helixビルドガイドより引用元 向きを間違えると基盤から抜けやすくなったり接触不良になりやすいので、Helixのビルドガイドを参考に取り付けをしました。 1.2. ホットスワップ用ベリリウムの取り付けここからがようやくキースイッチのホットスワップ化の話です。キースイッチのホットスワップ化する方法も主に２つあり、スルーホールにベリリウム銅を埋め込む方法とスイッチ用PCBソケットを利用する方法です。後者は基盤やケースの対応が必要になるので、今回は「みんな大好きベリリウム」2を使います。 ベリリウムは上記の写真のとおり非常に小さな金属です。写真右下のキースイッチに実際にベリリウムを嵌めていますが、上の方の足のベリリウムは非常に硬かったので最初下の足だけピンセットでベリリウムを嵌めて、もう一つのベリリウムは基盤のスルーホールに嵌めてからスイッチを垂直に挿すようにして嵌めました。このとき大事なのはベリリウムの穴に対してちゃんと狙って真上から力をかけることです。スイッチの足は折れやすいので斜めに力を掛けるとすぐに穴に入らずグニャリと逝ってしまわれます3。このベリリウムを挿す作業は非常に辛い作業で一部の人々には「田植え」とも呼ばれていますが、基盤から生え揃った金色の稲穂を眼前にすれば目頭が熱くなること必死です(笑)。 ErgoDash miniではこの段階で親指付近のキーの物理配置を決定しますが、せっかくホットスワップにしたのでキーの足が入る全てのスルーホールにベリリウムを埋め込んでおくことをオススメします。こうすることで後ではんだ付けすることなくキーの物理配置を変更することができます。実際にキーマップをいじっていると物理配置をいじりたくなる瞬間が何回かあってホットスワップにしておいてよかったと実感できました。 さて、この田植え作業が終わったと思って一息つけるかと思えば、そうは問屋が卸しません・・・組立工程の屈指の難関、ベリリウムのはんだ付けです。このはんだ付けの何が難しいかと言えば、基盤から顔を覗かせているベリリウムの高さがあまりないので、ベリリウムの穴にはんだが入らないように周囲にだけはんだを盛るのが大変なのです。単にスイッチの足をはんだ付けすればいいのであれば、一つの足に付き数秒で済みますが、ベリリウムの周囲をはんだが入らないように固めるとすれば、はんだを数回に分けて慎重に盛らねばなりません。自分の場合、普通にスイッチにはんだ付けするより5倍程の時間がかかりました・・・4 1.3. スタビライザー、キースイッチ、Pro Microの取り付けホットスワップにしたのでここからは基盤に挿すだけのお仕事です。ただスタビライザーを取り付ける場合には静音化のためにグリスをしっかり塗りましょう。自分は手元にあったシリコングリスを塗りました。オイル系だとあまり音を抑えられなかったのでここはグリスがいい感じでした。キースイッチは足が曲がらないように慎重にベリリウムを狙って挿すようにしましょう。Pro Microは基盤に挿すだけなのですが、Pro Microに着いているLEDは光量があって透明のアクリルケースだと拡散して結構目立ちます。気になる人は不透明な絶縁テープで目張りをすることをオススメします。下の写真では左が目張りをしていて、右が目張りをしていません。 USBの口と反対側にライトがあるのでここにテープを貼ります。この写真では赤色のLEDしか目張りしていませんが、緑色のLEDも気になる場合は全体に貼りましょう。 1.4. Pro MicroにQMK Firmwareの書き込みこの作業は公式のビルドガイドどおりで大丈夫です・・・といっても公式もリンクで実際はQMK Firmwareのページにもろもろ書いてあります。とりあえずGMK Firmwareの環境構築は終わっているものとして、骨子だけ説明します。ターミナルを開いて以下の手順で実施すれば大丈夫です。 12345cd ＜QMK Firmwareのトップディレクトリ＞cp -r keyboards/ergodash/mini/keymaps/default keyboards/ergodash/mini/keymaps/hinastory # デフォルトのキーマップをコピーして自分専用のものを作るemacs -nw keyboards/ergodash/mini/keymaps/hinastory/rules.mk # 「RGBLIGHT_ENABLE = yes」を追加emacs -nw keyboards/ergodash/mini/keymaps/hinastory/keymap.c # お好きなキーマップに変更sudo make ergodash/mini:hinastory # ファームウェアのビルドと転送。 上記で「hinastory」の部分は適当に好きな名前にしてください。自分のオリジナルのキーマップになるはずなのでユーザ名にしておくとわかりやすいです。emacsの部分はお好きなエディタに読み替えてください。Backlight LEDを有効にするためにはrule.mkに「RGBLIGHT_ENABLE = yes」を追加する必要があります。ファームウェアのビルドの転送に関してはコマンド実行後に以下のメッセージが表示されたら、PCと片側のキーボードをUSBケーブルでつないで、キーボードのリセットスイッチを押してください。この作業時にはTRRSケーブルは抜いておいてください。もう片側も同様にファームウェアの転送が必要です。 1Detecting USB port, reset your controller now... 1.5. 動作確認おめでとうございます！ここまでの作業でマスターにUSBケーブルをつなぎ、左右のキーボードをTRRSケーブル5で繋げはキーボードは光り、全てのキーが入力できるはずです。動作に問題があった方はご愁傷様です・・・ケースを組む前にトラブルシューティングにお進みください・・・6 1.6. ケースの組み立てケース組み立てはビルドガイドの通りにアクリルプレートをネジ止めすれば大丈夫です。問題はキーボードに傾斜をつけたい場合です。もともとErgodash miniにはPro Microのスペースを確保するために手前から奥にかけて軽めの傾斜が付いていますが、もう少し奥側を高くしたい場合はゴム足で調整するのが簡単です。 上記の写真右がキーボードの手前側で写真左がキーボードの奥側になります。手前に着いている小さいゴム足がキットに付属しているもので、奥側の少し大きめのゴム足が追加で購入したものです。ゴム足は色々なサイズのものがあるので好みの大きさを購入してください。Ergodash miniはコンパクトなキーボードなのでこのくらいの傾斜が自分にはちょうどよかったです。また、キーボードの中央と外側で高さを変えたい場合もゴム足の高さを変えることで調整できます。 1.7. キーキャップの取り付け 〜O-ringによる静音化〜いよいよ最後にキーキャップを取り付け作業です。自作キーボードの制作の中でも屈指の楽しい作業です。まずは手持ちのキーキャップを机に並べる所から始めましょう。自分はピラミッドを組みました(笑)7。キーキャップはキースイッチに適合したものであれば何でもよいです。一般的にはCherry MX互換スイッチが大多数なのでCherry MX対応のキーキャップから揃えることをオススメします。今回使ったGateron SilentスイッチもCherry MX互換のスイッチだったので、大量のキーキャップとキャッキャウフフしながら、キーボードの着せ替えを楽しみました。まさに至福のひとときです。 どのキーキャップをつけるか決めたら最後に静音化の一手間をかけます。前編で説明したO-ringです。今回はグループバイ(共同購入)した3mm O-ringを装着しました。O-ringの大きさや素材によって静音性は変わるので好みのものを選んでください。 取り付け方は簡単で上記の写真のようにキーキャップの裏の足に嵌めるだけです。2uのキーキャップには3箇所嵌める必要があります。 1.8. 完成!お疲れ様でした。完成です！ 2. トラブルシューティング今回自分が体験したトラブルはダイオードの挿し忘れ、LEDのはんだ不良、ベリリウムの穴にはんだ流し込み、ベリリウムのはんだ忘れ、スイッチの足にベリリムを嵌めようとしてスイッチの足を壊す、スタビライザーつけ忘れ、TRSケーブルとTRRSケーブルの間違い・・・書いてて自分はアホの子ではないかとおもうくらいやらかしています・・・orzただこれはみんな通る道だと信じています・・・以下のリンク先にこれらのトラブルの原因と対処方法がまとまっているのでご確認ください。ここに自分が体験したほぼ全てのトラブルが記載してありました。本当にいい情報なのでまとめてくれた人に感謝です。自分が自作キーボードを始めた頃にこのページはなかったのが悔やまれます・・・ キーボードを組み立てるときに陥るミスと対策 - Self-Made Keyboards in Japanはじめてキットを組む人に是非一読して欲しいもの、としてまとめていきたい htomine シチュエーションごとになっていたほうがわかりやすい気はするので、項目別の内容をそちらに転化していけるといいかも。 これだけは確認して欲しいリスト とても多い間違い・ミスをピックアップしました。… 上記のページで解決しない場合はDiscodeで質問しましょう。「#ergodash」という専用チャンネルもありますし、自作キーボードの入門的な質問なら「#beginner-help」でもいいでしょう。親切な人が多いのできっと誰かが手を差し伸べてくれるはずです8。 ここからはトラブルの傾向に対する自分の感想ですが、やはりいちばんの関門はキットやパーツの入手性の悪さですね。人気のキットはすぐに売り切れますし、グループバイ(共同購入)の情報も様々な情報を注視していないと拾えないです。最近は大分改善されましたが、一昨年まではまともに組もうとすると海外通販を避けて通れない状態でした。しかし、去年はコミケやTokyo Maker Fairや技術書店にいけばキットを購入でき、Boothでも手に入りやすい状態でした。今年はもうすぐ遊舎工房さんの実店舗が秋葉原にオープンするらしいので、入手性に関してはさらに改善される見込みです。次の鬼門ははんだ付けですね。特にPro Microのはんだ不良は結構耳にします。またダイオードやPro Microを逆付けしてはんだを剥がそうとして基盤を壊す人もそこそこいます。またLEDチップの実装は阿鼻叫喚の様相を呈しています。 あとはQMK Firmwareですね。苦労のタイプは大きく２つあって、QMK Firmwareそのものに苦戦する場合とQMK FIrmwareにたどり着く前の前提知識で苦戦する場合です。前者はQMK Firmwareのどこをいじればキーマップを思い通りにできるか悩む場合でドキュメントを読んである程度試行錯誤しないといけないでしょう。後者はそもそもビルド環境の構築やGit操作やC言語やmakeの仕組みの理解が足りなくて苦労しています。自分は前者の苦労だけで済んだので比較的楽でしたが、後者で苦労している人も多そうですね。残念ながらこの辺の苦労話を書くのはここの余白は狭すぎます・・・9 3. ホットスワップ化の長所と短所最後にホットスワップ化の作業について、自分が感じたProsとConsをまとめてみたいとおもいます。 Pro Micoのホットスワップ化(コンスルー利用時) Pros モゲ対策になる 初期不良対策になる Cons コンスルーの購入にお金がかかる コンスルーの向きに注意が必要 スイッチのホットスワップ化(ベリリウム利用時) Pros スイッチを自由に変えられる ケースを後から変えられる キーの物理配置を後から変えられる(ErgoDash等の一部のPCBのみ) Cons ベリリウム高い・・・ ベリリウムの入手性が若干悪い 田植えが辛すぎる・・・ キーキャップを引き抜くときに、一緒にキースイッチも抜ける場合がある Pro Microに関しては特に言うことないですね。大抵の人にオススメできると思います。スイッチのホットスワップ化は本当に人を選びます。とにかくお金と慎重さと忍耐が必要です。一旦ホットスワップ化をしてしまえば当然最高の気分になれます。特に末永くキーボードを使っていくとなると、後でキースイッチを変えたり、lubeをやり直したくなったりしますがこれをいつでもできるという安心感はすごいですね。ケースもスイッチをはんだ付けするとトッププレートはかえられませんが、これもスイッチを引き抜けると簡単に交換可能になります。あと最初は意識していなかったキーの物理配置を後から簡単に変えられるのも地味に嬉しかったです。 キースイッチのホットスワップ化後の注意点には、キーキャップを引き抜くときにキースイッチも抜ける場合があります。これはケースやキーキャップの装着部分のきつさにもよるのですが、自分の場合何もしないと3つに一つはキースイッチも一緒に抜けます。対策としてはキーキャップ引き抜き器(針金タイプのもの)の一つを治具代わりにして、キースイッチの上部を押さえて、２本めのキーキャップ引き抜き器でキーキャップを抜いています。 4. まとめまず、静音化ですがこれは体感でかなり変わりました。もちろん人によって評価は変わると思いますが、静かな会議室で利用しても問題ないくらいにはなったと感じています。また打ち心地に関してもlubeのおかげで大分なめらかになって、疲れにくくなったと感じました。ホットスワップ化に関しては、特にスイッチの作業自体は苦労しましたが一度壁を超えてしまえば恐れることはないし、その後に得られるものも大きいので次回のキーボード制作でも採用したいと思います。 最初は本当に静音化とホットスワップ化のことだけについて書く予定でしたが、書いている途中で色々盛り込みたくなって結局、前半、後半に分けても長い記事になってしまいました。本当にここまで読んで頂いてありがとうございました。この記事が読んでくれた方の自作キーボードの一助となれば幸いです。1.ここで言うホットスワップ化とは、はんだ付けせずにパーツを交換できる仕組みを指しています。電源を入れたまま抜き差しできるという意味ではないです。詳しくはここを参照してください。 ↩2.出典 ↩3.この作業でスイッチを2個ダメにしました・・・ ↩4.一回失敗してベリリウムの穴にはんだを入れてしまいました。5倍の時間というのは失敗したベリリウムを基盤から剥がす時間込みです。やっちまった瞬間は地獄に落とされたような感覚でした・・・ ↩5.TRSケーブルだとマスターの反対側のLEDが光りません。片側しかLEDがつかなかったらケーブルを疑ってみてください。 ↩6.当然自分もトラブルシューティングに進みました・・・なのでトラブルシューティングの節は体験談です・・・orz ↩7.キーキャップを入れている容器はダイソーで買ったアルミキャップPET容器です。Seriaでも買えるようです。安いし軽いしサイズも色々あってキーキャップ入れにちょうどよかったです。 ↩8.自分も1台目のときにお世話になりました。このときははんだ不良で貼り付けた写真にいろいろな人にアドバイスを頂きました。 ↩9.ようこそキーマップ沼へ を書きました。 ↩ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/cats-cats-cats/2019/01/10/ergodash-mini-2/"},{"title":"HexoのoEmbedプラグインをnpmに公開した話(前編)","text":"HexoにYouTubeなどのサイトを記事に埋め込むためのプラグインを作成しました。本当はYouTubeが埋込たかったわけではなくて、Speaker Deckのスライドが埋込みたかっただけなんですが、oEmbedを利用して汎用的な作りにしたので結果的にそうなってしまいました。ついでにもったいないからnpm1に公開しました。この記事はそのプラグイン制作記事の前編です。 hexo-oembedembed oEmbed item on your Hexo article. 目次1. 前提2. なぜHexoのタグを新しく作ろうと思ったか3. Hexoのタグの作り方4. Speaker Deckのタグを作ろうとして惨敗5. oEmbedとは5.1. hexo-tag-oembed現る5.2. 真打ちoEmbed Discovery5.3. 図解oEmbed5.4. 後編へと続く・・・ 1. 前提この記事はHexoのhexo-oembedプラグインの制作記事です。Hexoプラグインを作って見たい方、oEmbedの仕様に興味のある方、OSSへの貢献方法を一連の流れで知りたい方向けの記事となっています。hexo-oembedの使い方そのものが知りたい方は以下のページを御覧ください。 hexo-oembedを公開しました 早速製作記事に入りたいと思いますが、このブログで使われている静的サイトジェネレータのHexoのことを知らない方も多いと思います。この記事はHexoのプラグインの話なので知らない方は過去に書いた以下の記事を一読されることをオススメします。 Hexoでブログに再入門Advent Calendar用に久々にブログを立てて見ました。以前にパブリックに書いたのは多分10年以上前のような気がします。レンタルーサーバ借りてドメイン取ってRubyで動く何かを使って立てた気がするけど、よく思い出せません・・・ まぁ、過去のことは置いておいてせっかく立てた… Hexoは記事をMarkdownで記述することができるのですが、マークダウンで記述できないリッチなコンテンツ(例えばYouTubeの動画)を表示させたい場合は、以下のような形式で独自のタグを作成して表示させることができます。1{% tagName param1 param2 %}作成したタグは自分で利用できるのはもちろんですが、Hexoはプラグイン機能を持っているので、プラグイン化してタグを再利用しやすくすることもできます。 2. なぜHexoのタグを新しく作ろうと思ったか冒頭でも書きましたが、Speaker Deckのスライドを貼りたくなったからです。具体的には以下の前回の記事で貼りたくなりました。 Kubernetes Meetup Tokyo #15 - KubeCon 2018 Recap に初参加Kubernetes Meetup Tokyoに初参加しました。会場は六本木ヒルズのGoogle東京オフィスです。倍率2倍の抽選を潜り抜けて参加できることになりました。 Kubernetes Meetup Tokyo #15 - KubeCon 2018 Recap (2019/… Speaker Deckのような埋込みを意識してあるサイトでは概ね埋め込み用のHTMLを取得できるようになっていて、MarkdownにそのままそのHTMLを貼れば表示させることもできるのですが、やはり記事の書きやすさを考えるとスライドのパーマリンクから自動的に埋め込み用HTMLを展開してくれた方が望ましいわけです。 しかし、希望のタグは公式のタグプラグインには存在せず、Hexoのプラグインの中にも該当するものが見当たらなかったので、自作することにしました。 3. Hexoのタグの作り方公式のリンクにある通りタグ名を決めて展開したいHTMLタグを文字列で返すだけです。引数もargsに配列で渡ってくるのでオプション付きのタグを作るのも簡単です。ちなみに空白付きの引数を渡したいときはダブルクォートで囲ってあげれば大丈夫です。公式より1234hexo.extend.tag.register('youtube', function(args){ var id = args[0]; return '';}); ディスクからファイルを読み出したり、インターネットから取ってきた情報をもとにタグを作りたい場合には、非同期処理を利用することがよくあります。その場合は以下のようにオプションでasync: trueを渡してあげてプロミス2を返すようにしてあげれば問題ありません。実は最初は一番目の文字列を返す方式で実装するつもりだったのですが、いろいろと問題があって結局このプロミス方式で実装することになります。 公式より1234567891011var fs = require('hexo-fs');var pathFn = require('path');hexo.extend.tag.register('include_code', function(args){ var filename = args[0]; var path = pathFn.join(hexo.source_dir, filename); return fs.readFile(path).then(function(content){ return '&lt;pre&lt;code&gt;' + content + '&lt;/code&gt;&lt;/pre&gt;'; });}, {async: true}); 4. Speaker Deckのタグを作ろうとして惨敗さて、Hexoのタグの作り方が分かったところで本命のSpeaker Deckのタグを作ってみることにしました。目標はスライドのパーマリンクから埋め込み用のHTMLを生成することです。そして適当なスライドのパーマリンクと埋め込み用のHTMLを比較してみて愕然としました・・・ パーマリンク1https://speakerdeck.com/lynnandtonic/art-the-web-and-tiny-ux 埋め込み用HTML1script> お分かり頂けたでしょうか？最初の想定ではパーマリンクが分かれば文字列処理で埋め込み用HTMLを生成できるはずでした。しかし、蓋を開けてみるとdata-idなるどこぞの馬の骨ともわからないものがなければ生成できないではありませんか！ F●●K———- おっと、失礼。ついつい心の叫びがキーボードに伝わってしまいました。僕は悪くないよ。こうして、当初の目論見が破れて涙に暮れること3000年、突如救世主が現れました・・・ 5. oEmbedとは閑話休題。真面目な話、正直どうしようかと色々調べていたらSpeaker DeckがoEmbedに対応していることを知りました。oEmbedは簡単に言えば、パーマリンクを埋め込み用HTMLに変換するためのWeb API仕様です。仕様はオープンになっておりYouTubeやTwitterやFacebookなども採用していて、コンテンツを埋め込むための業界標準となっています。そしてパーマリンクから埋め込み用HTMLを生成するサービスの提供側をoEmbedのプロバイダというのですが、Speaker DeckはoEmbedのプロバイダであり、サービス提供の受付口であるエンドポイントと受付可能なパーマリンクのフォーマットを定義するスキーマを公開していました。ここからは公式のサンプルを引用しながら具体的に説明します。 サービス提供者 flicker パーマリンク http://www.flickr.com/photos/bees/2341623661/ oEmbedプロバイダ flickr URLスキーマ http://www.flickr.com/photos/* APIエンドポイント http://www.flickr.com/services/oembed 消費者 oEmbedリクエスト(HTTP GETリクエスト) http://www.flickr.com/services/oembed/?format=json&url=http%3A//www.flickr.com/photos/bees/2341623661/ oEmbedレスポンス(JSON形式) 123456789101112{ \"version\": \"1.0\", \"type\": \"photo\", \"width\": 240, \"height\": 160, \"title\": \"ZB8T0193\", \"url\": \"http://farm4.static.flickr.com/3123/2341623661_7c99f48bbf_m.jpg\", \"author_name\": \"Bees\", \"author_url\": \"http://www.flickr.com/photos/bees/\", \"provider_name\": \"Flickr\", \"provider_url\": \"http://www.flickr.com/\"} まずはサービス提供者とoEmbedプロバイダと消費者という、３つの登場人物がいることに注目しましょう。サービス提供者は文字通り埋め込み用コンテンツを提供する側です。この例では写真共有サービスのflickrになっており、埋め込みコンテンツを指定するためのパーマリンクを公開しているものとします3。 oEmbedプロバイダは前に説明したとおり、パーマリンクを埋め込み用HTMLに変換するための情報を提供します。ここでURLスキーマと見てみると、photosの後にアスタリスク(*)が指定されていることがわかります。これは任意の文字列を表していて、photos/以降の文字列がどんな場合でもパーマリンクはマッチすることになります。 最後に消費者にです。消費者は埋め込み用HTMLが欲しい人です。そのためにはパーマリンクおよび、パーマリンクを受け付けるoEmbedプロバイダの両方を知っている必要があります。消費者はoEmbedプロバイダに埋め込み用コンテンツを要求しますが、リクエストの構造は単純でHTTPのGETリクエストでエンドポイントを指定し、クエリとして最低限パーマリンクを指定するためのurlとレスポンス形式を指定するためのformatを指定するだけです。ここではformatはjsonを指定していますが、xmlを指定することもできます。oEmbedプロバイダはどちらか片方のフォーマットだけサポートしてもよいし、両方サポートしても良いことになっています。 レスポンスは見たままなのであまり説明することはありませんが、typeだけ付け加えるとphotoの他にlinkとvideoとrichがあります。photoは写真の埋め込みに使います。画像のURLをurlパラメータで返してくれるのでそのURLをimgタグで表示してあげればよいだけです。titleパラメータがあればalt属性に設定しましょう。 videoとrichの２つのタイプはについて説明するとこれらはhtmlパラメータを持っていていてこの中身を直接埋め込めばいいので一番ラクです。htmlの中身は経験上iframeタグになっていることが多いです。linkは面白くないしあまり使われているところをみたことがないので割愛します。 5.1. hexo-tag-oembed現るさて、ここまで調べて実はoEmbedに対応したタグならあるんじゃないかと思ってGoogle先生に相談したら、案の定みつかりました。 monsier-oui/hexo-tag-oembedEmbed tag plugin for Hexo. Contribute to monsier-oui/hexo-tag-oembed development by creating an account on GitHub. しかし残念ながら、このタグはお目当てのSpeaker Deckには対応していませんでした。しかもエンドポイントをソースコードに埋め込んでいたのでSpeaker Deckに対応してもらうためにはプルリクエストを送らないといけません。最初は素直にプルリクエストを送ろうかと考えていたのですが、oEmbedに対応しているサイトは大量にあるのでそのたびにプルリクエストを送るのもなんだかなぁーというお気持ちになりました。そもそもいちいちプロバイダー探してエンドポイントの定義なんて面倒くさいし何とかならないのかと、もう一度公式のドキュメントを眺めてみると、うん、ちゃんとおあつらえ向きな仕様があるではありませんか！ Discoveryです。 5.2. 真打ちoEmbed DiscoveryDiscoveryは、簡単に言うと前述のoEmbedリクエストをHTMLのヘッダに埋め込める仕様です。これも公式のサンプルを見てもらった方が早いでしょう。 公式より123 素晴らしい。先程の悩みは一瞬で解決しました。パーマリンク先がDiscoveryに対応していれば、まずHEADリクエストでヘッダだけ引っ張ってきて、linkタグのtypeがapplication/json+oembedまたはapplication/json+xmlなものを探して、href属性が示すURLにリクエストするだけでお目当てのoEmbedレスポンスが手に入ります。リクエストは一回増えますが致し方ないですね。しかし、ここまでするならいっその事ヘッダにoEmbedレスポンスを埋め込んでくれよ・・・とか思ってしまいますが、ここはグッと我慢します。頭でっかちな奴(HTML)は嫌われますからね。 5.3. 図解oEmbedここまでのまとめとしてoEmbedのシーケンス図を描いてみます4。ポイントはサービス提供者とoEmbedプロバイダは分かれてても良いということです。一般的には同じ場合が多いですが、複数のエンドポイントをまとめてくれるoEmbedプロバイダも存在します。embed.ly/とかが有名です。あとDiscoveryはoEmbedの仕様としてはオプションです。しかも対応しなければいけないのはサービス提供者側の各ページなので、oEmbedに対応しているページでもDiscoveryには未対応な場合は結構あります5。 5.4. 後編へと続く・・・ここにきてようやくHexoのタグを作成する準備が整いました。長かった・・・後編ではいよいよコーディングの話と公開に至るまでを紹介します。 HexoのoEmbedプラグインをnpmに公開した話(後編)1.npmはNode.jsのパッケージ管理システムです。Node Package Managerが由来ですがnpmのページの左上を見るとクリックするごとに色々はNPMに出会えます(笑)。現在ではJavaScriptのパッケージ管理システムのデファクトスタンダートとなっています。 ↩2.一般的に「プロミス」といえば非同期処理を扱うための手法または概念の一つですが、ここで言うプロミスとはJavaScriptの標準仕様であるECMAScript 6th Edition(ECMAScript 2015)で定義されているプロミスを指しています。JavaScriptの仕様に比較的最近入った仕様ですが最近のモダンブラウザでは問題なく利用することができます。またHexoが基盤として利用しているNode.jsでも標準仕様のプロミスがサポートされています。標準のプロミスについてはJavaScript Promiseの本によくまとめられているので参考にしてみてください。ちなみにJavaScriptのライブラリとして実装されている「プロミス」は標準仕様に準拠したもの以外にも星の数程あるのでそれらと混同しないようにしてください。有名なものではBluebirdがあり、これはHexo内部でも利用されています。 ↩3.一般的にはパーマリンクが用いられることが多いですが、oEmbedの仕様上は特にパーマリンクでなければならないという制約はありません。ちなみに例のパーマリンクのURLは公式のサンプルに乗っていたものであり、実際の写真の中身には自分は関知しておりません。あのパーマリンクを開くことによるいかなる被害および損害の責任はとれませんのでご了承ください・・・誰？ ↩4.このシーケンス図の作成にはPlantUMLを用いています。Hexoのタグとしてはhexo-filter-plantumlを利用しました。 ↩5.2019年2月現在、flickr、Gyazo、InstagramはoEmbedには対応しているけどDiscoveryには対応していなさそうでした。ちなみにoEmbedそのものに対応していないサイトとしては自分が試した限りニコニコ動画やAmazonやメルカリがありました。ショッピング系は物量も多いし入れ替わりも早いので仕方がないとしても、ニコ動には頑張ってほしかった・・・ ↩ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/cats-cats-cats/2019/02/09/hexo-oembed-1/"},{"title":"Developers Summit 2019に参加した感想など","text":"Developers Summit 2019(#devsumi)に参加してきました。会場は目黒のホテル雅叙園東京です。去年は仕事の都合上参加できなかったのですが、今年はなんとか両日とも午後を空けて参加してきました。 Developers Summit 2019ITエンジニアの祭典「Developers Summit 2019」（デブサミ2019）は、2019年2月14・15日に開催！ 目次1. 1日目 参加セッション1.1. Cloud Native時代における Docker / Kubernetes による開発1.2. いまなぜGoogle Cloud Platformを学ぶのか！？〜GCPを支えるGoogleテクノロジーと愛を語る〜1.3. 【祝】k8sデビュー！ エンタープライズ巨大アプリをマイクロサービス・コンテナ化。段階的移行(中)の全記録を追う。1.4. 「ITエンジニアに読んでほしい！技術書・ビジネス書大賞 2019」プレゼン大会2. 2日目 参加セッション2.1. 機械学習システムのアーキテクチャ アラカルト ～ BrainPad における実例を交えて～2.2. エンジニアの皆さんに贈る最速キャリア戦略2.3. これをまだ知らない Web エンジニアへ贈る - 私が愛する Elixir/Erlang の楽しさと辛さ -2.4. サーバーレスで最高に楽しめるアプリ開発2.5. 無意味なアラートからの脱却 〜 Datadogを使ってモダンなモニタリングを始めよう 〜2.6. Webアプリのチューニングバトル「（社内）ISUCON」の魅力と楽しさ3. 場外バトル4. まとめ 1. 1日目 参加セッション午後から参加しましたが、この日の目玉は何と言っても【14-G-1】のGCP特別セッションです。Googleの実際の開発手法やCI事情が聞けるなんてめったにないですから本当に楽しみにしていました。あと、なにげにこの日の最終セッションの技術書・ビジネス書大賞は世相を反映しているので毎年楽しみにしています。 1.1. Cloud Native時代における Docker / Kubernetes による開発 【14-A-4】 13:05～13:50 青山 真也[サイバーエージェント] Kubernetes完全ガイドの著者によるセッションです。1/10にあったKubernetes Meetup Tokyo #15の発表も見ていたので、今回も楽しみにしていました。発表内容はタイトルどおりクラウドネイティブやKubernetesの解説だったのですが、その構成が素晴らしかったです。マイクロサービスとサービスメッシュから始めて徐々にブレークダウンしてKubernetesの話題にもっていき、最後にGitOpsで締める流れは非常に分かりやすかったです。もしクラウドネィティブ\bやKubernetesにもやもやしている方はスライドを一読することをオススメします。 ちなみにクラウドネイティブ関連ではJapan Container DaysやKubernetes Meetup Tokyo #15の参加レポートも書いているのでよろしければそちらもどうぞ。 JapanContainerDays v18.12 に初参加12/4(火)にJapanContainerDays v18.12に初参加しました。このイベントは春に1回目を開催して今回で2回目の開催だそうですが1、会場には800人以上の人が詰め掛けたようで非常に盛況でした。 JapanContainerDays v18.12[12/3-5開… Kubernetes Meetup Tokyo #15 - KubeCon 2018 Recap に初参加Kubernetes Meetup Tokyoに初参加しました。会場は六本木ヒルズのGoogle東京オフィスです。倍率2倍の抽選を潜り抜けて参加できることになりました。 Kubernetes Meetup Tokyo #15 - KubeCon 2018 Recap (2019/… 1.2. いまなぜGoogle Cloud Platformを学ぶのか！？〜GCPを支えるGoogleテクノロジーと愛を語る〜 【14-G-1】 14:10～15:40 中井 悦司[グーグル・クラウド・ジャパン]、他 さて、本日一番楽しみにしていたGCP特別セッションです。さすがGoogleだけあってテーブルはコンセント付きで、Wi-Wiカードもあって、コーヒーとお菓子付きで、バレンタインデーだからかもしれませんがGCPを象ったチョコとクッキーも貰いました。至れり尽くせりですね。 本題のGoogleの開発環境に関するプレゼンですが、いろいろと予想外のこともあったので、手元のメモからなるべく詳細に書き起こしてみました。 共通ミドルウェアサービス 分散ファイルシステム、分散NoSQL、分散ロックマネージャ、分散XXX・・・ 単一リポジトリによるソース管理 Gitは使っていない １日あたり4万コミット、20億行のソースコード 全てのプロジェクトを一つのリポジトリに保存。プロジェクトごとにディレクトリに分けて管理 他のプロジェクトのコードも閲覧可能。任意のプロジェクトのコードをインポートリンク可能 Pros プロジェクト間のソースコード共有の促進 バージョン間の依存関係問題が起きにくい 大規模なリファクタリングが可能 Cons 専用ツールの開発・メンテが大変 ライブラリの依存関係の管理が大変 ブランチを持たない開発ツリー ソースコードの修正は全てメインラインに反映 リリースブランチのみ分ける（チェリーピックで必要な修正をメインラインから取り込む） 自動ビルドツールによるテスト駆動開発 Blaze(Bazelに似たビルドツールで依存関係と自動テストのルールを指定 コミット時の自動テストでは変更コードに依存する他の自動テストを全て実行 １日あたり1万3千個のプロジェクトにおける、約80万回のビルド処理と1億5000万回のテストを実施 自動テストの工夫 定期的に発生するチェックポイントでテストを実施(重複テストを削減) リソース効率は良くなるがテスト結果が遅れるのでストレスになる 依存関係が遠いテストの実行頻度を落とす ソースコードの更新プロセス リポジトリ全体を(仮想的に)ローカルにコピー ローカルで修正した内容をコードレビュー レビュー終了後にリポジトリにコミット レビュー前後に自動テストを実行 コードレビューシステム CL1ごとに変更部分をレビュー Critique(Gerrit2に類似のレビューシステム)上で実施 軽量なレビュープロセス レビューアのアサイン後、小さなもので1時間、大きなもので5時間いないにコメントを受け取る 開発者は平均して週3時間のレビューを実施 99%のCLでレビューアは5人以下、75%のコミットでレビューアでは1人 90%のCLで変更されるファイルは10以下、35%のCLで変更されるファイルは1つ 一つのコミットの変更行の中央値は24行、10%のCLで1行のみ変更 コードレビューの目的 他人が理解できるコードを書くこと これが絶対の基準。開発者の入れ替わりが早いのでこれが最重要。 理解できない場合は、「理解できない」と突き返せばよい 個人的な感想としては単一リポジトリとブランチを持たない開発ツリーは結構衝撃でした。勇気をもってメインラインに突っ込む！は大胆だなぁと思いましたが、後続の話を聞いて納得しました。要はローカルの修正結果を自動テストしてレビューしてもらうシステムがありきなんですね。一般的にはレビューしてもらうにはブランチを切ってコードレビューシステムと連動している共有リポジトリにプッシュしますが、Googleはコードをリポジトリに突っ込むことなくローカルのコードをレビューしてもらえるシステムがあるので、常にレビュー済みのソースのみがメインラインに突っ込まれるようです。まぁ、それでもメインライン一本の運用はすごいと思いますが・・・ あと、コードレビューの目的もシンプルでイイねをしたくなりました。コードレビューの目的を他人が理解できるコードを書いているかのみにすれば、それを徹底すればバグは明白になるし、開発者の入れ替わりでも問題が起きにくくなるので非常に効率的だと感じました。コードレビューのチェックリストをたくさん覚えるよりもこっちのほうが効果がありそうです。 上記のプレゼンは下記の公開資料にもとづくそうなので、いつか読んでみたいと思います。 Why Google Stores Billions of Lines of Code in a Single Repository Modern Code Review: A Case Study at Google Taming Google-Scale Continuous Testing Lessons from Building Static Analysis Tools at Google セッションの二本目はパネルディスカッションで、Googleエンジニアの経歴紹介やGCPとの関わり等を聞けて非常に興味深かったです。気になった話題で言えば、Javaの\"Write once, run anywhere\"は嘘3というパワーワードが出ました。なぜこの話題が出てきたかというとGCPがアプローチを変えてWrite once, run anywhereを達成したという矜持からだと思います。Googleのサービスは今や世界中で欠かせないインフラです。そしてGCPでコードを書けばGoogleのインフラに乗せて世界中に動くサービスを提供することができます。これは恐らくSunの達成したかった本質であり、GCPが誇っていい真実だと思います4。 あと情報収集の仕方も話題になりました。Googleエンジニアでもブログ5、SNS、RSS、SlideShar、Qiitaは一般的な情報源のようです。面白かったのはスマホのChromeでおすすめ記事の表示がトップ画面にでてきますが、これが意外と自分の興味にあった記事を勧めてくれるそうです。 1.3. 【祝】k8sデビュー！ エンタープライズ巨大アプリをマイクロサービス・コンテナ化。段階的移行(中)の全記録を追う。 【14-D-7】 16:20～17:05 石田 健亮[ドリーム・アーツ] 既存のJavaアプリをKubernetesを用いてマイクロサービス化する話でした。k8sを用いたモダナイズの事例としてとてもよい発表だったと思います。 旧環境 Angular,Velocity,Struts,俺々PersistenceAPI,MySQL 新環境 AKS, SpringBoot, kustomize, fluentd(サイドカーでログ収集、DaemonSetを使ってノード単位で立てる) 工夫した点 マイクロサービスは重い(実測で4倍遅い) キャッシュを利用 非同期、並列にする Netflix OSSをチェキラ デブサミ 2019 【祝】k8sデビュー！エンタープライズ巨大アプリをマイクロサービスコンテナ化 from Kensuke Ishida 1.4. 「ITエンジニアに読んでほしい！技術書・ビジネス書大賞 2019」プレゼン大会 【14-A-8】 17:25～18:45 密かに楽しみにしていたセッションです。やっぱり本を読むのって時間がかかるのでなるべくハズレは引きたくないものです。かといって売れているから自分にあっているとも限らないので悩ましいところですが、ここでは著者または関係者が読みどころをプレゼンしてくれるので、非常に参考になります。今日行われたプレゼンも非常に熱がこもっていて、実際に自分が投票した2冊は絶対に買おうと思いました6。 ITエンジニアに読んでほしい！技術書・ビジネス書 大賞2019「ITエンジニアに読んでほしい！技術書・ビジネス書 大賞 2019」技術書・ビジネス書の各ベスト10を発表。大賞は、2月14日のプレゼン大会にて決定します！ そして2019年の大賞はこの2冊に決定しました。おめでとうございます。 2. 2日目 参加セッション2日目も午後からの参加でしたが、雪が降っていたので積もらないことを祈るばかりでした。雅叙園前から駅に向かう坂は激坂なので・・・ 2.1. 機械学習システムのアーキテクチャ アラカルト ～ BrainPad における実例を交えて～ 【15-C-3】 12:10～12:40 太田 満久[ブレインパッド] データ活用を生業としている会社からの機械学習の適用事例をおよびパターンの紹介で非常に参考になりました。一番のポイントはデータ分析が必要とされる場面でも機械学習はオーバースペックのケースが多々あって、その場合は古典的な統計処理を利用しようという事と、機械学習を利用する場合でもなるべく既成のAPIを利用するようにして、独自訓練は避けようというものでした。やはり独自訓練は大量のデータが必要だしコストも高いので、実践では費用対効果を考えながら必要な精度を見極めて、最低限の作り込みにする必要があるみたいです。途中の独自vs既成で出てきた Cloud AutoMLは使ってみたいと思いました。 あとバッチ推論の方がオンライン推論よりも非機能要件がゆるくてデータサイエンティストが行うモデル設計の環境に近いというのもなるほどと思いました。推論はリアルタイムで行うものばかりだと思いこんでいましたが、要件さえあえばバッチ推論の方が問題は少なさそうです。 機械学習システムのアーキテクチャアラカルト from BrainPad Inc. 2.2. エンジニアの皆さんに贈る最速キャリア戦略 【15-B-4】 13:05～13:50 松本 勇気 [DMM.com] CTO大変ッスね・・・という感想がまず一言。生き急ぎたい人向けのセッションでした。自分は途中で振り落とされましたが、正論は正論なので生まれ変わったら実践できる人になってみたいです・・・ AWS・GCP実弾演習場はマジうらやましぃ 暇なら仕事量増やしてください・・・ カッツモデル・・・ヒューマンスキル・・・ツライ 全部Hello Worldはつらいよね？ 取捨選択大事 マネジメントはみんなが学ぶべき概念 正しい意見より、解決できる意見 ITエンジニアとして学んだスキルは他の分野にも流用可能 人はオブジェクトでメッセージパッシングで動いていると捉える 自分を知ってもらう。自分の能力・目標について、周囲は思ったほど知らない ジョハリの窓 意思決定者が誰で、何で困っていて、何を目標として、何を考えているのか それを知って自分がそこにどう貢献するかを考える 意に沿わなくとも、組織の意思決定内容に貢献する 時間をすべて経験に変換する 意思決定されたことに反対するのに無駄な時間を使うな 文句があるなら意思決定に絡む努力をすること 「正しいことをしたければ、偉くなれ」を思い出した・・・ 2.3. これをまだ知らない Web エンジニアへ贈る - 私が愛する Elixir/Erlang の楽しさと辛さ - 【15-D-5】 14:10～14:55 幾田 雅仁 [gumi] すごい軽妙なトークで引き込まれました。まさしくElixirはWeb開発のための言語だと思います。 今年もErlang & Elixir Festをやるそうなので、是非参加したいと思います7。 Pros(楽しさ) Elixir + Phoenix はWeb開発に割り切れば学習容易 適当に書いてもCPU(コア)を程よく使い切ってくれて、そこそこ速くて、安全 GCでシステム全体が止まることはない(プロセス8単位でメモリを持ち、GCする) Cons(辛さ) EVM9は高機能だが、カッコいい機能は沼なので、Web開発時には無視すること モジュールは誤解されがち。関数単位で考えること 2.4. サーバーレスで最高に楽しめるアプリ開発 【15-B-6】 15:15～16:00 江藤 武司[Riotz Works] スライド リアルタイムの動画やフィードバックを始めて扱う場合でも24時間、3人で作れるよ、という感じのセッションです。楽しそうですね。肝はPWAとFirebaseとAWS(Lambda,DynamoDB)、SkyWayといったところでしょうか。サーバレスアーキテクチャなのでイベントドリブンでサービスをラムダで繋いでいく感じですが、そのことをピタゴラ装置と言っていたのが非常に面白かったです。あとDynamoDBでレコードの生成イベントやTTLイベントをトリガにする話も参考になりました。サーバレスは基本的にポーリングではなくイベントを如何に活用するかがキーポイントなんだなと改めて感じました。 ちなみにサーバレスなので費用は使った分しかかからないわけですが、このようなイベントでもワンコイン(500円)程度しかかからないそうです。 2.5. 無意味なアラートからの脱却 〜 Datadogを使ってモダンなモニタリングを始めよう 〜 【15-B-7】 16:20～17:05 池山 邦彦[Datadog] Datadogを使った監視のお話です。Datadogはデフォルトの監視設定が豊富に提供されているので基本的なOSやアプリの監視で困るようなことはなさそうです。あと長年弱点と言われてきた外形監視ももうすぐ使えるようになるそうなので非常に楽しみです。余談ですが、Datadogの社員は犬派よりも猫派が多いらしいです。このブログ名のとおり自分も猫派なので、親近感を覚えました(笑)。あと話題の 入門監視もやはりオススメらしいです。 なぜ無意味なアラートが発生するのか 監視する必要のないものは監視しない 通知する必要のないものは通知しない モニタリングのポイント ワークメトリクス スループット, 成功, 失敗, パフォーマンス リソースメトリクス 使用率, 飽和度, 失敗, 可用性 イベント 変更, アラートスケーリング APM ログ モニタリングの種類 閾値, 外れ値(Outlier), 異常値検知(Anomaly), 予測(forecast), ログ, APM, 複合条件 もう少しで対応予定 外形監視 サービスが本当にReadyなのか確認できる 【15-B-7】無意味なアラートからの脱却 ～ Datadogを使ってモダンなモニタリングを始めよう ～ from Developers Summit 2.6. Webアプリのチューニングバトル「（社内）ISUCON」の魅力と楽しさ 【15-B-8】 17:25～18:25 櫛井 優介[LINE]/古川 陽介[リクルートテクノロジーズ]/南 直[Wantedly] パフォーマンスチューニングバトルの ISUCONのお話です。名前だけは聞いたことあって最初は海外コンテストをリスペクトしてるのかなと思っていましたが、どうやら日本発祥のコンテストだったみたいで元々の意味は椅子(ISU)を投げるから取ったみたいです。ちなみに正式名称はIikanjini Speed Up Contestです。面白そうだったので過去問あさって見ようかなという気分にはなりました。優勝賞金100万円のISUCON9も開催が決まったようですが出場するかどうかは未定です・・・10 3. 場外バトル場外でも熱いバトルと言うか、宗教戦争が繰り広げられていました。 デブサミ2019に出展ブースにて「あなたが好きなエディタ＆開発環境」アンケートまだまだ実施中です。Visual Studio Codeが圧倒的人気！ここまで差が出るとは思いませんでした。#devsumi pic.twitter.com/0jlx3GFRf3— 開発室/虎の穴ラボ＠技書博E-09 (@toranoana_lab) February 14, 2019 最終日の結果です😃Javaが強かった💪🏻Java:304JavaScript:285Python:262C#:194Ruby:132PHP:116C++:89#devsumi #language pic.twitter.com/pLOESAXNc9— ymk9638 (@ymk9638) February 15, 2019 現場からは以上です11。 4. まとめやはり参加して良かったです。特にGoogleの開発環境なんて今まで聞いたことがなかったので非常に面白かったです。また、このブログでは全然書ききれていませんが現場の空気感とかセッションの盛り上がりとか実際に参加してみないと分からないことだらけなので、もし機会があれば来年も参加したいと思います。 本記事はデブサミに参加したくても諸般の事情で参加できなかった人や、興味があるけどいろいろと悩んでいる人のためになるべく面白さが伝わるように心がけて書きました。その結果長文になってしまいましたが、本ブログを読んでデブサミに興味を持っていただけば幸いです。 ちなみにデブサミ関連の資料は以下のリンクにまとまっていますのでご参考まで12。 デブサミ2019、講演関連資料まとめ 翔泳社主催のソフトウェア開発者向けカンファレンス「Developers Summit 2019」（以下、デブサミ2019）の関連資料一覧です。以下、敬称略。随時更新します（2019/04/16 14:36 更新）。 1.Change Listの略。一回のコミットに含まれる変更ファイル ↩2.GerritはGoogleが開発したOSSのコードレビューシステム。GerritはCritiqueを元にOSS化されたものらしい。 ↩3.Javaでクロスプラットホーム開発したことあるエンジニアになら大抵知っていることですが、まともな製品を開発をする場合は大抵JVMの下側がWindowsなのかLinuxなのか、はたまたAndroidなのかは当然意識します。要はWrite once, run anywhereは言い過ぎってことです。特にインストーラ周りは壊滅的だし、UIは残念なことになります。というのも結局はJVMでは最大公約数的なアプローチしかできないから、それで事足りる分はいいのですが大抵はそれだけではうまくいかないからです。もちろんこれは当時のSun Microsystemsが掲げた理念に過ぎないのかもしれませんが、Java生誕から20年以上経った今でも達成されていないことを考えると完全に誇大広告だったということだと思います。 ↩4.GCPの場合スケールさせることができるのでWrite once, run everywhereの方が近いかもしれませんが、これもさすがに言い過ぎ感があるので忘れてください・・・ ↩5.日本語ブログはありがたいのでブログ書いて！と訴えていました。このブログが届くとは思いませんが、まぁ書き続けたいと思います・・・ ↩6.自分が投票した2冊とも大賞に選ばれました。技術書部門大賞の方は2日目の翔泳社の販売ブースで購入しました。読んだ感想とかいつかブログでまとめたいと思います。 ↩7.過去2回は両方参加しています。もともとElixirはRuby on Railsのコミッターが作った言語で文法もRubyに似ていることからRubyユーザが多い印象です。 ↩8.ここで言うプロセスはOSのプロセスではなく、Elixirのプロセスです。一般的にはアクターと呼ばれる非同期処理の単位です。 ↩9.EVM=Erlang VM。ElixirはErlang言語の仮想機械(VM)であるEVM上で動作します。Java言語のVMであるJVM上で動作するKotlinやScalaのようなものです。 ↩10.最大の難関はいいチームが組めるかどうかですね・・・ ↩11.自分はEmacs派ですが、このブログはVS Codeで書いています・・・あと好きな言語はRubyとScalaです。ただ機械学習の関係でPythonを使う機会も増えてます・・・ ↩12.自分もこの記事を書く際に参考にさせて頂きました。ありがとうございました。 ↩ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/cats-cats-cats/2019/02/15/devsumi-2019-winter/"},{"title":"Scala3に入るかもしれないContextual Abstractionsを味見してみた(更新・追記あり)","text":"Scala3のリサーチコンパイラであるDottyにImplicitsに代わる「Contextual Abstractions」と呼ばれる一連の機能が実装されていたので一部を味見してみました。 (2019年3月10日追記・更新: 追記内容はここを見てください) (2019年6月22日追記・更新: 追記内容はここを見てください) 目次1. TL;DR2. Scala3とは3. Dottyとは4. Contextual Abstractionsとは5. 味見の方法6. 味見の結果6.1. 基本的な例6.2. 高度な例7. Contextual Abstractionsのその他の機能8. 味見してみた感想9. 2019年3月10日の更新内容10. 2019年6月22日の更新内容 1. TL;DR この記事はDottyに実装されたImplicitsに代わる「Contextual Abstractions」と呼ばれる一連の機能を味見してみたものです 利用したDottyのバージョンは2019年2月時点で最新の0.13.0-RC1です。Dottyの開発は非常に活発なので異なるバージョンでは本記事の内容とは異なる場合があります 2019年6月時点で最新の0.16.0-RC3で変更があった文法の更新を反映しました。Dottyの開発は非常に活発なので異なるバージョンでは本記事の内容とは異なる場合があります 「Contextual Abstractions」は従来のImplicitsで初学者が躓きそうな機能を整理して使いやすくしています 「Contextual Abstractions」には従来のImplicitsでは実現できなかった機能(暗黙のインポート、型クラス導出、コンテキストクエリ等)も含まれています 「Contextual Abstractions」の機能はまだ提案段階でありScala3の正式な仕様に決定したわけではありません 今後機能が変化したり、機能が採用されなかったりする可能性も十分あります 「Contextual Abstractions」がScala3に正式採用された場合、古いImplicitsは段階的に廃止される予定です 「Contextual Abstractions」への移行はScalafixでサポートされる予定です 2. Scala3とは2020年初頭に出ることが予定されているScalaの次世代版です。コンパイラの高速化と大幅な機能強化が行われる予定です。基本的には現行のScala(Scala2)とのソースコードレベルの後方互換性を意識して機能強化が行われていますが1、非互換が生まれるところや推奨の書き方が変わる所はScalfix2で対応することが予定されています。 3. DottyとはDotty3はScala3の研究用コンパイラで、Scala3\bの仕様や実装を研究するためのものです。Scala3はDottyがベースになることがアナウンスされています4。 4. Contextual Abstractionsとは現行のScalaには俗にImplicitsと呼ばれる機能がありますが、初学者を非常に混乱させる機能として悪名高いものでした5。そこでDottyには、この混乱に決着を着けるべくImplicitsの機能を包含しつつより整理された「Contextual Abstractions」と呼ばれる一連の機能が実装されました6。Implicitsの代替という面でみるとこれらの機能は「implicit」というキーワードをなるべく使わずに別の用語(delegate/given等)で置き換えて、型クラスをより書きやすいようにチューニングしたような内容になっている印象です。本記事ではDottyドキュメント7を参考にしながら、「Contextual Abstractions」の機能の一部を味見してみました。以下が味見した機能の一覧です8。 デリゲート(Delegates) 従来のimplicitで定義されていたインスタンスと同等です Given節(Given Clauses) 従来のimplicitで定義されていたパラメータリストと同等です デリゲートインポート(Delegate Imports) 通常のimportではdelegateで定義された暗黙のデリゲートはインポートされず、別途import delegateでインポートする必要があります デリゲートがどこから来たのかを明確にするために導入されたようです 拡張メソッド(Extension Methods) Dottyの新機能です 型が定義された後にメソッドを追加することができます 型クラスの実装(Implementing Typeclasses) 「デリゲート」、「Given節」、「拡張メソッド」でよりシンプルに型クラスが実装可能になりました 5. 味見の方法ここからdotty-0.16.0-RC3.zipをダウンロードして解凍します。解凍後のフォルダのbinにパスを通せば利用できるようになります。dotcがコンパイラです。dotrはクラス名を指定するとコンパイル済みのバイナリを実行します。単独で起動した場合にはREPLになります。12$ dotc # ソースコードのコンパイル$ dotr # コンパイル済みのコードを実行 もしくはサンプルコードをGitHubで公開したので、sbtをすでにインストールされている方はそちらの方が早いと思います。使い方はREADME.mdをご覧ください hinastory/dotty_contextual_abstractions_exampleSample code of Dotty's Contextual Abstractions. Contribute to hinastory/dotty_contextual_abstractions_example development by creating an acc… 6. 味見の結果Dottyドキュメントに記載されている例をベースに味見をしてみました9。 6.1. 基本的な例従来のImplicitsが分かっている人から見れば、おおよそ以下のコードの意味が分かると思います。拡張メソッド記法だけは、最初は戸惑うかもしれません。自分は最初Go言語に似ているなと思いました・・・ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** 暗黙のインスタンス、推論可能パラメータのサンプル */object DelegateExample { /** 順序型の定義 */ trait Ord[T] { def compare(x: T, y: T): Int def (x: T) < (y: T) = compare(x, y) < 0 // 拡張メソッド記法を使って定義してあります def (x: T) > (y: T) = compare(x, y) > 0 // 上記と同様 } /** 順序型のIntの暗黙のインスタンスの定義 */ delegate IntOrd for Ord[Int] { def compare(x: Int, y: Int) = if (x < y) -1 else if (x > y) +1 else 0 } /** 順序型のListの暗黙のインスタンスの定義 */ delegate ListOrd[T] for Ord[List[T]] given (ord: Ord[T]) { def compare(xs: List[T], ys: List[T]): Int = (xs, ys) match { case (Nil, Nil) => 0 case (Nil, _) => -1 // 空リストよりも非空リストの方が大きい case (_, Nil) => +1 // 同上 case (x :: xs1, y :: ys1) => val fst = ord.compare(x, y) // 先頭の大きさがLists全体の大きさ if (fst != 0) fst else compare(xs1, ys1) // 同じだったら次の要素を再帰的に繰り返す } } /** 推論可能パラメータ */ def max[T](x: T, y: T) given (ord: Ord[T]): T = if (ord.compare(x, y) < 1) y else x /** 無名推論可能パラメータ */ def maximum[T](xs: List[T]) given Ord[T]: T = xs.reduceLeft(max) /** コンテキスト境界使った書き換え(Scala2と同様) */ def maximum2[T: Ord](xs: List[T]): T = xs.reduceLeft(max) /** 推論可能パラメータを使って新しい逆順序型クラスインスタンスを作る関数 */ def descending[T] given (asc: Ord[T]): Ord[T] = new Ord[T] { def compare(x: T, y: T) = asc.compare(y, x) } /** より複雑な推論 */ def minimum[T](xs: List[T]) given Ord[T] = maximum(xs) given descending}/** `DelegateExapmple`の利用方法 */object DelegateExampleUseCase { import DelegateExample._ import delegate DelegateExample._ // Listの` def use(): Unit = { println( max(2,3) ) // 3 println( max(List(1, 2, 3), Nil) ) // List(1, 2, 3) println(List(1, 2, 3) < List(1, 2, 3, 4)) // true println(List(9, 2, 3) < List(1, 2, 3, 4)) // false val numList = List(1,10,2) println( maximum(numList) ) // 10 println( maximum2(numList) ) // 10 println( minimum(numList) ) // 1 }} B): F[B] } /** モナドの型クラス */ trait Monad[F[_]] extends Functor[F] { def (x: F[A]) flatMap [A, B] (f: A => F[B]): F[B] def (x: F[A]) map [A, B] (f: A => B) = x.flatMap(f `andThen` pure) def pure[A](x: A): F[A] } /** リストモナドのインスタンスを定義 */ delegate ListMonad for Monad[List] { def (xs: List[A]) flatMap [A, B] (f: A => List[B]): List[B] = xs.flatMap(f) def pure[A](x: A): List[A] = List(x) } /** リーダモナドのインスタンスを定義 */ delegate ReaderMonad[Ctx] for Monad[[X] ==> Ctx => X] { def (r: Ctx => A) flatMap [A, B] (f: A => Ctx => B): Ctx => B = ctx => f(r(ctx))(ctx) def pure[A](x: A): Ctx => A = ctx => x } /** 関手の利用 */ def transform[F[_], A, B](src: F[A], func: A => B) given Functor[F]: F[B] = src.map(func) /** コンテキスト境界を使った書き換え */ def transform2[F[_]: Functor, A, B](src: F[A], func: A => B): F[B] = src.map(func)}/** `TypeClassExample`の利用方法 */object TypeClassExampleUseCase { import TypeClassExample._ import delegate TypeClassExample._ def use(): Unit = { println( transform(List(1, 2, 3), (_:Int) * 2) ) // List(2, 4, 6) /* リーダーモナドの例はずだが・・・ 以下の例は0.13.0-RC1ではコンパイルが終わらない・・・ 0.16.0-RC3でもコンパイル同様・・・ val calc: Int => Int = for { x e + 1 y e * 10 } yield x + y println( calc(3) ) // 34 */ }} 7. Contextual Abstractionsのその他の機能Contextual Abstractionsの機能で味見できなかった機能を簡単に紹介します。 マルチバーサル等価性(Multiversal Equality) Scala2では文字列と数値が比較可能でしたが、この機能により厳密に型が合っていないとコンパイルエラーにすることもできるようになりました 型クラスの導出(Typeclass Derivation) Haskellのderivingと同等の機能です。現在のDottyで導出可能な型クラスはマルチバーサル等価性を表すEqlのみのようです メタプログラミングを使えば自分で導出可能な型クラスの定義もできます 暗黙の型変換(implicit conversion) 元々のImplicitsのトラブルメーカーです。新たにConversionという型が定義されてその暗黙のインスタンスを定義することで利用できます コンテキストクエリ(Context Queries) 以前はImplicit Function Typeと呼ばれていた機能で0.13.0-RC-1で構文が変更されました ビルダーパターンを簡単に実装できます 8. 味見してみた感想Implicitsが大分飼いならされたような印象でした。特に従来はimplicitをパラメータリストで受け取っていたのをgivenという専用構文で受け取るようになったのが非常に分かりやすかったです。ただ、従来のimplicitlyの名称はまだかなり揺れているみたいです11。 もともとは「A Snippet of Dotty」を読んで、あまりにも自分が知っているScalaと違っていたので調べ始めたのがこの記事を書こうと思ったきっかけです。この記事がScala3がどういう方向を目指しているのか知りたい人の参考になれば幸いです。 9. 2019年3月10日の更新内容本家のブログが公開されたようです。0.13.0-RC-1のタグが打たれてから10日以上経ってからの公開なのでかなり遅い方だと思いますが、それだけ今回のリリースが盛りだくさんだったと言うことだと思います。本家のブログには従来のimplicitがなぜダメだったのか丁寧に説明されていました。The implicit keyword is used for both implicit conversions and conditional implicit values and we identified that their semantic differences must be communicated more clearly syntactically. Furthermore, the implicit keyword is ascribed too many overloaded meanings in the language (implicit vals, defs, objects, parameters). For instance, a newcomer can easily confuse the two examples above, although they demonstrate completely different things, a typeclass instance is an implicit object or val if unconditional and an implicit def with implicit parameters if conditional; arguably all of them are surprisingly similar (syntactically). Another consideration is that the implicit keyword annotates a whole parameter section instead of a single parameter, and passing an argument to an implicit parameter looks like a regular application. This is problematic because it can create confusion regarding what parameter gets passed in a call. Last but not least, sometimes implicit parameters are merely propagated in nested function calls and not used at all, so giving names to implicit parameters is often redundant and only adds noise to a function signature. Dotty Blogより 意訳すると従来のimplicitにはimplicit conversionsとconditional implicit valuesの２つの用途があったけど、意味が違うし初学者は混同しやすいので構文的に別にするという話です。というかconditional implicit valuesという言い方は自分は初めて目にしました。単純なimplicit valuesよりもわかりやすいですね。 この本家のブログを受けてというわけではないですが、前回の記事でサンプルの解説が大分雑だったのでいろいろと見直して、サンプルコードもGitHubに公開しました。興味のある方は味見をして頂けると幸いです。 10. 2019年6月22日の更新内容先日発表されたDotty 0.16.0-RC3で本記事に関する大きな文法変更が行われました。具体的には以下の通りです。 impliedからdelegateにキーワードを変更 (＃6649) 型ラムダに=>>を使用 (＃6558) サンプルコードで使用していた given節を最後にする (#6513) 0.15.0-RC1で変更 上記の変更に伴い本文の該当箇所を修正しました。また、GitHubに公開したサンプルコードも0.16.0-RC3にしてあります。あと何回キーワードが変更されるんだろう・・・1.Pythonの教訓を活かして、なるべく言語の世代間の断絶を起こさないように配慮して開発が進められているようです。もちろん配慮が足りていない可能性もありますが・・・ ↩2.ScalafixはScalaにおける汎用的はリファクタリング、リンティングツールです。Scala3専用ではありません。 ↩3.コンパイラの理論的な基盤にDependent Object Types (DOT)を用いているのが名前の由来です。 ↩4.Dottyに現在入っている機能が全てScala3に取り込まれるわけではありません。Scala3に正式に取り込まれる機能は Scala Improvement Process (SIP)(JavaのJCP/JSRのようなもの)を通過する必要があり、ここで承認が得られなければScala3に取り込まれることはありません。2019年2月時点ではDottyの新機能の多くはまだSIP以前の提案段階であり、これから徐々にSIPのレビュープロセスに乗せられていくものと予想されます。 ↩5.現行のImplicitsの混乱するポイントについてはこちらの記事で詳しく取り上げられています。 ↩6.暗黙のインスタンスと推論可能パラメータが追加された経緯を知りたい方は#5458と #5852をご確認ください・・・#5458の方は長すぎてまともに追っていませんが元々はwitnessというキーワードで提案されて途中でinstanceに変わって#5825でimpliedに変わったようです。本当に大激論で互換性に対する懸念が何回も強く出ています。とりあえずこの機能はSIPを通さないとScala3に入ることはないという念押しでマージされました。それ以外のContextual Abstractionsの機能(拡張メソッドや型クラスの導出等)はここまでもめた様子はなかったです。さらに#6649でdelegateに変更されました・・・ 本当に何回変わるんだろう・・・ ↩7.このドキュメントは最新版のスナップショットなので、どんどん書き換えられています。今の所過去のバージョンは参照できないみたいです・・・ ↩8.機能の日本語訳は自分がしました。間違っていたら教えてください。 ↩9.一部で実行しやすいように手を加えたり、コメントで説明を加えたり、例が間違っている箇所を修正したりしているのでドキュメントそのままというわけではないです。 ↩10.この件は自分はイシューやプルリクエストは本家に上げていません。理由は既存のイシューやプルリクエストに目を通す余裕が自分にはないのと、Dottyを常用している訳ではないので特に困っていないからです。まぁ端的に言えば自分にはリソースとモチベーションが足りていなかったので、誰か気になる人は本家に上げてみてください。 ↩11.もともとsummonという名前で提案されていましたが、0.13.0-RC-1ではinferに変わり、現在のmasterブランチではtheに変更されています。ちょうどこの記事を書いている途中で変更が masterにマージされたので、混乱しないように慌てて味見の結果からinferを抜きました。 ↩ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/cats-cats-cats/2019/02/24/scala-dotty-contextual-abstractions/"},{"title":"RubyKaigi 2019 in 福岡に参加してきた話","text":"前代未聞の公式パーティーが開催されたRubyKaigi 2019に参加してきました。去年は仙台、一昨年は広島でしたが今年は福岡での開催でした。自分は広島から連続で参加していますが、このイベントはホスピタリティが高く今年も楽しみにしていました。ただし今年は参加者の度肝を抜くネタが２つも仕込まれていたことから特筆すべき「RubyKaigi」になったといっても過言ではないでしょう。 RubyKaigi 2019RubyKaigi 2019, 4/18...4/20, Fukuoka, Japan #rubykaigi 目次1. 会場について1.1. 会場内の様子2. セッション内容2.1. The Year of Concurrency (Keynote) @yukihiro_matz2.2. 福岡県知事2.3. A Type-level Ruby Interpreter for Testing and Understanding @mametter2.4. Pattern matching - New feature in Ruby 2.7 @k_tsj2.5. その他のセッション3. 食事3.1. 朝食3.2. 昼食3.3. 間食3.4. Official Party in 川端商店街4. 令和時代のRubyKaigi5. まとめ 1. 会場について日時と場所は以下のとおりです。初日は羽田から飛行機で飛んで、8時半頃に福岡空港に着きました。時間があり天気も良かったので、地下鉄で中洲川端まで出てそこからは徒歩で会場に向かいました。 日時 4/18(木) - 4/20(日) 10:00〜 場所 福岡国際会議場 1.1. 会場内の様子到着は9時半ごろです。すでに受付には行列ができていました。参加証の後ろの紙はCookpadさんで配っていたRubyパズルです。一日一枚配っていて一枚あたり3問出題されていました。写真に写っているProblemsの3-1は何とか解けましたが、その他はあまり解けませんでした。コメントや改行を用いたトリッキーなものが多かった印象です1。 2. セッション内容2.1. The Year of Concurrency (Keynote) @yukihiro_matz初日のキーノートのもちろんRubyの父であるMatzこと\b「まつもとゆきひろ」さんのキーノートです。 タイトルからして並列性の話かと思いましたが、Ruby3全般の展望のお話が聞けました。個人的に安心したのは静的型付けへの道筋が立ったようだという点です。去年の段階だとかなりもやっとしていた印象ですが、今年は基礎技術が出揃ってアーキテクチャが固まってきたという印象を持ちました2。そしていつもの「型は書きたくない」発言が聞けて大満足です(笑)。 個人的なメモです。詳細を見たい場合はクリックして開いてください。 Rubyは良いと言われている 生産性 柔軟性 楽しい！ Rubyは悪いと言われている 性能 伝統的に遅いと評判だが、年々速度向上している マルチコアを活かしきれない GIL(Giant Interpreter Lock)があるから 大きなチームや大規模プロジェクト向きではない Rubyは大抵の用途には十分良い GitHub、Airbnb、Instacart、Cookpadという実例がある Twitterのようなサービスには向いていない。(リアルタイム性や性能要求が高いから？) そもそもTwitterは遅い1.8を続けたから自滅したんじゃない？ 1.9以降を使っていたら未来は変わったかも Ruby3の改善点 性能 MJITの導入(2.6) ファミコンエミュレータでは速くなるけどRailsでは遅くなる 改善予定 並行性 Guild アクターモデル AutoFiber I/O待ちの改善 静的解析 型は書きたくないでござる Rubyソースには型アノテーションは入れずに、別ファイル(.rbi)に型定義を書く 以下の４つをRuby 3で行う予定 型定義文法 標準ライブラリの型定義 Type Profiler 静的型チェック Sorbet Steep 我々は生き残らなければならない ご飯を食べなければいけない 前進し続けるしかない 賢く進むしかない 自分は天才じゃない。後悔もする(スレッドをいれたこととか) みんなで進むしかない Rubyで世界を良くしたい 2.2. 福岡県知事小川福岡県知事がRubyKaigiに来られて挨拶されました。内容は観光案内とRubyの力に期待を込めた内容でしたが、国際会議の流儀どおりに英語でスピーチしたのはポイントが高いと思います。ただ福岡県がRubyに力を入れていること知っていたので、予想はできたというかこれで度肝を抜かれたというわけではないです2。 2.3. A Type-level Ruby Interpreter for Testing and Understanding @mametter15:40 - 16:20 / Main Hall (3F) @ rubykaigiA 前述したRuby 3で入る予定Type Profilerの発表です。Type Profilerはタイトルの「型レベルインタプリタ」のとおり、型に関する部分を「実行」して、プロファイリングするもののようです。 A Type-level Ruby Interpreter for Testing and Understanding from mametter Type ProfilerはRuby 3で提供予定の静的解析のためのコンポーネントの一つです。静的解析の全体像としては以下の図が分かりやすかったです。Type Profilerの主目的は通常のRubyアプリケーションコードからクラスやメソッドの型を推定して型定義ファイルのプロトタイプを生成することです。この型定義は健全ではないので間違うこともあり、手動で修正が必要な場合があります。 Ruby 3の静的解析Ruby 3 Progress Reportより Type Profilerの動作については以下の図が分かりやすかったです。従来のインタプリタが「値」に注目して実行しているのとは対照的に、Type Profilerでは呼び出し時の引数の型と戻り値の型に注目して評価し、その結果を型シグネチャとして抽出します。 Type Profilerの動作セッションスライドより このような動作のため実際にテストコードを通さないと型シグネチャは得られないみたいです。またその他にもメタプログラミングに弱かったり、状態爆発して遅かったりまだまだ問題はあるそうですが、とりあえず動作するものが公開されたので、今後の進捗に期待しつつ自分も少し触ってみたいと思います3。 2.4. Pattern matching - New feature in Ruby 2.7 @k_tsjこれですよ、これ。最近のRubyで一番欲しかったやつ。パターンマッチングです。どうやら発表前日にtrunkに取り込まれたそうなので、すでに遊べるようです。 その有用性は以下のJSONのパターンマッチングの例を見れば一目瞭然でしょう。 JSONのパターンマッチング例セッションスライドより こういったマッチングはScalaのような静的言語でやろうとすると非常に面倒ですが、Rubyだと本当にシンプルに書けていい感じです。その他にも配列やハッシュで使いやすいように考慮されていたりElixirで言うところのpin operator(^)が実装されていたりするのでかなり実用的になっているなと感じました。ただ一つ残念なのはキーにはまだシンボルしか使えないらしいので、そこは今後に期待です。 2.5. その他のセッションその他も素晴らしいセッションはたくさんありましたが、全てを紹介するのは難しいので簡単な感想(メモレベル)を書きました。自分の心の声や脳内(誤)変換もそのまま消さずに残しておきました。嘘や間違いが見抜けて優しくスルーできる人だけが読んでください(笑)4。 覚悟ができた方はここをクリックしてご覧ください。 Matz Keynote テスト嫌いなんだよね DRYじゃないでしょ Ruby 3 Progress Report RubyコアチームからのRuby3に向けての進捗報告 実質Matzの話の続きで少し詳細化した内容 How To Use OpenApi3 For Api Developer @ota42y OpenApi 3の話 分かる人にはSwaggerがそのままOpenAPIに名前を変えたといったほうが分かりやすいかもしれない 個人的にはRESTよりもGraphQLのほうがスマートだと思っているが・・・ Pragmatic Monadic Programming in Ruby @joker1007 モナドをRubyに実装した話 RubyのASTを 悪用 活用した素晴らしい例 Scalaを パクった インスパイアした素晴らしい例 個人的にはこういうのを待ってた 👍 リポジトリは こちら。後で遊ぶよ。 Fibers Are the Right Solution @ioquatix Call back hell！ Async/Await Hell！ So Fibers are right！ Auto Fiberに期待しておこう All bugfixes are incompatibilities (Keynote) @nagachika リリースブランチのメンテナの6年間の苦労話 「人間は1年に1歳年をとる脆弱性がある」というパワーワードが飛び出る 美しいパッチだと取り込みたくなる 必要のないパッチを入れるのはやめておけ。バグるかもしれない・・・ parse.yは魔境 Syntax Errorは辛い・・・ 回避不能 括弧つけろよ、と思わなくもない Be Practical コミットログを読もう コンフリクトは2割ぐらい 発生バージョンが細かく書いてあったり、具体的に困っているプロダクトがあると取り込みやすい Six Years of Ruby Performance History: But How to Measure…? @codefolio RRB(Ryby Rails Bench)によるとRailsはRuby 2.6は2.0と比較して172%速くなった RRBは実アプリケーションに合わせたマクロなベンチでどの部分が遅いかは教えてくれない そこでRSB(Ryby Simple Bench)の出番 intimate Chat with Matz and mruby developers about mruby @Hir0_IC 今日4/19はmrubyお誕生日・・・\bです mrubyはメモリ消費を抑えるのを頑張っている MatzにGCを作って欲しければ、退屈な会議に参加させればよい 捻挫したからセパレートキーボードにした by Matz 回答者よりも先に質問者が回答を述べる。誘導尋問とかそういうレベルではない Building a game for the Nintendo Switch using Ruby @amirrajan Nintendo SwitchでRubyを動かしやがった・・・ こ、こいつ動くぞ！ RubyData Workshop 資料その2 @mrkn, @284km, @kozo2, @ktou, @znz Red Data Toolsの話 無理しすぎんなよ rubydownは面白そう お菓子とフルーツのデプロイが完了した What is Domain Specific Language? @tanaka_akr Syntax + Semantics = Language この二つの違いをちゃんと知りたい方はコンピュータサイエンスを学びましょう(笑) Smalltalkの2項演算子には優先順位がない。ま、まじか！ 良いことには限界があるが悪いことには限界がない 名言頂きました Lightning Talk Sessions How does TruffleRuby work @kis Javaの話をします。Javaを書こう！ Graal VMとGraalは違う 第3二村射影がTruffleになるという話。コンパイラジェネレータのお話。 How to Make Bad Source @jimlock ブラックジャックを糞コードにした話と仕様を都合よく変える話(ぉぃ ワレ、TRICK2018ノ、フッカツヲ、ノゾム 奴らクレイジーだな Dive into middleware with mruby @spikeolaf 人生を生きているとRDBMSを作りたくなる・・・まじか！ From ㍻ to U+32FF @Y_MITSUBOSHI まぁ令和ネタはあるだろうと思ってた Invitation to the dark side of Ruby @tagomoris Rubyには決してマクロは入れない by Ma●ｚ 👉 Maccro作りました。てへぺろ。 Applying mruby to World-first Small SAR Satellite @ShunsukeOnishi mrubyのコードを衛生に送る ラーメン屋の行列を見てから行きたいじゃないっすか？ The TracePoint bumb! @koic TracePointを使ったテロの話 頭沸いてるんじゃねーか by ko1 悪とかそういうレベルじゃねえなこれは by usa バグ・オブ・ザ・イヤー by nobu wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww やめろ、こんなん草しか生えんわ！ Make Ruby Differentiable @nagachika Rubyでも自動微分したい！的な何か Ruby Committers vs the World curryはお手本を見せるために作った。使うべきではない。 新機能をガシガシ増やしたい人 ノシ by 多数の観衆 投票は信じないよ by Matz わざわざ福岡に来るのはアグレッシブな人なの。真に受けて実行したあとに責任取らされるのは僕なの！ by Matz 公開開発者会議(議事録) HackMDは便利。OSS版はCodiMDで自分はこちらをよく使う。 Haskellの$やElixirの|>相当の演算子がRubyにも欲しい 👉 が演算子の候補になったときは大爆笑。草はやすわ むしろ右代入が欲しい こうしてゆるくてほとんど決まらないのが平常運転 もう少しでRubyコアの開発をsubversionからcgitに移行するよ → したよ! Cleaning up a huge ruby application @riseshia 立ち見が出るほどの超人気セッション Cookpad社で使われているcookpad_allというリポジトリはコード量が50万行以上あり 未使用コードを削りたい KitchenCleanerを開発 1年間更新の無いコード、未実行のコードを自動で見つけ出す GitHubにIssueを立ててgit logからランダムで人を選んでアサイン。まじか！ IseqLogger 使われていない命令を洗い出す。要コンパイル Ruby 2.6から入った“oneshot coverage”は一回でも実行されたかどうかを計測。これは便利そう。 The challenges behind Ruby type checking @soutaro Rubyの型チェッカーの Steepの話 FontAwesomeでRubyを検索するとアヒルがでてくる。分かっているじゃないか（ニヤリ） アヒルはスケールするよ Rubyのシグネチャ定義言語 後付の型定義言語なのでかなり柔軟に表現できる。TypeScriptの影が見えた・・・ openの型定義がとんでもないことになってる・・・闇が深い・・・ The future of the Bundled Bundler with RubyGems @hsbt RubyGemsの多要素認証を設定してください。🙏 Rubyを使うのにbundlerをまず入れなきゃ、みたいなのは体験が良くないのでやめたい Reducing ActiveRecord memory consumption using Apache Arrow @mrkn Apache Arrowを使ってActiveRecordのメモリ削減できるかという話 先日の発表は間違っていました 列指向。Pandasと言われて納得した。データフレームね。 Red Chainer and Cumo: Practical Deep Learning in Ruby @sonots @hatappi 現在のPythonのDNNスタックに対応するものがだいたいRubyにも出揃った Chainer-> RedChainer, TensorFlow -> TensorFlow.rb, MXNet -> MXNet.rb, NumPy ->Numo::NArray, CuPy -> Cumo ONNXを使った連携。ProtocolBuffer使う。 numoをcumoにしたら奇跡的に動いた！ Ruby3で3倍速くするという話をしてますけど、Cumoを使うと75倍速い（ドヤ） Optimization Techniques Used by the Benchmark Winners (Keynote) @jeremyevans0 SequalやRodaといったベンチマークで高性能を叩き出すフレームワーク作者の最適化術 執念は見習いたい Rubyが速くなれば万事解決(ぉぃ 3. 食事いつも何がでるか楽しみですが、今年は特にやばかったです。 3.1. 朝食二日目と三日目は朝食がでました。バイキング形式です。前日に飲みすぎて胃もたれしていたので少なめにしています・・・ 3.2. 昼食まさかの屋台！トップページが伏線だったとは・・・屋台は5軒出ていたのでパノラマ写真にしてみました。 タイムラプスにした方もいるようです。 10分タイムラプス #rubykaigi pic.twitter.com/o7WdPthxgI— ORGiL Mk.Sein (@orgil_) April 19, 2019 ビーフストロガノフと焼きラーメンを食べました。とても美味しかったですが、屋台の暖簾はフェイクだったので店を間違えました・・・Rubyラーメン食べたかった・・・ 一日だけお弁当にしてみました。これも美味しかったです。 3.3. 間食お茶やコーヒーはブースで入れてもらいました。特に八女茶の甘みと旨味のコラボレーションが忘れられない・・・ お菓子やフルーツも大量にGetできました。 3.4. Official Party in 川端商店街技術カンファレンスとしては前代未聞の商店街のアーケードをまるまる使った公式パーティーです。常人の発想じゃない(褒め言葉)ですね。震えが止まりません・・・ Yahooニュースにもなったみたいです。 このパーティーは本当に驚愕でしたが、控えめに言って最高でした。参加できてよかったです。 4. 令和時代のRubyKaigi最後の最後でまさかの令和ネタが飛び出ました。次の開催は長野県松本市です。この「松本」で開催されるRubyKaigiは名前的に縁起がよく、正しく令和時代の最初のRubyKaigiに相応しい場所と言えると思います。これがRubyKaigiで一番度肝を抜かれたネタでした。不意打ちすぎる・・・ 5. まとめRubyKaigiはフレンドリーで活気に満ちた素晴らしい国際カンファレンスです。この記事を読んでくれた方に、少しでも\u001cRubyKaigiの楽しさをお伝えできたなら幸いです。 参加者、関係者の皆様、お疲れ様でした！ 1.問題はExtraステージも含めて公開されているので興味がある方はチャレンジしてみてはいかがでしょうか？ ↩2.とは言っても一介の技術イベントで県知事が挨拶するのは異例のことだとは思いますが・・・ ↩3.Gitリポジトリの中にpdfのペーパーも入っていたので合わせて読もうと思います。 ↩4.メモの内容は登壇者の発言も自分の感想もごちゃまぜです。また、登壇者の発言と思しきものも自分の印象で若干誤変換が入っている可能性があります。従って実際のセッション参加者なら多少は意味のある内容ですが、それ以外の人は鵜呑みにしないでください。RubyKaigiのセッションはいずれYouTubeに上がると思われるので、それを見たあとでなら楽しめるかもしれません(笑)。 ↩ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/cats-cats-cats/2019/04/23/ruby-kaigi-2019/"},{"title":"全プログラマに捧ぐ！図解「ノートブック」","text":"Jupyter Notebookを使い始めて半年経ちました。最初は機械学習のためのツールとして触り始めましたが、徐々にデータサイエンティストだけの玩具にしておくのは勿体無いと思うようになってきました。本記事では一般のプログラマにも伝わるようになるべく図解で「ノートブック」を解説してみたいと思います。 目次1. はじめに2. ノートブックとは3. ノートブックと実行結果4. ノートブックとセル5. ノートブックとカーネル6. ノートブックとファイル7. ノートブックの変換8. ノートブックの共有9. ノートブックとJupyterLab10. ノートブックを始めてみる11. ノートブックの用途12. まとめ 1. はじめに本記事はJupyter Notebookにおける「ノートブック」という機能に着目して解説したものです。「ノートブック」は、REPL1の進化形態であり、仮にデータサイエンティストでないとしても全プログラマが知っていて損はないアイデアだと思います。 2. ノートブックとはノートブックとは以下の図のように「コード」と「実行結果」と「コードのメモ」をまとめたものです。コードのメモは恐らくプログラマの方にはおなじみのMarkdown形式で記述することができます。 ノートブックの凄いところはこのプログラムの理解に必要な３点セットを上手にまとめている点です。これらがバラバラに管理されていたとなると、プログラムのコードの動作を他人に理解させようとすると非常に苦労することが目に見えますし、もちろん書いた本人にも優しくないです(笑)。 面白いのは以下の図のようにコードだけでなくメモも「実行(Run)」できる点です。実行後のプログラムのコードの下にはコード実行結果が出力されているのはお分かり頂けると思いますが、メモの実行結果はMarkdownがレンダリングされた結果となります。また図を見てお分かりのとおり、コードやメモはきちんと色付けされており視認性もよいです。 ノートブックが実行されるのは以下の図のようにノートブックサーバになります。コードやメモはそれぞれノートブックの中の「セル」と呼ばれるものに格納されていて、セル単位で対話的に実行が可能です。 また、コードの編集や実行はブラウザを通して行うことになりますが、マウス操作以外にもキーボードショートカットやコード補完等が使えるので一般的なWebアプリケーション以上に快適な作業が可能です。 3. ノートブックと実行結果実行結果とはプログラム自体が画面に出力したものと、プログラムの「最後の行の戻り値」になります。以下のノートブックの一部を使って説明します。 上記の灰色の枠内がプログラムです。半径5の円の面積を計算しています。その枠の下の「78.53981633974483」が戻り値になります。これはプログラムの最後の行「math.pi * r ** 2」を評価した結果が戻り値になっています。 初めての人が陥りやすい罠として、最後の行を「area = math.pi * r ** 2」のような代入文にして、何も表示されず困るというものがあります。これはPythonの代入が戻り値を持たない仕様のためにおこる現象です2。この場合は代入文の後に「area」を追加して最後の行を表示したい変数に変更するか、以下のようにprint関数で明示的に画面出力すればよいです3。 さらにノートブックは、テキスト以外にも他のライブラリと連携してリッチな出力結果を実現できます。以下は表を表示してみました。 グラフも表示可能です。 画像処理結果の表示もお手の物です。 動画の埋め込み4なんかも可能です。 4. ノートブックとセルセルとは以下の図5のように、ノートブック内のプログラムのかたまりであり、セル単位でプログラムの編集、実行、削除が可能です。 セルには編集モードとコマンドモードがあり、直接マウスで選択すると編集モードになります。編集モードでプログラムを記述して「Shift + Enter」キーを入力することでセルの実行が可能です。編集モードで「Esc」キーを入力することでコマンドモードに移行することができます。コマンドモードではその名のとおりセルに対して様々な命令を実行することができます。例えば「d d」を入力することでセルの削除が可能です。 ノートブックでは基本的に下にセルを追加して、実行結果を確認したい単位でプログラムを書いて実行することを繰り返します。一度実行したセルもまたセル内のプログラムを編集して再実行することができます。そのためセルの左側には実行の順番を表すための番号が振られており、実行するごとに１増えていきます。 赤枠で表示されているのは、プログラムを実行して発生した例外のスタックトレースです。このようにスタックトレースも色付きで分かりやすく表示されるのでデバッグには重宝します。プログラムでエラーになった場合を特定するためにセルを分割して、例外が発生した箇所を狭めていく手法もよく使われると思います。 セルは一番下だけでなく、セルとセルの間にも挿入することができます。これは後で忘れていた処理を追加するのに便利ですが、注意すべき点があります。以下の図は上から２番めのセルの下に新しいセルを挿入して、プログラムを記述して実行した後の状態を示しています\b。セルの実行順番はセルの左の番号の通りです。 この図で注意すべきは3点あります。１つ目の注意点は、挿入したセルの実行結果はすでに実行済みのセルの実行結果には影響を与えないということです。この図の場合一番下のセルの最終行はa + bとなっていますが、今回のようにその上のセルに挿入してbの値を書き換えても最後のセルの実行結果は変わりません。 次に注意すべき点は、いったんこのノートブックを終了して再度ノートブックを「先頭から」実行したときに実行結果が変わる点です。問題は最後のセルで変数aとbを上書きしている点です。このため上から3番目のセル(挿入したセル)で、実行結果が変わってしまいます。この場合array([9, 12, 15])だった結果が[1, 2, 3, 4, 5, 6, 4, 5, 6]になります。さらに続けて最終セルを実行しようとすると例外が発生します。 最後に注意すべき点は一番最後のセルでimport文を使っている点です。一回実行されたimport文はノートブックの範囲内で有効なので、セルの挿入位置にかかわらずインポートされたライブラリの機能が利用できます。しかし、ノートブックを終了して再度先頭から実行しようとすると、当然import文の実行前にそのライブラリの機能を使おうとすると怒られます。今回の例ではさらに紛らわしくて実行結果が変わるという現象にもつながっています。 従って、ノートブックを先頭から再実行する可能性があり、かつセルを一番下以外に挿入する場合は、セルを一番上から実行しても問題ないかということを意識する必要があります。このトピックはおそらくノートブック利用者が一度は通る道だと思い言及しました6。 5. ノートブックとカーネル一つのノートブックには必ず一つのプログラミング言語が紐付きます。下の図のようにノートブックを開くと裏では紐付いたプログラミング言語の実行環境が起動して、セルの実行のために待ち受けています。このプログラミング言語の実行環境のことを「カーネル」と呼びます。現在、非常に多くのカーネルが公開されています。 またカーネルは図のようにノートブックを開くたびにひとつ起動されるイメージで、カーネル間でのメモリ等の共有はなく完全に独立しています。また、このカーネルは明示的にシャットダウンしないとずっと動きっぱなしになります。従ってノートブックを開くとカーネルが起動してマシンのリソースを消費するので、不要なカーネルはこまめにシャットダウンすることをおすすめします。 6. ノートブックとファイルノートブックの実体は一つのファイルです。もう少し具体的に述べると拡張子が「.ipynb」でJSONフォーマットで保存されています。単なるファイルなのでフォルダによる整理やGit等のバージョン管理システムによる管理も可能です7。 7. ノートブックの変換ノートブックは以下の図のように様々な形式に変更可能です。単純に実行スクリプトに変換できるのはもちろんですが、HTMLやマークダウンにも変換できるのでQiitaやブログサービスへの埋込も可能です。Reveal.jsのスライドにすればプレゼンテーションにも利用できます。 8. ノートブックの共有ノートブックの実体はファイルだということは前述のとおりですが、このファイルは様々な環境で開くことができます。例えばVisual Studio Codeでは拡張機能でノートブックに対応しています。さらに、クラウド上にはノートブックに対応したマネージドサービスが揃っているので、ローカルで作成したノートブックをクラウドで実行するのも簡単です。また編集や実行機能が必要なければ、nbviewerのGitHubのように表示だけが可能なサービスも存在するので、コードや実行結果の共有だけがしたい場合はこちらのほうが手軽です。 9. ノートブックとJupyterLabJupyterLabはJupyter Notebookの次世代ユーザインターフェースです。タブインタフェースで非常に使いやすく自分も愛用しています。まだ、バージョン1.0には達していませんが、普段の利用にはほぼ問題ない感じです。現在は混在\b期間でどちらも非常に多く使われており甲乙付け難いです。拡張機能も含めた安定性や情報の多さを取るならJupyter Notebookに軍配が上がりますが、一部の先進的な機能や格好良さを求めるならJupyterLabをおすすめします。以下の画面は自分が実際に利用しているJupyterLabの画面です8。 10. ノートブックを始めてみるノートブックの始め方はいろいろあるので、ざっくりとしたチャートを自分の主観で書いてみました。最初の一歩を踏み出すための道標としてご利用ください9。 エントリー URL Try Jupyter https://jupyter.org/try Colaboratory https://colab.research.google.com Sage Maker https://aws.amazon.com/jp/sagemaker Azure Notebooks https://notebooks.azure.com Binder https://mybinder.org zero-to-jupyterhub-k8s https://github.com/jupyterhub/zero-to-jupyterhub-k8s jupyterhub-deploy-docker https://github.com/jupyterhub/jupyterhub-deploy-docker JupyterHub https://jupyterhub.readthedocs.io/en/stable Jupyter Notebook https://jupyter.org/install base-notebook https://hub.docker.com/r/jupyter/base-notebook minimal-notebook https://hub.docker.com/r/jupyter/minimal-notebook all-spark-notebook https://hub.docker.com/r/jupyter/all-spark-notebook pyspark-notebook https://hub.docker.com/r/jupyter/pyspark-notebook tensorflow-notebook https://hub.docker.com/r/jupyter/tensorflow-notebook datascience-notebook https://hub.docker.com/r/jupyter/datascience-notebook Go back to TOP OF THIS PAGE このページの先頭から再度読み直してください 11. ノートブックの用途ノートブックは非常に用途が広いので、プログラミングにおける様々な場面で活用することができると思います。以下の図は思いついた用途です。 12. まとめ以下、「ノートブック」のまとめです。 「ノートブック」はコードと実行結果とコードのメモをまとめたものである 「ノートブック」の実体はファイルである 「ノートブック」はMarkdown、Asciidoc、LaTeX、HTML、PDF、実行スクリプト、スライドなど様々な形式に変換できる 「ノートブック」を利用できる複数のクラウドサービスが存在する 「ノートブック」にはプログラミング全般に幅広い用途がある Jupyter Notebookはデータサイエンスの分野ではほぼ必須とまで言われるようなツールになりましたが、一般のプログラマへの浸透具合はいまいちと感じたので、データサイエンスの文脈からなるべく切り離して解説をしてみました。 本記事が「ノートブック」の理解と普及の一助になれば幸いです。1.REPLは「Read-Eval-Print loop」の略で、入力された部分ごとに評価して表示することを繰り返す、対話型実行環境を意味しています。PythonにおけるiPythonやRubyにおけるirbにあたります。インタラクティブシェルと呼ばれることもあります。 ↩2.Pythonでは代入以外にもifやwhile等の制御構造も戻り値を持ちません。一方Rubyのように、代入やifやwhileが戻り値を持つ言語もあります。 ↩3.printは戻り値を持たない関数なので、戻り値は表示されません。しかし一般的なPythonの関数は戻り値を持つもの(returnで値を返す)が多いので、大抵は関数の結果確認のために「最後の行の戻り値」を有効活用できます。 ↩4.埋め込まれている動画は「 https://www.youtube.com/watch?v=XQB3H6I8t_4 」になります。 ↩5.ノートブックの図はJupyter Notebookの新インターフェースであるJupyterLabを元に作成しています。Jupyter Notebookだと若干見え方は異なりますが、ここで説明される概念は共通です。 ↩6.この注意点はPythonを例にしているので他の言語では当てはまらない場合があります。ノートブックの特性と言語の特性の組み合わせで思わぬ落とし穴があるかもしれないということだけ覚えておくといいかと思います。 ↩7.ノートブックには実行結果も含まれますが、実行結果を除いてバージョン管理しようとすると少し工夫が必要になります。手段はいろいろあるので気になる方は検索してみてください。 ↩8.画面に写り込んでいるプログラムは PythonによるAIプログラミング入門の例題になります。 ↩9.ツッコミどころがあるのは理解しております。スルーして頂けると幸いです。 ↩ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/cats-cats-cats/2019/04/06/understanding-notebook/"},{"title":"全プログラマに捧ぐ！図解「パターンマッチ」","text":"パターンマッチを使い始めてかなりの時間が経ちました。最初は関数型言語の一機能として触り始めましたが、徐々に関数型言語のユーザだけの玩具にしておくのは勿体ないと思うようになってきました。プログラミングにおいて、パターンマッチほど有用であるにもかかわらず普及が遅れている言語機能は他にないと思います。本記事ではその状況に一石を投じたく、一般のプログラマにも伝わるようになるべく図解で「パターンマッチ」を解説してみたいと思います。 目次1. はじめに2. パターンマッチとは3. パターンマッチとパターン4. パターンマッチの構造5. パターンマッチと照合6. パターンマッチと分解7. パターンマッチと変換8. パターンマッチと合成9. パターンマッチとパターンの重なり10. パターンマッチと広がる世界11. まとめ 1. はじめに本記事はプログラミング言語における「パターンマッチ」1という機能に着目して解説したものです。「パターンマッチ」は、switch文の強化版2であり、仮にパターンマッチを持たないプログラミング言語のユーザだとしても全プログラマが知っていて損はないアイデアだと思います。 2. パターンマッチとはパターンマッチは以下の図のように、入力データを「パターン」と呼ばれる特定の構造と照合して、データとパターンが適合(マッチング)した場合に分解して要素を取り出します。 パターンマッチの凄いところは、入力データの値だけではなく、構造にも着目してデータを抽出できることです。上記の図は入力データとして同じ整数の配列([1,6,5,2])を用いて、4種類のパターンを用いてパターンマッチを実行している様子です。1番目のパターンは特に説明は不要だと思うので、二番目のパターンから説明するとパターン([1,x,5,y])のように、構造から値を抽出しておきたい場所を変数にしておけば、データ構造を分解することができます。抽出した変数は後の変換処理で利用できます。3番目のパターンはパターンマッチが失敗していますが、理由は簡単でパターンと入力データの長さが異なるからです。4番目のパターンは再帰処理でよく使うパターンで配列の先頭とそれ以外にデータを分割できます。 このようにパターンマッチを用いると、データ構造をパターンを用いて分解して処理ができるので、様々なアルゴリズムが書きやすくなるというメリットがあります。 パターンマッチの構文はプログラミング言語ごとに異なりますが、概ね「入力」と「パターン」と「変換処理」を記述できます。以下はscalaを用いた一番シンプルなパターンマッチ構文の例です。 scalaのパターンマッチ構文123入力 match { case パターン => 変換処理} 変換処理では分解によって取り出した変数を利用した処理を書くことができます。そして、変換処理の結果自体がパターンマッチ全体の結果となります。パターンマッチに失敗した場合は一般的には例外が発生します。 最初の図の4つのパターンマッチをScalaで記述した例が以下になります。Scalaを知らなくても上記の図が理解できていれば、どんな処理をしているのか想像がつくと思います。 scalaを用いたパターンマッチ例12345678910111213141516171819val result1 = Seq(1, 6, 5, 2) match { case Seq(1, 6, 5, 2) => \"ok\"}// result1 = \"ok\"val result2 = Seq(1, 6, 5, 2) match { case Seq(1, x, 5, y) => x + y}// result2 = 8val result3 = Seq(1, 6, 5, 2) match { case Seq(x, y) => x + y}// 例外発生！val result4 = Seq(1, 6, 5, 2) match { case Seq(x, tail @ _*) => tail}// result4 = Seq(6, 5, 2) 3. パターンマッチとパターンパターンはいくつかの基本形に分類されますが、以下は自分が特に重要だと思う9つの基本形です3。パターンマッチで一番誤解を受けいているのがこの部分で、この基本形を十分に理解せずにはパターンマッチを使いこなしているとは言えないと思います。そしてこの基本形を使いこなせるようになればパターンマッチ、ひいてはプログラミングの世界が大きく広がると思います4。 基本形は組み合わせてより複雑なパターンを記述することができます。重要な役割を果たすのが入れ子構造にすることが可能なシーケンスパターンとタプルパターンです。 上記の複雑なパターンは「定数パターン」、「変数パターン」、「ワイルドカードパターン」、「シーケーンスパターン」、「タプルパターン」、「asパターン」、「パターンガード」の7つの基本形を組み合わせたパターンになります。このようにパターンは入れ子にすることで飛躍的に表現力が増し、応用範囲が広がります。さらにはパターンマッチで分解した結果を「変換処理」の中でさらにパターンマッチすることもできます。つまりパターンだけでなくパターンマッチ自体も入れ子にすることができます。以下の例はScalaを用いたパターンマッチを入れ子にした例です5。 scalaを用いたパターンマッチの入れ子の例1234567val result = Seq(Seq((true, 5), (false, 10)), Seq(), Seq((true, 1))) match { case a @Seq(Seq((true, _),(false, x)), _*) if x > 3 => a match { case Seq(_, y @ _*) => x + y.size }}// result = 12 ここまで読んでいただいた方はパターンマッチにおける基本形の重要さが理解できたと思います。そして一番最初に図解したパターンがどの基本形にあたるかも簡単に分かると思います。プログラミングの重要な目的の一つはデータを処理することだと思います。そしてパターンマッチはデータ構造をパターンで分析し処理するのにうってつけの機能です。従ってパターンマッチは間違いなくプログラミングの本質に迫る機能だと考えられます。 4. パターンマッチの構造プログラミング言語のパターンマッチは、以下の図のとおり入力と出力がある一種の関数と考えることができます。パターンマッチの内部は「パターン」と「変換処理」と呼ばれるユーザが定義するデータと「照合(check)」、「分解(destructure)」、「変換(transform)」と呼ばれる３つの工程から構成されています6。 上記の図は「シーケンスパターン」を用いて、整数の配列[1,2,3]の入力に対するパターンマッチを実行している様子を示しています。この入力のパターンマッチは成功して実行結果として5を返しますが、もし、仮に入力が[1,2]だった場合にはパターンの照合に失敗して赤矢印で示した「NG」へ行き、パターンマッチが失敗します。 パターンマッチを関数とみたときにこのように失敗する可能性がある場合は、失敗しない関数（数学的な関数、全関数とも言う）と区別して「部分関数」と呼ぶことがあります。部分関数を全関数にするにはパターンを網羅的にする必要があります。 5. パターンマッチと照合「照合」の役割は、以下の図のようパターンに適合(マッチ)する入力データを選別することです。そして適合したデータは次の「分解」のフェーズに送られます。 6. パターンマッチと分解「分解」の役割は、以下の図のようにパターンに従ってデータを分解して、変数に対応する値を入力データから見つけて変数に入れることです。分解の結果は次の「変換」のフェーズに送られます。 この分解はパターンマッチ構文以外でも見ることができます。例えば以下は擬似コードですが代入がシーケンスパターンのパターンマッチになっています。 12[a, *, b] = [1, 2, 3]// a = 1, b = 3 このように代入に見えてパターンマッチになっているケースもあるので、実は知らないうちにパターンマッチのお世話になっているかもしれません。 7. パターンマッチと変換「変換」の役割は、以下の図のように変換処理の変数に分解結果の変数を引き当てて、評価することです。評価した結果は出力としてパターンマッチ全体の結果になります。 8. パターンマッチと合成パターンマッチの合成には直列合成と並列合成があります。直列合成のイメージは以下の図のように通常の関数の合成のイメージと同じで前の関数の出力と後ろの関数の入力の型が合えば合成することができます7。 ソースコードの方が理解しやすい方がいるかも知れないので以下にScalaで２つのパターンマッチを直列合成をした例を記載します。 Scalaでパターンマッチの直列合成12345val match1 = (a:Int) => a match {case x if x % 3 == 0 => x * 2}val match2 = (a:Int) => a match {case x if x > 5 => x * 10}val composed = match1 andThen match2composed(3) // 60composed(5) // MatchError 以下はパターンマッチの並列合成です。並列合成は大抵の言語のパターンマッチ構文に組み込まれているので、あまり「合成」と意識することは少ないかもしれません。しかし直列合成と比較するとプログラミングの論理演算であるandとorと類似していることが分かると思います。つまり、直列合成の場合はパターンマッチが全て成功しないと合成されたパターンマッチが成功しないのに対して、並列合成ではパターンマッチが一つでも成功すれば、合成されたパターンマッチが成功します。 以下は直列合成の例を並列合成に書き換えたものです。結果が変わっているのがわかると思います。 Scalaでパターンマッチの並列合成123456val composed = (a:Int) => a match { case x if x % 3 == 0 => x * 2 case x if x > 1 => x * 10 }composed(3) // 6composed(5) // 50 9. パターンマッチとパターンの重なり並列合成のパターンマッチの場合には、パターンの重なりを意識することが重要です。以下の図は整数の集合における基本的なパターンの重なりを分類したものですが8、このようにパターンを図で思い描けるようになるとパターンの設計に非常に役に立ちます。 並列合成では上のパターンマッチから順番に照合されるため、パターンに重なりがあると上のパターンマッチが優先されることになります。特に包含関係にあるパターンは上に大きいパターンを持ってくると下のパターンが隠れてしまって全く照合されない事態になるので、注意が必要です。 またパターンを網羅的にすることでパターンマッチの失敗がなくなり、無意識にバグを作り込むことを防ぐことができます。従ってパターンマッチは特に理由がない場合は網羅的にすることが望ましいです。網羅的にするのに適した基本パターンは「変数パターン」と「ワイルドカードパターン」になるので、並列合成の一番最後にこれらのパターンを入れることを検討してください。 10. パターンマッチと広がる世界従来パターンマッチはHaskellに代表されるような関数型言語の十八番でしたが、現在では関数型プログラミングに源流を持たないプログラミング言語でもパターンマッチを実装するようになってきました。C#では7.0以降でパターンマッチが利用可能であり、Rubyでもすでにtrunkではパターンマッチが利用できます9。また比較的新しく出た言語は最初からパターンマッチが使える場合が多く、パターンマッチの世界は広がり続けています。仮にお気に入りの言語にパターンマッチがなかったとしても諦めるのはまだ早いかもしれません。使い勝手は言語に統合された機能よりは劣るかもしれませんが、パターンマッチのためのライブラリも数多く公開されています。 言語としての変わり種は Egisonです。「直感をそのまま表現するパターンマッチング 」という謳い文句で、パターンマッチとして非常に面白いので気になった方はぜひ触って見てください。 このように少しずつですが着実にパターンマッチが使える言語が増え続けているのは、パターンマッチがプログラミング全般で非常に用途が広く、使いこなすことで直接的にプログラマの能力を拡張するからだと思っています。以下の図は思いついたパターンマッチの用途です。 11. まとめ以下、「パターンマッチ」のまとめです。 「パターンマッチ」は入力データを「パターン」と呼ばれる特定の構造と照合して、データとパターンが適合した場合に分解して要素を取り出す 「パターンマッチ」のパターンには9つの基本形があり、基本形を組み合わせてより複雑なパターンを表現できる 「パターンマッチ」は「照合」、「分解」、「変換」から構成される 「パターンマッチ」の合成方法は２種類ある 「パターンマッチ」ではパターンの重なりを意識する必要がある 「パターンマッチ」は様々な言語で利用可能になってきている 「パターンマッチ」はプログラマの能力を直接的に拡張する パターンマッチは関数型プログラミングでは特に再帰関数と相性が良く欠かせない存在ですが、一般のプログラマへの浸透具合はいまいちと感じたので、関数型プログラミングの文脈からなるべく切り離して解説をしてみました。 本記事が「パターンマッチ」の理解と普及の一助になれば幸いです。 1.ここで言うぱ「パターンマッチ」はパターンマッチを実装しているプログラミング言語の総和でイメージしており、特定のプログラミン言語のパターンマッチを意味していません。従って、本記事で解説しているパターンマッチの機能や用語は個別の言語でそれぞれ異なる場合があります。 ↩2.ここで言う「switch文」とはC言語のswitch文をイメージしています。また、ここではswitch文とパターンマッチとの歴史的な繋がりではなく、機能的な包含関係について「強化版」という表現をしています。 ↩3.パターンの記述は疑似言語で記載しています。また、パターンマッチの対応を謳っているプログラミング言語でも、いくつかの基本形が使えない場合があります。しかし上の6つのパターンはだいたい使えるのではという感触です。 ↩4.9つの基本形は非常に重要なのでA４サイズで収まりがいいように図を工夫しました。チートシートとしてご利用ください。机や冷蔵庫に貼って忘れないようにするのもいいかもしれません(笑)。 ↩5.ネストができることを示すだけの例なのでコードに特に深い意味はないです。 ↩6.工程の呼び方はいろいろあります。例えばdestructureとextractと呼んだりtransformをmapと呼ぶ場合もあるようですが、ここでは自分が一番分かりやすいと思った表現を採用しています。また、「照合」と「分解」だけを指して「パターンマッチ」と呼ぶ流儀も存在しますが、多くのプログラミン言語のパターンマッチの構文には変換処理も含まれるので、この記事では「変換」も含めて「パターンマッチ」と呼びます。 ↩7.実際には型だけでなく関数の定義域や値域を考慮する必要がありますが、数学的な話になってくるので詳細は割愛します。 ↩8.整数にしたのはイメージが簡単にできると思われるためであり、ここで説明するパターンの重なりは整数以外の集合にも同じことが言えます。 ↩9.正式にはRuby 2.7で利用可能になる予定です。 ↩ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/cats-cats-cats/2019/04/30/understanding-pattern-matching/"},{"title":"「エンジニアの心を整える技術」が予想以上に「技術書」だった件","text":"「エンジニアの心を整える技術」は実は気になって技術書展で一度は手にとったのですが、ちょうど開いたページがプロジェクト炎上中の様子を記述していて、また「プロジェクト炎上の火消しネタか・・・」と勝手に思い込んでしまいそっと本を閉じてしまいました。今まで何回かその手の本を読んだことがあったのですが、結局は体験談止まりで一回読めばお腹いっぱいというものがほとんどでした。 しかし、「エンジニアの心を整える技術」は一味違いました。著者の方がnoteで2章まで公開されていて、本の目次まで見てようやく勘違いに気づきました。この本は体験談から一歩進んだれっきとした「技術書」だったのです。 「エンジニアの心を整える技術」をnoteで2章まで無料公開します! #感想まとめ #技術書典6｜karamage@「エンジニアの心を整える技術」好評発売中！｜note このnoteは、2019年4月14日に開催された「技術書典6」で頒布し、これまで600部以上(書籍＋PDF版)販売している「エンジニアの心を整える技術 - 誰でも実践できる心のリファクタリング術 - 」のPDF版のダウンロードページになります。 技術書典6での当日の販売の… 目次1. 過去の閉ざされし封印2. 再び邂逅する3. 3章まではIT業界「あるある」4. マインドフルネス5. アドラー心理学6. 人は本当に変わることができるのか？7. 「エンジニアの心を整える技術」を読み始める前の事前準備8. まとめ 1. 過去の閉ざされし封印技術書展6は自分も参加していてレポートはここに書いたとおりですが、ちょうどこの本の販売ブースの前を通ったときに「エンジニアの心を整える技術」というタイトルで目を惹かれました。しかも、サブタイトルが「誰でも実践できる心のリファクタリング術」だったので、大いに反応しました。エンジニアならみんな大好き「リファリクタリング」です1。検証しないわけにはいきません(笑)。 しかし最初に開いたページが、運悪くプロジェクト炎上ネタだったのが災いしました。過去この手のネタは読んだことがあったのですが、体験談止まりで「あるある」以外の感想しか出てこなかったのでこの本もきっと同じだろうなと決め込んでしまいました。 もうちょっと他のページも開いてみれば良かったのですが、「⽉の残業時間200 時間超えが続く」とか「ベテラン主任さん死亡」とか書いてあると自身の封印していた記憶をこじ開けてしまいそうで、「これ以上読んではいけない」と心が警鐘を鳴らしました。楽しいはずの技術書展でこれ以上「SAN値」を削られるわけにはいかなかったので、軽く笑顔で会釈をしながら本を元の位置に戻してその場を去りました。 このようにして「エンジニアの心を整える技術」とのファーストコンタクトは見事に失敗してしまいました。 2. 再び邂逅するそして先日のnoteの記事で目次を目にして、速攻で購入してしまいました。いや、本当にまた巡り会えてよかったです。私が感じたこの本の魅力は4章以降にありました。でも、3章までもいい内容なので順を追って振り返ってみたいと思います。 ただここからは多少のネタバレを含みますので、少しでもネタバレをするのが嫌な方は読後にお読みください。購入を迷われている方はぜひこの先を読んで購入の参考にしてください。 3. 3章まではIT業界「あるある」まず、1章にはこの本が必要となる背景が書かれています。「マインドフルネス」や「アドラー心理学」に反応できればこの本の価値が分かるのですが、そのことは後述します。2章/3章はプロジェクトの炎上案件と、IT業界のブラックな場面の紹介になっています。まぁ、業界経験が長ければ耳にしたことがあるネタが多くて、正直自分は「あるある」と頷いて終わりました。 内容は非常に良かったので、業界経験の浅い方にはぜひ読んでもらいたい内容です。 4. マインドフルネス4章ではこの本で是非読んでもらいたい「マインドフルネス」のことについて書かれています。マインドフルネスとは瞑想および瞑想によって得られる精神状態を指すようです。 ベトナムの僧侶ティク・ナット・ハンさんが瞑想法のキーワードとして⽤いたため、そこに⾄るための瞑想そのものを｢マインドフルネス｣と表現されています。Google やApple が社員研修に取り⼊れたことで、⼀気に有名になりました。 「エンジニアの心を整える技術」13ページより 瞑想というとちょっと迷信っぽく思いましたが、学術的な検証はされているそうです。 瞑想を⾏うことによって幸せを感じる脳内分泌物質とも呼ばれるセロトニンの分泌が促されることにより、⼼の落ち着きや満⾜感・充⾜感がもたらされるという学術的裏付けがあります。 「エンジニアの心を整える技術」59ページより 自分はヨガの文脈で過去に瞑想をしたことがありますが、運動やスポーツ以外の文脈での瞑想を思いつかなかったのでこれは新鮮でした。確かに瞑想は心を落ち着けるのでこれをエンジニアの生活に取り入れることに何ら支障はありません。 それでは具体的にどうやって取り入れていけばいいのかということが、本書の4章に書いてあるのでぜひ読んでみてください。エンジニア向けの瞑想術が書いてあります。自分がこの本を「技術書」だと思ったのはまさにこの部分で、学術的な裏付けを述べてそれを実践するための具体的な手法を述べているのが気に入りました。著者曰く「瞑想のコスパは最強」だそうですが、自分も同感です。 あと本格的にマインドフルネスを実践したい方には以下の本が本書のなかでオススメされていたので、自分も後で読んで見たいと思います。 (function(b,c,f,g,a,d,e){b.MoshimoAffiliateObject=a;b[a]=b[a]||function(){arguments.currentScript=c.currentScript||c.scripts[c.scripts.length-2];(b[a].q=b[a].q||[]).push(arguments)};c.getElementById(a)||(d=c.createElement(f),d.src=g,d.id=a,e=c.getElementsByTagName(\"body\")[0],e.appendChild(d))})(window,document,\"script\",\"//dn.msmstatic.com/site/cardlink/bundle.js\",\"msmaflink\");msmaflink({\"n\":\"サーチ・インサイド・ユアセルフ――仕事と人生を飛躍させるグーグルのマインドフルネス実践法\",\"b\":\"\",\"t\":\"\",\"d\":\"https:\\/\\/images-fe.ssl-images-amazon.com\",\"c_p\":\"\\/images\\/I\",\"p\":[\"\\/41td8q2cgzL.jpg\",\"\\/31w8YWEptfL.jpg\"],\"u\":{\"u\":\"https:\\/\\/www.amazon.co.jp\\/%E3%82%B5%E3%83%BC%E3%83%81%E3%83%BB%E3%82%A4%E3%83%B3%E3%82%B5%E3%82%A4%E3%83%89%E3%83%BB%E3%83%A6%E3%82%A2%E3%82%BB%E3%83%AB%E3%83%95%E2%80%95%E2%80%95%E4%BB%95%E4%BA%8B%E3%81%A8%E4%BA%BA%E7%94%9F%E3%82%92%E9%A3%9B%E8%BA%8D%E3%81%95%E3%81%9B%E3%82%8B%E3%82%B0%E3%83%BC%E3%82%B0%E3%83%AB%E3%81%AE%E3%83%9E%E3%82%A4%E3%83%B3%E3%83%89%E3%83%95%E3%83%AB%E3%83%8D%E3%82%B9%E5%AE%9F%E8%B7%B5%E6%B3%95-%E3%83%81%E3%83%A3%E3%83%87%E3%82%A3%E3%83%BC%E3%83%BB%E3%83%A1%E3%83%B3%E3%83%BB%E3%82%BF%E3%83%B3\\/dp\\/4862762271\",\"t\":\"amazon\",\"r_v\":\"\"},\"aid\":{\"amazon\":\"1448335\",\"rakuten\":\"1448332\"}}); 5. アドラー心理学5章の「アドラー心理学」も見どころです。「アドラー心理学」は聞きかじった程度だったので、うまく説明ができなかったのですがこの章を読んでようやく腹落ちしました。 アドラー⼼理学は、他者を変えるための⼼理学ではないです。⾃分を変えるための⼼理学です。⼈間関係を改善したいと考える⼈が、周りを変えるのではなく、⾃分⾃⾝の考え⽅を変えればいいんだと気づくことが重要です。 「エンジニアの心を整える技術」71ページより それでは具体的にどうやって変えていけばいいのかということが本章で書かれています。あまり細かいことを書くとネタバレになってしまうので、自分が面白かったと思う節タイトルを抜き出してみました。以下を見て気になった方はぜひ本書を手にとって読んでみてください。自分はこれを読んでかなり心の中のもやもやがスッキリした感じがしました。 5.3.1 エンジニア的劣等コンプレックス 5.3.2 技術マウンティングは劣等コンプレックスの裏返し 5.5.2 ⾃分の課題、他⼈の課題を分ける 5.5.4 他者の期待を満たす必要はない 5.5.5 他者の課題に⼟⾜で踏み込まない 5.6.1 しかってはいけない、ほめてもいけない 5.6.2 評価ではなく、感謝する 5.7 エンジニアの承認欲求を否定する 5.8.1 エンジニアの約束された勝利の剣 5.10.1 ⼼理的安全性 6. 人は本当に変わることができるのか？ただちょっと気になった点もあります。本書では「人は変わることができる」と述べていますが本当にそうでしょうか？ 変えようと思えば、今この瞬間からでも、⼈は変わることができます。 「エンジニアの心を整える技術」73ページより 確かに行動は変えることができます。しかし行動した結果「自分を変えること」ができず、元の行動に戻してしまうこともあると思います。これは単に根性論の問題ではなく「変わりやすい部分」と「変わりにくい部分」があるからだと思います。 「変わりにくい部分」は、幼いころに身に着けた習慣や長いこと続けてきた習慣、長いこと触れてきた環境に対する反応等です。具体的には言語やコミュニケーションや性格、思考のクセなどです。これらは個人のアイデンティティと深く結びついており、考え方や行動を変えただけではなかなか変えることは難しいと思います。 例としては海外で長く暮らしてもその土地の言語が身につかない日本人は大勢いますし、ネイティブの感覚まで持っていける人はかなりの少数派です。そしてどんなに長く海外で暮らしても日本人としてのアイデンティティを捨て去ることは難しいです。もちろん絶対に変えられないわけではありませんが、そのためには「行動」と「環境」を変えた上で「専門家」のカウンセリングが必要です。その上で完全に変わったと確信できるまでには長い時間が必要な場合があり、変わり切る前に元の行動や環境にまた触れてしまった場合には台無しになる可能性もあります。「トラウマ」や「PTSD」も「変わりにくい部分」の例です。 「コミュ障」を克服したなると美談に聞こえるかもしれませんが、全ての人が同じことをして変われる保証がないことは十分に強調されるべきことです。「コミュニケーション」を支える基礎能力の獲得には訓練が必要です。「コミュニケーション」は「視覚」、「聴覚」、「読解力」等を駆使して脳で処理する高度な技術であり、幼い頃にこれらの訓練が十分でなかった場合には生涯に渡って身につかない可能性もあります。「目」が物理的に悪くなくても「耳」が物理的に悪くなくても、脳に処理回路がない場合にはコミュニケーションに必要な情報を引き出すことはできません。繰り返しますがコミュニケーション能力は高度な脳の処理であり、コミュニケーション能力の高さは幼いうちから親や環境からシャワーのようにコミュニケーションの訓練を「知らずの内に」受けてきた結果です。 そして「コミュニケーション」の基礎能力の訓練不足は、極端な例を持ち出さなくても一般家庭でも程度の差はあれ普通に起こり得ることであり、子供の頃に訓練してこなかった能力が大人になったら自然と身につくと考えるのは完全な誤解です。「コミュ障」を克服した人というのはコミュニケーションの基礎能力がある程度高く(幼少期の環境に恵まれていた)、行動や考え方を変えるだけ、もしくは個人的な努力の範囲内でなんとかなった一部の人だと考えるのが妥当だと思います。 私自身の主張としては自分の「変わりやすい部分」と「変わりにくい部分」を見極めて、「変わりやすい部分」で自分が気に入らない部分をまず変えるべきだと思います。その見極めのためにまず「行動を変えてみる」はありだと思います。そして、「変わりにくい部分」で自分が変えたいと思う部分があった場合はどうすればよいかというと、それは投資対効果で判断します。具体的には「行動」、「環境」、「専門家」を揃えた上で変わるために必要な訓練期間を想定して、かかる費用を算出してみます。そしてその費用を投資と見做して自分の人生の中で回収できるかを判断します2。ただ大抵の場合は「変わりにくい部分」を無理やり変えようとせず、「変えずにうまく付き合う」という選択肢を増やしたほうが幸せになれる気がしています。 7. 「エンジニアの心を整える技術」を読み始める前の事前準備さて、ちょっと水をさしてしまいましたが、本書は個人的には超オススメなのでぜひ多くの方に読んで頂きたいです。ただその前に事前準備を忘れないようにしてください。それは「SHIROBAKO」というアニメを見ることです。 TVアニメ「SHIROBAKO」公式サイト記事の説明 これを見なくして本書を十分に味わうことはできません。SHIROBAKOには様々な名言やパワーワードが散りばめられていますが本書ではそれが多く引用されており、より実感を深めるのを手伝ってくれます。特に本書の最後に差し込まれた「あの画像」が明確なメッセージ性と熱量を伝えていて、涙しました。そして気づいたら再度SHIROBAKO全24話を徹夜で見直していました・・・ そういえば劇場版の制作も発表されました。今から待ち遠しくてたまりません。 8. まとめ本書を読んでみて意外と「技術書」だったなというのが読後の感想です。単なる体験談や自己啓発書とは一味違い、とても面白く読めました。ただ「技術書」にカテゴライズした場合に少し残念なのは、4章と5章には批判的な内容や注意事項がなかったことです。一般的にはどんなに優れた技術にも「長所」と「短所」があり、また適用範囲や副作用に対する注意事項や制限事項があるものですが、本書には「マインドフルネス」や「アドラー心理学」の良いところしか書いていないように見えたので少しフェアではないなと感じました3。以下まとめです。 本書はプロジェクトの炎上案件、IT業界のブラックな場面の紹介があり、業界経験の浅い人はぜひ読んでほしい 本書は「マインドフルネス」について書かれており、学術的な裏付けのある「瞑想」の効果の説明とそれを実践するための「技術」が述べられてる 本書は「アドラー心理学」について書かれており、自分を変えるための考え方や行動について書かれている しかし、「人は本当に変わることはできるのか？」という点で自分は疑問を持っている 「変わりやすい部分」と「変わりにくい部分」があると考えている 本書を読む前に「SHIROBAKO」を見るべき。これを見ずして筆者が伝えようとしたかったことを正しく受け取るのは難しい ここまでお読み頂き本当にありがとうございました。本書は本当におすすめです。2章までは無料で読めますので、まずは試し読みしてみてください。 「エンジニアの心を整える技術」をnoteで2章まで無料公開します! #感想まとめ #技術書典6｜karamage@「エンジニアの心を整える技術」好評発売中！｜note このnoteは、2019年4月14日に開催された「技術書典6」で頒布し、これまで600部以上(書籍＋PDF版)販売している「エンジニアの心を整える技術 - 誰でも実践できる心のリファクタリング術 - 」のPDF版のダウンロードページになります。 技術書典6での当日の販売の… 1.私見です。自分の観測範囲の大体はそんな感じですが、観測範囲が偏っていることを否定しません。 ↩2.「変わりにくい部分」を無理に自分の行動や考え方だけで変えようとすると最終的にはメンタルに来るので十分注意して判断してください。「行動」、「環境」、「専門家」を「必要な期間」確保できない場合は「無理をせず妥協する」が最も合理的な判断です。 ↩3.単なる自己啓発書として見ればよくある内容ですが、エンジニアとして「技術書」として本書を見た場合には少し評価が落ちるという意味です。本書に対する注意点のひとつはこの記事の「人は本当に変わることはできるのか？」に書いたとおりです。さらに言えば「マインドフルネス」や「アドラー心理学」が他の自己啓発手法と比べてどのようなメリット・デメリットがあるのかを解説していれば、本書はより素晴らしいものになったと思います。 ↩ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/cats-cats-cats/2019/05/11/mindfulness/"},{"title":"HexoのoEmbedプラグインをnpmに公開した話(後編)","text":"HexoにYouTubeなどのサイトを記事に埋め込むためのプラグインを作成して、npmに公開しました。この記事はその後編にあたります。前編は以下になります。 HexoのoEmbedプラグインをnpmに公開した話(前編) 目次1. Hexoタグの制作1.1. 完成形をイメージする1.2. モデルを探す1.3. 一番簡単なタグを作ってみる1.4. プラグイン化してみる1.5. ソースコードをGit管理してみる1.6. oEmbedを利用したタグを作ってみる1.7. 答え合わせ2. Hexoタグの公開2.1. GitHubでリポジトリを作成する2.2. README.mdを書く2.3. package.jsonを書く2.4. GitHubに公開する2.5. npmに公開する2.6. READMEにバッジをつける2.7. Hexo本家のプラグイン一覧に載せてもらう2.8. ブログやツイッター等で告知する3. hexo-oembedの今後4. まとめ 1. Hexoタグの制作前回はコンテンツ埋め込みのための業界標準であるoEmbedの説明まで行いました。今回はいよいよoEmbedを利用したHexoタグの制作と公開を行います。ここからはこれから実際にHexoタグを作ってみたい方や、OSS貢献に興味がある方向けに丁寧に書いてみたいと思います。 1.1. 完成形をイメージする制作を始める前に完成形をイメージします。今回Hexoのタグ名はoembedにして、後ろにパーマリンクを渡せるものとします。パーマリンクがスライドの場合、oEmbedのレスポンスとしてはtypeがrichのものが帰ってくるので、パラメータのhtmlの値をそのまま表示すればよいだけです。大抵の場合htmlの中身はiframeタグになっています。あとは外側をdivタグで囲ってクラスを指定しておきます。こうすることで後で簡単にスタイルを適用できるようになります。outerとinnerで二重に囲っているのは要素をセンタリングしたい場合にinnerクラスが指定してあったほうが便利だからです。最初はouterだけだったのですが、htmlパラメータで返ってくるのがiframeかどうか保証はできないので念の為囲うことにしました。 Hexo タグ1{% oembed http://slide.com/slides/123456 %} 実際に展開されるHTML12345 iframe> div>div> もう一つ例を見てみましょう。今度は写真の場合です。写真の場合はoEmbedのtypeがphotoになるので自分でタグを生成します。といっても、aタグとimgタグを入れ子にするだけの単純なものです。aタグで囲うのは写真をクリックした際にもとのパーマリンク先に飛べるようにするためです。あとはoEmbedにtitleパラメータがあればimgのalt属性に指定するようにしておきます。あと、oEmbedの仕様ではオプションでmaxwidthとmaxheightを渡せるので、これもHexoタグにオプションとして渡せるようにします。以下の例ではmaxwidthに300、maxheightに400を指定しています。 Hexoタグ1{ oembed http://phote.com/photos/456789 300 400 %} 実際に展開されるHTML12345 a>div> 1.2. モデルを探すある程度仕様がイメージできたら、次はパクリ元リスペクト元を探してきます。ライセンスには十分注意しましょう。公式のサンプルを参考にしたり一般的な構成を真似るくらいであれば特に言及はいらないと思いますが、ソースコードを流用する場合はライセンスに則って処理してください。ソースの流用がなくても独創的な機能を真似る場合は、READMEに謝辞を述べるのが礼儀だと思います。今回は以下を参考にさせて頂きました。 Hexo公式のタグプラグイン 公式のタグプラグインです。本体に取り込まれているためプラグインとしての参考にはなりませんでしたが、タグの作り方の参考にしました linkPreviewプラグイン 本ブログでもお世話になっているタグです。構成の参考にしました hexo-tag-oembed 前編で紹介したoEmbed対応タグです。 今回作ろうとしているタグはこれのパワーアップ版みたいなものです ソースコードの流用はしていませんが、構成の参考にしました node-oembed ライブラリとして利用させて頂きました Discoveryに対応しています 1.3. 一番簡単なタグを作ってみる公式のドキュメントを参考に一番簡単なタグを作ってみます。以下は単なるhogeと表示するだけのタグです。hoge.jsというファイルに保存して[hexo dir]/themes/scripts配下に配置します。hoge.js123hexo.extend.tag.register('hoge', function(){ return 'hoge';}); 配置ができたらHexoサーバを再起動して、ブログの記事でhogeタグを使ってみましょう。レンダリングした投稿に「hoge」と表示されていて、HTMLが以下のようになっていれば、成功です。HTMLはChromeのデベロッパーツール等で確認してください。 Hexo タグ1{% hoge %} 実際に展開されるHTML1hogespan> 1.4. プラグイン化してみるHexoはプラグイン機能を持っています。プラグイン化するとソースコードを外出しできて、npmでインストールすることができるようになります。npmで公開するための必須の手順ですが、単に外出しできるだけでもGitによるソース管理が行いやすくなるので、早めにやったほうがいいと思われます。プラグイン化の方法は 公式に書いてあるとおり、驚くほど簡単です。適当なディレクトリ(hexo-hoge-plugin)を作って、メインのソースファイルであるindex.jsとnpmのメタファイルであるpackage.jsonを配置するだけです。 index.js123hexo.extend.tag.register('hoge', function(){ return 'hoge';}); package.json12345{ \"name\": \"hexo-hoge-plugin\", \"version\": \"0.0.1\", \"main\": \"index\"} さっそく作成したパッケージをnpmでインストールしてみましょう。 1$ npm install --save Hexoサーバを再起動してhogeタグが利用できれば成功です。このとき前節で作成したhoge.jsファイルをscriptsディレクトリから削除しておくことを忘れないでください(笑)。npmは一般的にはネット上のnpmリポジトリからダウンロードしてインストールしますが、このようにローカルのパスを指定してインストールすることも可能です。このときインストール先のnode_modules配下にはパッケージディレクトリへのシンボリックリンクが張られるだけなので、一度インストールをすればパッケージディレクトリのファイルを修正が同期します。したがって更新のたびにインストールするとかは必要ないです1。 1.5. ソースコードをGit管理してみるGitにおけるファイル管理は非常に心強いです。こまめにコミットしておくことで至福の安心感が得られます。特に新しいモノを作ろうとしているときは試行錯誤の連続なのでバージョン管理があるとないとでは効率で大きな差がつくのでなるべく早い段階でGit管理に以降するようにしましょう。以下はおまじないのようなものです。反射的に打てるようになるまで写経しましょう(笑)。ちなみに公開予定のリポジトリのコミットログは英語だけで書くことをオススメします。拙くても日本語で書かれるよりはより多くの人に理解してもらえます2。 123456$ cd # 管理対象のソースコードの一番上のディレクトリに移動$ git init # Gitのレポジトリとして初期化$ echo node_modules > .gitignore # .gitignoreにnode_modules配下を無視するように記述$ git add . # カレントディレクトリ配下のファイルをステージング$ git status # 余計なファイルが入っていないか確認$ git commit -m \"initial commit\" # メッセージ付きでコミット 1.6. oEmbedを利用したタグを作ってみるさて、いよいよoEmbedを利用したタグ作りに取り掛かります。まず、oEmbedのプロトコルをどのように実装するかです。HTTPクライアントを使って素直に実装する手もありますが、Discoveryも含めるとちょっと面倒なので公開されているパッケージの中に良いものがないか探してみたところ、node-oembedパッケージがありました。これを使えば比較的ラクにoEmbedを実装できそうです。 oembedoEmbed consumer library and tools あともう一つ決めなければいけないことは、エンドポイントの設定方法です。幸いにもHexoにはディレクトリのトップに_config.ymlという設定ファイルがあり、これに自由に設定を加えていけます。具体的には以下のような設定があったとします。classNameは冒頭で述べたCSSのクラス名の設定です。endpointsが具体的のoEmbedプロバイダを設定する箇所で、matchパラメータがパーマリンクのURLのホスト名に部分一致していたらそのエンドポイントのurlを利用するという仕様にします。正確なスキーマの検査をしなくても多分このレベルで実用になるだろうと判断しました。手を抜いたわけじゃないよ！ _config.yml123456789101112oembed: className: oembed endpoints: instagram: match: instagram url: http://api.instagram.com/oembed/ gyazo: match: gyazo url: https://api.gyazo.com/api/oembed/ flickr: match: flickr url: http://www.flickr.com/services/oembed/ 上記の設定ファイルにはhexo.configでアクセスできます。例えばインスタグラムのエンドポイントのURLが欲しい場合はhexo.config.oembed.endpoints.instagram.urlです。これで、oEmbedのタグを実装する上での主要な情報と仕様が出揃いました。あとは基本的はWebプログラミングの知識があれば解ける問題です。Let’s Try! 1.7. 答え合わせさて、皆様の出来栄えはいかがしょうか？以下のCodePenに自分のソースコードを日本語のコメント付きで載せたので参考にしてみてください。 See the Pen hexo-oembed by hinastory (@hinastory) on CodePen. 2. Hexoタグの公開せっかく作ったので公開して多くの人に使ってもらいたいと思います。そのための手順を簡単に説明したいと思います。 2.1. GitHubでリポジトリを作成するまずは、 GitHubにリポジトリを作成します。もしまだアカウントを作成していない方はSignUpから始めてください3。以前に以下の記事でプライベートリポジトリの作り方を説明しましたが、今回は公開用のパブリックリポジトリです。 GitHubのプライベートリポジトリに移行した話新年そうそうビッグニュースが流れてきました。GitHubがプライベートリポジトリをタダで使わせてくれるってよ! GitHub、無料ユーザーもプライベートリポジトリを使い放題にGitHubが、無料ユーザーもプライベートリポジトリを無制限に使えるようにした（共有は3人まで）。料金体系… リポジトリ名はダイレクトにhexo-oembedにしました。ライセンスは特にこだわりがなければHexoと同じMITライセンスにしておけばいいと思います。.gitignoreファイルはもうすでに作成済みなのでここであえて作成する必要はないです。リポジトリの作成自体は十秒もかからず終わります。以下が今回作成したGitHubのリポジトリです。 hinastory/hexo-oembedembed oEmbed item on your Hexo article. Contribute to hinastory/hexo-oembed development by creating an account on GitHub. リポジトリの作成が終わったらローカルのリポジトリとGitHubのリポジトリをリンクさせます。 1$ git remote set-url origin {new url} 2.2. README.mdを書くREADME.mdは公開したパッケージの説明や利用法をMarkdownで書くファイルです。リポジトリのトップにこのファイルを置いておけばGitHubのリポジトリのトップページに表示してくれるので、公開時にはほぼ必須のファイルです。書き方も大体以下のようにリポジトリ名->リポジトリの簡単な説明 -> 特徴 -> インストール方法 -> 利用方法 -> 設定(あれば) -> 謝辞(利用or参考にしたものがあれば) -> ライセンスの順に書いていけばOKです。 12345678910111213141516171819202122232425262728# hexo-oembedEmbed [oEmbed](https://oembed.com/) item on your [Hexo](https://hexo.io/) article.Features--------- Supports A- Supports B## Installation`npm install hexo-oembed --save`## Usage・・・## Configuration...## Thanks## LicenseMIT 実はここが今回一番苦労したところです。oEmbedはともかくoEmbed Discoveryとかエンドポイントの設定方法とか説明しなければいけない部分がそこそこあるので、どうしたものかと悩みました。特に英語が苦手なのでGoogle先生のお力も拝借したのですがイマイチ自信がありません・・・ 2.3. package.jsonを書くすでにnpmでインストールするために最低限のpackage.jsonは記述していると思いますが、npmに公開するためにはさらに追加の記述が必要です。以下がほぼ最低限の公開用package.jsonです。特に気をつけなければ行けないのはバージョン番号です。セマンティック バージョニングになるべく厳密に従うようにしてください。あと、ファーストバージョンは1未満のバージョンから初めるのが慣例です。ある程度成熟したと感じたときにバージョン1をリリースしてください。 12345678910111213141516171819202122{ \"name\": \"hexo-oembed\", \"version\": \"0.1.5\", \"description\": \"embed oEmbed item on your Hexo article.\", \"main\": \"index.js\", \"repository\": { \"type\": \"git\", \"url\": \"git@github.com:hinastory/hexo-oembed.git\" }, \"bugs\": { \"url\": \"https://github.com/hinastory/hexo-oembed/issues\" }, \"keywords\": [ \"hexo\", \"blog\",\"plugin\",\"helper\",\"tag\",\"oembed\",\"youtube\",\"slideshare\",\"speakerdeck\",\"twitter\",\"vimeo\",\"codepen\",\"pixiv\",\"instagram\",\"flickr\",\"gyazo\" ], \"author\": \"hinastory\", \"license\": \"MIT\", \"dependencies\": { \"hexo-util\": \"^0.6.3\", \"oembed\": \"^0.1.2\" }} あと、お気づきだと思いますがキーワード盛り盛りですね(笑)。ここのキーワードはnpmの検索時に参照されるので、嘘偽りがなければできるだけ多く記載したほうが良いです。特に今回のhexo-oembedみたいにパッケージ名だけだと具体的に何をするものか分からない場合はkeywordに力を入れましょう。 2.4. GitHubに公開するGitHubに公開するのは簡単です。git pushするだけです。簡単なんですが、以下のコマンドを打った瞬間に全世界に公開されしまうのでgit diffやgit showで余計なファイルやコミットがないか再確認してからpushしましょう。一番ありがちなのは必要なファイルをgit addし忘れてpushすることです。他にもプライベートアクセスキーとか重要な情報も一緒にコミットしてしまったりとかあります。もし間違ったコミットをしてしまった場合は、早い段階であればforce pushでもみ消せますがマナーとしては最低ですので最後の手段としましょう。 1$ git push origin master ブランチをプッシュしたら忘れずにタグもプッシュしておきましょう。GitHubの場合タグのプッシュが新バージョンのリリースとみなされるので、リリース直前には必ずタグを打つようにします。 12$ git tag v0.1.5$ git push origin v0.1.5 2.5. npmに公開するnpmに公開するのはもっと簡単です。公開するパッケージ直下でnpm publishを打つだけです。npmのアカウントを持っていなければ作成する必要がありますが、GitHubのアカウントでログインできるので手間はそれほどかかりません。アバターの設定にはGravatarが利用できます。これも持っていなければWordPress.comにログインしてすぐに作ることができます。 npm publishに成功したらnpmからページを確認してみます。自分のアバターのメニューのPackagesからも確認できますし、パッケージ名やキーワードで検索をかければ出てきます。 hexo-oembedembed oEmbed item on your Hexo article. ページの確認ができたらnpm installしてパッケージがネットからインストールできるか試してみましょう。このときローカルバージョンをインストールしている場合は一旦npm uninstallしてから実行してください。 2.6. READMEにバッジをつけるGitHubのリポジトリを眺めているとREADME.mdにイカすバッジが着いているのを見かけることがあります。や みたいな奴です。 これらのバッジはカッコいいだけでなく、必要な情報が視覚的にわかりやすいという実用面も大きいのでぜひ貼りましょう。まず一番目に紹介するのはnpmパッケージをかっこよく表示してくれる NodeICOです。ドメイン名にこだわりが感じられます(笑)。npmのパッケージ名を指定するだけですぐに作ってくれるので張らない手はないです。 次に紹介したいのは Shields.ioです。Shields.ioではOSS向けに高いクオリティのバッジを提供しています。種類も豊富でカスタマイズも可能なので、大抵の用途のバッジはここで作成することができます。上記のlicenseのバッジはここで作成しました。 最後に紹介したいのはCode Climiteです。ここはGitHubのリポジトリからOSSの品質を測定するサービスを提供しています。そしてその結果はバッジとして表示可能になっています。上記のこのバッジはCode Climiteを利用しています。hexo-oembedのページには、測定結果の詳細が載っているのでパッケージの改善に役立てる事ができます。 2.7. Hexo本家のプラグイン一覧に載せてもらうようやく公開の最終工程の一歩手前です。実は拡張の公開は以下のとおり大きく分けて4段階あって、今までおこなったのは2段階目までです。3番目は見逃されがちですが利用者の観点からすれば非常に重要です。ここに載せてもらえるか否かでリーチできるターゲット規模が大きく変わるので手を抜かずにやり遂げましょう。 パブリックソースリポジトリに公開する GitHub, GitLab, Bitbucket, Mercurial・・・ パブリックパッケージリポジトリに公開する npm, RubyGems, PyPI CPAN, MvnRepository, NuGet, OS系パッケージ管理システム・・・ 公式の拡張リストに記載してもらう ブログやツイッター等で告知する とはいっても、気負う必要はまったくありません。最近は公式のサイト自体GitHubで管理でしているところが増えてきているので、ドキュメントを修正してプルリクエストを投げるだけです。バグ修正のプルリクエストと変わらないというかむしろそれより敷居は低いといっても過言ではありません。さらにHexoの場合には公式サイト自体がHexoで構築されているため、ドキュメントの修正確認に新しい知識は不要です。具体的には公式の手順を確認してもらう必要がありますが、たった5ステップで通常のバグ修正とほぼ変わりないことがわかると思います。 注意点としては、プルリクエストには各リポジトリにマナーがあるのでコントリビューションガイドにはよく目をとおすことと、過去のクローズ済みのプルリクエストを確認して自分のプルリクエストに問題ないか確認することを忘れないようにしましょう。マナー違反のプルリクは優しく注意してくれる場合もありますが、問題が多ければ放置や強制クローズもありえます。ちなみに今回のプルリクは半日程度でマージしてもらえました4。 マージしてもらったら公式のプラグイン一覧でoembedで検索して、問題なく掲載されているか確認します。自分の1件しか引っかからなかったので、どうやらhexo-tag-oembedの方は公式への登録を行っていなかったみたいです。もったいない・・・ 2.8. ブログやツイッター等で告知するまさしくこの記事です・・・ 3. hexo-oembedの今後npmパッケージとしては結構ニッチかなと思っていましたが、公開から一週間も経たないうちにダウンロード数が200を超えたので意外とニーズはあったみたいです。ということでしっかり開発およびメンテナンスはしていきたいと思います。 まず開発の基本方針として、サイト固有の対応を入れるつもりはないです。それやりだすとキリがないので・・・実はjquery-oembed-allというライブラリも見つけていたのですが、更新が止まっていたし自分がこのようなものを作ろうと思ってもメンテナンスが辛そうなので正直やりたくありません。しかもこのライブラリのフォールバック先のYQL (Yahoo! Query Language)は2019/1/3で終了したみたいです。 ただちょっと面白いなと思ったのはフォールバック先にOpen Graph protocolがあることです。OGP対応は割とメジャーなSEO対策でリンク先のサムネイルや説明の表示でお馴染みだとおもいます。もちろんこのページもOGPには対応しています。hexo-oembedのフォールバック先として一応Embed.lyには対応していますが5、OGPへのフォールバックは今後検討しようかと思います。 もちろんプルリクは大歓迎です。またバグ報告、ご意見・ご要望はGitHubのIssuesにお願いします6。 4. まとめ既存のOSSへの貢献としてメジャーなのはバグ報告したりプルリクを出したりすることだと思いますが、プラグインを作って公開して公式の載せてもらうまでを丁寧に解説した入門記事は意外と少ないと感じました。断片的な記事は多いのですが、それだとどういう流れなのか入門者にわかりづらいかなと思い、本記事ではhexo-oembedをテーマにOSSへの貢献への流れを要点を絞って解説するようにしました。 実際に既存のOSSへの貢献を始めるには、いきなり本体に手をだすよりもプラグインから手をだした方がうまくいく場合が多いです7。プラグインを通して本体を見たほうが理解しやすいですし、プラグインを作ってる最中に本体のバグを見つけることも多いので本体へのプルリクを書く動機にもなります(笑)。そのうちプルリクを送り続けていれば本体側にも十分詳しくなってコラボレーターとして招待されるかもしれません。実際にプラグインから始めてそのOSSへのメンテナーになった人は数多くいるので、まずOSSに貢献してみたいと思ったら気に入ったOSSを見つけてプラグイン機能を探して、実際に作ってみることをオススメします。 最初はHexoタグの作り方を簡単に紹介する記事にする予定でしたが、もしかしたら既存のOSSへの貢献の入門記事としてもニーズがあるのではないかと思ったのが今回の記事を書こうと思った動機です。長くなってしまいましたが本当にここまで読んで頂いてありがとうございました。この記事が読んでくれた方のOSS貢献の一助となれば幸いです。 1.ちなみにnpm linkというコマンドもあってこちらはさらに便利で、複数の非公開パッケージを開発するときに真価を発揮します。興味がある方はぜひ調べてみることをオススメします。 ↩2.自分も頑張れば読めはしますが、書くのは苦手です・・・ 話すのはもっと無理です・・・ ↩3.認証周りの設定とかいろいろ面倒くさいのでそこそこ時間ががかかると思います・・・この記事の余白に書くのは狭すぎるのでGoogle先生のお力をお借りください・・・・ ↩4.このプルリクです。 ↩5.一応利用しているライブラリ(node-oembed)が対応していたので、対応コードは入れてみたけど実際に動かしてはいないです・・・ ↩6.コントリビューションガイドはまだ用意していませんが、いずれ突っ込む予定です・・・ ↩7.プラグインで実装できるものを本体側を修正してプルリク送るとメンテナーに嫌がられることが多いです。それはメンテナーは単に機能を見ればよいのではなく、全体との整合性や今後の開発の障害にならないか等、取り込みの判断に非常に多くの労力を割かなければいけないからです。従ってプラグインでできることはプラグインで実装したほうがよいです。そしてどうにもならない部分だけ最小限に絞って、なるべく汎用的で、互換性に影響ないような形で本体側にプルリクを投げるとうまくいく確率が高まります。 ↩ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/cats-cats-cats/2019/02/11/hexo-oembed-2/"},{"title":"ScalaMatsuri 2019に参加してきました","text":"ScalaMatsuri 2019に参加してきました。毎年何気に楽しみにしているお祭りです。今年も面白い発表がたくさんあり、お祭り気分も充分に味わえたので満足の行くカンファレンスでした。 ScalaMatsuri 2019｜日本最大級の Scala カンファレンスScala をテーマに日本最大級のカンファレンスが開催されます。 目次1. ScalaMatsuriとは2. 会場について2.1. 行動規範3. カンファレンスDAY3.1. Scala 3って、私にはどんな影響があるの? @joang38 (Joan Goyeau)3.2. 再帰:スキーム,代数,finally tagless,データ型. 統合されたビジョン @alexknvl (Alexander Konovalov)3.3. プロジェクトで引き回す型をEffにするメリット @wing_007 (ma2k8)3.4. こんなに違う！ @kaelaela (前川裕一)3.5. DOT計算をやさしく説明する @kmizu (水島宏太)3.6. Making Logic Monad @halcat0x15a (ねこはる)3.7. sbt コア・コンセプト @eed3si9n (Eugene Yokota)3.8. 継続とDI @gakuzzzz (中村学 (がくぞ）)4. アンカンファレンスDAY5. 聞きたかったけど聞けなかったセッションたち6. 食事7. カフェスペース8. まとめ9. 戦利品 1. ScalaMatsuriとはプログラミング言語Scalaをテーマにした日本最大級のカンファレンスです。今年は「Scala Conference in Japan 2013」から数えて６回目の開催になります。ScalaMatsuriの特色としてはセッションの決定がチケット購入者の投票によって決まること、海外スピーカの招待に力を入れておりセッションに日英同時通訳が入っていること、アンカンファレンスがあることなどが挙げられます。また、その名の通り「お祭り」の雰囲気を出すための工夫が随所に見られ、非常に親しみやすいカンファレンスとなっています。 2. 会場について 日時と場所は以下のとおりです。自分は6/28のカンファレンスから参加しました1。場所はお台場です。ビッグサイトの近くと言ったほうが分かる人にはわかるかもしれません（笑）。新橋からゆりかもめに乗って行ったのですが、東京国際クルーズターミナル駅と言う聞き慣れないアナウンスが流れて来て仰天しました。どうやら最寄り駅の駅名が変わっていたみたいです・・・2 日時 6/27(木) - 6/29(土) 10:00〜 場所 東京国際交流館 2.1. 行動規範到着したのは10:00頃で、ちょうど行動規範3のアニメが流れているときでした。このアニメは毎年クマくんのところで笑ってしまいます。アニメが流れ終わったところで、次のオススメ動画に子供向け動画（３匹の子豚？）が出てきて会場が爆笑していました。 3. カンファレンスDAYScalaMatsuriは27日(金)がカンファレンスDAYでした。ScalaMatsuriで凄いと思うのは３本のセッションが並行して走っていてそのうち２つの部屋では同時通訳が行われていたことです。そのため翻訳レシーバを借りれば英語のセッションでも問題なく楽しめました。4。 以下が27日に自分が聴講したセッション一覧です。ちょっとこじらせているので関数型プログラミングに偏っています（笑）。 Scala 3って、私にはどんな影響があるの? @joang38 (Joan Goyeau) 再帰:スキーム,代数,finally tagless,データ型. 統合されたビジョン @alexknvl (Alexander Konovalov) プロジェクトで引き回す型をEffにするメリット @wing_007 (ma2k8) こんなに違う！ @_kaelaela (前川裕一) DOT計算をやさしく説明する @kmizu (水島宏太) Making Logic Monad @halcat0x15a (ねこはる) sbt コア・コンセプト @eed3si9n (Eugene Yokota) 継続とDI @gakuzzzz (中村学（がくぞ）) ここからは少し長くなりますがセッションの感想を一つずつ述べていきます。 3.1. Scala 3って、私にはどんな影響があるの? @joang38 (Joan Goyeau)Scala3(Dotty)の影響についての発表でした。以下が言及があった機能一覧です5。概ね知っていましたが、いくつか新しい発見もあったので有意義なセッションでした。 Enumerations, Algebraic Data Types やっとScalaにまともなEnumurationが来るといった話です。今まではcase objectで書いていたものがenumキーワードで大分シンプルに書けるようになります6。 交差型, 合併型 ようやくTypeScriptでできた型表現がScalaでもできるようになりました 交差型に関してはwithもあったけど交換可能でなかったので、ようやく本物がDottyにも入ったということです NULLは100万ドルの間違い たぶん#5747の話だったと思います 現在でもOptionがありヌルポを見る機会はあまりありませんが、将来的には本当に見る機会がなくなるかもしれません Opaque 型エイリアス AnyValは、いけてないよねという話7。opaqueで本物の型エイリアス（いわゆるゼロコスト抽象化）が手に入ります 拡張メソッド 型が定義された後にメソッドを追加できる機能 拡張メソッドの構文はすごいGo言語チックだと思いました8 デリゲート 今までの型クラスのためのハックがまともな構文として定義されましたというお話 マルチバーサル等価性 トレイトパラメータ givenが使えるのは大きいです Parameter Untupling mapでcaseのあのパターンがいらなくなるお話。これは地味に便利 TASTy コンパイル時の成果物の新しいフォーマットです クロスコンパイルが容易になります 上記の機能のいくつかはこのブログでも言及しているので参考にしてください。 Scala3に入るかもしれないContextual Abstractionsを味見してみた(更新・追記あり)Scala3のリサーチコンパイラであるDottyにImplicitsに代わる「Contextual Abstractions」と呼ばれる一連の機能が実装されていたので一部を味見してみました。 (2019年3月10日追記・更新: 追記内容はここを見てください) (2019年6月22… 3.2. 再帰:スキーム,代数,finally tagless,データ型. 統合されたビジョン @alexknvl (Alexander Konovalov)ScalaMatsuriでは例年話される関数型プログラミングネタです。最初の方はずっと同型（Isomorphism）について話していたので、どこに向かうのかよく分かりませんでしたが終わってみれば関数型プログラミングの流行りのテクニックの総集編みたいな内容でした。結論は以下のような感じです。 1folds(畳み込み) ≈ 再帰スキーム ≈ Final Tagless ≈ Free 「folds(畳み込み) ≈ 再帰スキーム」と「Final Tagless ≈ Free」は予想は付いていましたが全てが同型だとは思っていませんでした。まぁ「代数」というくくりで見ると確かに同じ気がします。 3.3. プロジェクトで引き回す型をEffにするメリット @wing_007 (ma2k8)この話も毎年恒例になってきたEff(Extensible Effects)のお話です。Effを簡単に説明するとモナドの合成と評価を柔軟に行うためのテクニックです。 上記スライドでEffと対比されていた型は以下です。 Future[A] Future[Try[A]] Future[E Either A] EitherT[Future, E, A] Eff[R,A] この中で自分がよく使うのは1です。2,3,4は使ったことはありますが型合わせが面倒なので部分的にしか使ったことはないです。5はEffそのものですが写経したくらいで実践で使ったことはありません。いずれ使って見たいと思いますが、問題はチーム全員が使いこなせるかどうかですね・・・ 3.4. こんなに違う！ @kaelaela (前川裕一)ScalaをコンパイルするとシンプルでKotlinをデコンパイルすると複雑だというのが面白かったです。あと似ている型も注意が必要そうです。デコンパイルしよう。 3.5. DOT計算をやさしく説明する @kmizu (水島宏太) スライド kmizuさん9によるScala3の理論基盤であるDOT計算のお話です。現実のプログラミング言語を厳密に理論基盤に載せるのは難しいので、妥当な言語のサブセットを作ってモデル化したものを「核計算」というらしいです。DOTはScala3の核計算であり、健全性が厳密に証明されているようです。残念ながらDOT計算の詳細は時間がなかったので翌日のアンカンファレンスに持ち越されました。 3.6. Making Logic Monad @halcat0x15a (ねこはる)論理プログラミング言語としてはPrologが有名ですが、その一部の機能をScalaで実現しようというものでした。自分は論理プログラミングはあまり知らなかったのですが、論理的に可能な組み合わせが全て解として求めることができるというのは面白いと思いました。 Making Logic Monad from Sanshiro Yoshida 具体的なモナドの構成はスライドを見たほうがいいと思いますが、印象に残ったパワーワードは以下の２つです。 バックトラッキングはモナドプラス FizzBuzzは実践的アプリケーション あとはType-aligned sequenceというデータ構造も知らなかったので後で調べて見ようと思います。 3.7. sbt コア・コンセプト @eed3si9n (Eugene Yokota)scalaで最もよく使われているビルドツールであるsbtの解説でした。いつもお世話になっているsbtですが、いつもなんとなくというかその場しのぎで調べて動かしていたので、いろいろと勉強になりました。内容はおそらく6/11-23に開催されていた Scala Days 2019で発表されたものと同じではないかと思います。 Player is loading…以下はメモです。 空でも動く 流れを堰き止めるのがcommand commandよりtaskがオススメ キーは4次元 デリゲーションルール Zero キーは最も広いスコープで定義して、最も狭いスコープで参照 3.8. 継続とDI @gakuzzzz (中村学 (がくぞ）) スライド 継続渡しスタイル(Continuation Passing Style/CPS)とDI(Dependency Injection)を比較する非常に興味深いセッションでした。自分の継続のイメージはSchemeから来ていてどちらかと言うとgotoと比較されるプリミティブだったのですが10、確かに言われて見ればDIだなと納得しました。あとSchemeでCPSを使うとネストが深くなりますが継続モナドを使うとネストを潰せてDSLっぽくなるのも面白かったです。CPSとDIのどちらを使うべきかという問いに対しては、使い分けが必要でCPSはアドホックな場面で使いましょうということでした。個人的に気になった点は似たような使い方ができるリーダーモナドやMinimal Cake PatternやEffなどと比較した場合はどうなんだろうということでした。また時間があったら自分で考察してみたいと思います。そういえば大昔にScala本体にも継続が実装されていていつの間にか標準から切り離されていたけど今も息をしているのだろうか・・・ 4. アンカンファレンスDAYアンカンファレンスはカンファレンスのカウンターパートです。つまり、カンファレンスほど形式張らずにアドホックにセッションを決定しようという比較的軽いノリですが、まさしく「お祭り」の雰囲気に相応しいワイワイした感じがとても印象的です。 アンカンファレンスが具体的にどのように進むかというと、前日から用意されたホワイトボードに付箋で聞きたいネタや喋りたいネタを貼って、セッションに参加したいと思ったら赤いシールを貼ります。そして当日の朝会や昼会で投票が多くて発表者やファシリテータがいるものを優先してセッション枠を埋めていきます。上の写真はホワイトボードの様子と昼会でセッション枠を決めている様子です。 以下参加したセッションです。どれも非常に面白かったのですが長くなるのでメモベースの記載になります。 仕事でScalaを使おう - Arm Treasure DataでのAirframe活用事例 @taroleo (Taro L. Saito ) 最近よく聞く Airframeのお話です AirframeはDIコンテナだと思いこんでいましたが、どうやらDIだけではなく様々な便利ツールの集合体のようです MessagePackがTreasure Data発だと初めて知りました。MessagePackを使いたくなったらAirframe logとlauncherは後で試してみよう Bengal: Dotty Cats @ Walter Chang Bengal: A less than minimal functional library in the spirit of cats in Scala 3. Scala Taiwanから来日された方の発表です Scalaで型クラスを使う場合に広く使われているcatsライブラリをScala 3で実装するとどうなるかという発表でした 個人的に面白かったのは shapelessを使って型クラスを導出する部分でした DOT Calculus I didn’t explain yesterday @kmizu (水島宏太) DOTは難しいということが分かりました 特にサブタイプは鬼門だと・・・ DOTは健全らしいです （参考: dot soundness) Fast & Functional 最初の１時間だけ聴講しました パワーワード「制限は開放し、自由は制限する」 WiFi x Scala: Implementing Captive Portal in Scala and deploy into #ScalaMatsuri @ kuro_m88 Captive Portalという仕組みを初めてしり勉強になりました 今回のWifi事情はおそらく他のカンファレンスと比べても非常に良かったと言えるくらい安定して繋がりやすかったです その裏舞台を聞けて非常によかったです Write stacksafe non-tailrec recursions @jooohn1234 再帰 is cool Stack overflowを避けるためにトランポリンを使おうという話 Fujitask meets Extensible Effects @ y-yu Extensible Effectsでトランザクションモナド“Fujitask”を作る - Qiita トランザクションを型レベルの計算に落とせるというのは面白い kits-effを利用している 進捗大陸05にねこはるさんのkits-effの記事があります。自分も前回の技術書典で購入していました From Go To Scala Easy vs Simple 個人的にはアンカンファレンスのなかで一番熱いプロレスでした KotlinやC++やSwiftも参戦してきて、カオスな雰囲気がいい味を出していました Applicative Functor - Selective Functor - Monad Selective Functorという聞き慣れない言葉に誘われて聴講しました なんとなく仕組みはわかりましたが、どういうときに使うものかイマイチわからなかったので後で勉強します・・・ 5. 聞きたかったけど聞けなかったセッションたちあとで見るために資料のリンクだけ載せておきます。 Using Akka Cluster for a payment service Running Scala on AWS Lambda in a Snappy Way 同僚の登壇資料作成をScalaで手伝った話 How we replaced a 10-year-old Perl product using Scala ScalaのOSSに貢献しよう ~ Phil Bagwell Award記念講演 High Performance Scala/high_performance_scala How to build an Event-Sourcing system using Akka with EKS [Running in PRODUCTION Reactive Systems with cloud services ScalaでGANをスクラッチ開発した話@ScalaMatsuri コードで理解するPlayframeworkの脆弱性 Functional Concurrency in Scala 101 悩める開発者に贈る〜 サービスの継続的な成長を支える分析設計手法 Clean Architecture in Practice Intro to typeclass in Scala Scala Driven Management Case of Ad Delivery System is Implemented by Scala and DDD ピュアなドメインを支える技術/pure domain model and the technology behind it How to test proper{t,l}y (Scala Matsuri edition) 6. 食事ScalaMatsuriの魅力には食事もあります。以下の写真は昼食のお弁当です。お弁当はいくつかの種類があってちゃんとベジタリアン向けのお弁当も用意されていました。多分以下は鳥がメインのお弁当だったと思います。 ScalaMaturiで「祭り」の気分が味わえるのは屋台の存在も大きいです。カンファレンスDAYにはたこ焼き屋が出ていて、アンカンファレンスDAYにはかき氷屋が出ていました。 懇親会も盛り上がりました。途中でLTもありました。 左下はアンカンファレンスDAYの朝食で、右下はデプロイされていたうまい棒です。コーヒーとお菓子は豊富に配備されており、セッションの合間に飲んだり食べたりしていました。 7. カフェスペース今年から1階にカフェスペースが設けられていました。カフェスペースの入り口でScalaのシンボルである螺旋階段がお出迎えをしてくれました（笑）。カフェスペースなのでコーヒーやお菓子がデプロイされていましたが、それ以外にもScala関連書籍が置かれており自由に読めるようになっていました。 8. まとめScalaMatsuriは本格的なカンファレンスでありながらその名の通り「お祭り」気分が味わえる素晴らしいカンファレンスです。もっとScalaMatsuriを知りたい方はScalaMatsuri運営ブログやTwitterのハッシュタグ #ScalaMatsuriもチェックしてみてください。 この記事を読んでくれた方に、少しでも\u001cScalaMatsuriの楽しさをお伝えできたなら幸いです。 参加者、関係者の皆様、お疲れ様でした！ 9. 戦利品たくさんの記念品を頂きました。今年も型安全でありますように・・・ 1.6/27はワークショップDAYです。 お絵かきで学ぶScala教室と OSS ハッカソンが開催されていました。OSSハッカソンはよく見たらチューターがガチですね。どんなコントリビュートがされたのか気になります。 ↩2.2019年3月16日に「船の科学館駅」から「東京国際クルーズターミナル駅」に改称したようです。また「東京国際展示場正門駅」も「東京ビッグサイト駅」に変更されています。こちらはまだ分かりやすい気がしますが、東京国際クルーズターミナルの開業は2020年7月ということらしいので、寝耳に水でした。 ↩3.行動規範(Code of Conduct/Universal Access)はカンファレンス参加者が守るべきルールです。内容はハラスメントフリーで参加者全員を尊重しつつ、みんなが気持ちよくカンファレンスを楽しめるようにするための取り決めになっています。行動規範はイベントごとに微妙に違うので事前に目を通しておくことをおすすめします。 ↩4.この同時通訳は日本語->英語だけではなく、英語->日本語も行われています。したがって英語話者に対して日本語で質問ができたりその逆も可能です。RubyKaigiでも同時通訳はありましたが日本語->英語だけだったので、その点ScalaMatsuriの方が英語が苦手な人でも楽しめると思います。またスライドに日本語訳が付いているのも有難かったです。 ↩5.軽くメモしただけなので間違っているかもしれません。Dottyドキュメントのリンクは自分調べて貼りました。 ↩6.Enumerationクラスは本当に使えない子なので見なかったことにしてあげてください。 ↩7.AnyValがなぜいけていないかは SIP-35を参照してください。 ↩8.拡張メソッドの構文は#6760で変わるかもしれません・・・ マージされずにクローズされました。ただまたいつかこの話題が再燃するかもしれません・・・ ↩9.退職エントリが話題になっていました。他にもドワンゴの退職エントリを見かけたので、本気でやばそうですね・・・ ↩10.Schemeでは継続が第一級オブジェクトで、機能名からcall/ccともよく呼ばれています。goto（またはsetjmp/longjmp）と呼ばれる理由は「Scheme/継続の種類と利用例 - Wikibooks」を参照するとよく分かると思います。 ↩ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/cats-cats-cats/2019/07/04/scala-matsuri-2019/"},{"title":"Scalaプログラマが圏論を学ぶためのオススメ文献 - 3選","text":"圏論は数学の一分野です。これを学ぶのには「数学書」を手に取るのが王道なのですが、残念ながらこれは大部分のプログラマに理解できる言葉では書かれていません。「定義・命題・証明」の積み重ねで書かれています1。ここで大半のScalaプログラマは苦い顔をすると思います。もう少し分かりやすいScalaプログラマ向けの圏論入門がないかと探してみると「Haskell」向けの記事が大量に引っかかるでしょう。ここで多くのScalaプログラマは心を折られてしまいます。「圏論」はまだScalaプログラマには早すぎたんだと・・・ 本記事ではそんなあなたに贈る3つの文献をご紹介したいと思います。 目次1. はじめに2. プログラマが圏論を学ぶべき理由3. オンラインで読めるオススメ文献 - 3選3.1. Category Theory for Programmers Scala Edition3.2. Scala with Cats3.3. 猫番4. プログラマが圏論で学んでおいたほうがよい概念5. まとめ6. もっと圏論を学びたい人向けのオンラインで読めるオススメ資料 1. はじめに本記事は圏論に興味があるScalaプログラマを対象にしています。特にプログラマにとって実用的な圏論の知識をScalaを通して身につけたい方にオススメします。 2. プログラマが圏論を学ぶべき理由プログラマが圏論を学ぶべき理由に関しては圏論入門レベルの自分があまり大きなことは言えないので、「Category Theory for Programmers Scala Edition」の序文から３つの文章を引用しようと思います。 First, category theory is a treasure trove of extremely useful programming ideas. Category Theory for Programmers Scala Edition (意訳) 最初に、圏論はめちゃくちゃ役立つプログラミングのアイデアの宝庫です。 I would go as far as to argue that category theory is the kind of math that is particularly well suited for the minds of programmers.That’s because category theory — rather than dealing with particulars — deals with structure. It deals with the kind of structure that makes programs composable. Category Theory for Programmers Scala Edition (意訳) 圏論はプログラマの心理に特に適した数学の分野であるといっても過言ではないと思います。それは圏論が個々の詳細よりもむしろ構造を扱うからです。圏論はプログラムを合成可能にする特定の構造を扱います。 Composition is at the very root of category theory — it’s part of the definition of the category itself. And I will argue strongly that composition is the essence of programming. Category Theory for Programmers Scala Edition (意訳) 合成は圏論の重要な根幹を成しており、圏自体の定義の一部でもあります。そして合成はプログラミングの本質であると、はっきり述べておこうと思います。 3. オンラインで読めるオススメ文献 - 3選本記事は「Scalaプログラマに適した圏論の文献紹介」という趣旨なので、以下の条件に当てはまる文献を３つに絞って紹介したいと思います。 圏論の概念(特にモノイド、関手、モナド)に触れている Scalaで解説がしてある 定理の証明が極力載っていない オンラインで無料で読める 3.1. Category Theory for Programmers Scala Editionまずは前述した「Category Theory for Programmers Scala Edition」を紹介します。 Category Theory for Programmers: The Preface | Bartosz Milewski's Programming Cafe 元のHaskellで書かれたページ Category Theory for Programmers Scala Edition Scalaエディションのダウンロードページ 上記のページから「category-theory-for-programmers-scala.pdf」をダウンロード この本はもともとHaskell(と若干のC++)で書かれていた例に、後でScalaの例を付け加えたものになっています。この本の特徴のひとつは豊富な図解とスニペットです。これは具体的に引用して見てもらった方が早と思います。以下は10章の自然変換で使われている4つの図になります。 番号と赤い矢印は自分が書き足したものです。一般の数学書による自然変換の説明だと最後の4番目の図のしかも右側の可換図式しか描かれていない場合がほとんどだと思います。しかし本書では1番目の図で同じ圏に移す2つの関手FとGが示されて図式が犬と豚に変換されているイメージが描かれています。2番目の図では、自然変換が対象を移すことを示し、3番目の図で対象だけでなく射も移すことを示しています。そして3番目を簡略化したものが4番目の図になることが分かります2。 このように本書では圏論の概念が豊富な図によって解説されています。またソースコードもHaskellとScalaのコードが一緒に載っていて非常にわかりやすいです。以下の引用はListの長さを示すlength関数が自然変換であることの説明に使われているコードです。 length関数は一般的にはList[A] => Intの関数でList関手をIntに変換するものですが、Intを定値関手であるConst[E, A]に埋め込まれたConst[Int, A]と見做すことでlengthを関手間の変換、つまり自然変換になることを示しています。本書では関手間のパラメトリックな多相関数は常に自然変換になることを述べています。 上記のように本書では一貫してHaskellのコードが青、Scalaのコードが赤で示されており非常にわかりやすくなっています。一般的な圏論のプログラミングへの応用ではHaskellを例に出されることが多いので、このように併記してある文献はHaskellを学びたいScalaプログラマにとっても嬉しいと思われます。 最後に本書の内容と構成に関してですが、自分は圏論を学びたいプログラマにとっては非常に秀逸だと思いました。少なくとも数学にはあまり自身がないけどプログラミングに圏論を活かしたいプログラマにとっては必要な概念はほぼ本書で触れられていると思います。 以下に本書の目次(一部抜粋)を載せておきます3。また、自分の日本語訳とプログラマとして読んだ方がいい章を5段階評価で★印を付けています。本書を読む参考にしてください。 目次(日本語訳付き) Preface (序文) ★★★★★ 1 Category: The Essence of Composition (圏: 合成の本質) ★★★★★ 1.1 Arrows as Functions (関数としての矢) 1.2 Properties of Composition (合成の特性) 1.3 Composition is the Essence of Programming (合成はプログラミングの本質) 2 Types and Functions (型と関数) ★★★★ 2.1 Who Needs Types? (なぜ型が必要なのか) 2.2 Types Are About Composability (型は合成可能性に関係する) 2.3 What Are Types? (型とは何か？) 2.4 Why Do We Need a Mathematical Model? (なぜ数学モデルが必要なのか？) 2.5 Pure and Dirty Functions (純粋と汚い関数) 2.6 Examples of Types (型の例) 3 Categories Great and Small (圏 大から小まで) ★★ 3.1 No Objects (対象なし) 3.2 Simple Graphs (単純なグラフ) 3.3 Orders (順序) 3.4 Monoid as Set (集合としてのモノイド) 3.5 Monoid as Category (圏としてのモノイド) 4 Kleisli Categories (クライスリ圏) ★★★ 4.1 The Writer Category (Writerの圏) 4.2 Writer in Haskell (HaskellにおけるWriter) 4.3 Kleisli Categories (クライスリ圏) 5 Products and Coproducts (積と余積) ★★★ 5.1 Initial Object (始対象) 5.2 Terminal Object (終対象) 5.3 Duality (双対) 5.4 Isomorphisms (同型) 5.5 Products (積) 5.6 Coproduct (余積) 5.7 Asymmetry (非対称) 6 Simple Algebraic Data Types (単純な代数的データ型) ★★★ 6.1 Product Types (積型) 6.2 Records (レコード型) 6.3 Sum Types (和型) 6.4 Algebra of Types (型の代数) 7 Functors (関手) ★★★★ 7.1 Functors in Programming (プログラミングにおける関手) 7.1.1 The Maybe Functor (Maybe関手) 7.1.2 Equational Reasoning (等式的推論) 7.1.3 Optional (Optional) 7.1.4 Typeclasses (型クラス) 7.1.5 Functor in C++ (C++における関手) 7.1.6 The List Functor (List関手) 7.1.7 The Reader Functor (Reader関手) 7.2 Functors as Containers (コンテナとしての関手) 7.3 Functor Composition (関手の合成) 8 Functoriality (関手っぽいもの) ★★ 8.1 Bifunctors (双関手) 8.2 Product and Coproduct Bifunctors (積と余積双関手) 8.3 Functorial Algebraic Data Types (関手的代数的データ型) 8.4 Functors in C++ (C++における関手) 8.5 The Writer Functor (Writer関手) 8.6 Covariant and Contravariant Functors (共変と反変関手) 8.7 Profunctors (プロ関手) 8.8 The Hom-Functor (ホム関手) 9 Function Types (関数型) ★★★★ 9.1 Universal Construction (普遍的構成) 9.2 Currying (カリー化) 9.3 Exponentials (冪) 9.4 Cartesian Closed Categories (デカルト閉圏/カルテシアン閉圏) 9.5 Exponentials and Algebraic Data Types (冪と代数的データ型) 9.5.1 Zeroth Power (0乗) 9.5.2 Powers of One (1の冪乗) 9.5.3 First Power (1乗) 9.5.4 Exponentials of Sums (和の指数) 9.5.5 Exponentials of Exponentials (冪の指数) 9.5.6 Exponentials over Products (積の指数) 9.6 Curry-Howard Isomorphism (カリー・ハワード同型) 10 Natural Transformations (自然変換) ★★★ 10.1 Polymorphic Functions (多相関数) 10.2 Beyond Naturality (自然性を超えて) 10.3 Functor Category (関手圏) 10.4 2-Categories (2圏) 11 Declarative Programming (宣言的プログラミング) ★★ 12 Limits and Colimits (極限と余極限) ★★ 12.1 Limit as a Natural Isomorphism (極限と自然同型) 12.2 Examples of Limits (極限の例) 12.3 Colimits (余極限) 12.4 Continuity (連続性) 13 Free Monoids (自由モナド) ★★★ 13.1 Free Monoid in Haskell (Haskellにおける自由モノイド) 13.2 Free Monoid Universal Construction (自由モノイドの普遍的構成) 14 Representable Functors (表現可能関手) ★★ 14.1 The Hom Functor (ホム関手) 14.2 Representable Functors (表現可能関手) 15 The Yoneda Lemma (米田の補題) ★★ 15.1 Yoneda in Haskell (Haskellにおける米田) 15.2 Co-Yoneda (余米田) 16 Yoneda Embedding (米田埋め込み) ★★ 16.1 The Embedding (埋め込み) 16.2 Application to Haskell (Haskellへの応用) 16.3 Preorder Example (前順序の例) 16.4 Naturality (自然性) 17 It’s All About Morphisms (結局は射が全て) ★★★ 17.1 Functors (関手) 17.2 Commuting Diagrams (可換図式) 17.3 Natural Transformations (自然変換) 17.4 Natural Isomorphisms (自然同型) 17.5 Hom-Sets (ホム集合) 17.6 Hom-Set Isomorphisms (ホム集合同型) 17.7 Asymmetry of Hom-Sets (ホム集合の非対称) 18 Adjunctions (随伴) ★★ 18.1 Adjunction and Unit/Counit Pair (随伴と単位/余単位) 18.2 Adjunctions and Hom-Sets (随伴とホム集合) 18.3 Product from Adjunction (随伴から積へ) 18.4 Exponential from Adjunction (随伴から冪へ) 19 Free/Forgetful Adjunctions (自由/忘却随伴) ★★ 20 Monads: Programmer’s Definition (モナド: プログラマーの定義) ★★★★ 20.1 The Kleisli Category (クライスリ圏) 20.2 Fish Anatomy (魚の解剖学) 20.3 The do Notation (do記法) 21 Monads and Effects (モナドと作用) ★★★ 21.1 The Problem (問題) 21.2 The Solution (解決策) 21.2.1 Partiality (部分性) 21.2.2 Nondeterminism (非決定性) 21.2.3 Read-Only State (読み取りのみの状態) 21.2.4 Write-Only State (書き取りのみの状態) 21.2.5 State (状態) 21.2.6 Exceptions (例外) 21.2.7 Continuations (継続) 21.2.8 Interactive Input (対話型の入力) 21.2.9 Interactive Output (対話型の出力) 22 Monads Categorically (圏論的なモナド) ★★ 22.1 Monoidal Categories (モノイダル圏) 22.2 Monoid in a Monoidal Category (モノイダル圏におけるモノイド) 22.3 Monads as Monoids (モノイドとしてのモナド) 22.4 Monads from Adjunctions (随伴としてのモナド) 23 Comonads (余モナド) ★ 23.1 Programming with Comonads (余モナドでプログラミング) 23.2 The Product Comonad (積余モナド) 23.3 Dissecting the Composition (合成の解剖) 23.4 The Stream Comonad (ストリーム余モナド) 23.5 Comonad Categorically (圏論的な余モナド) 23.6 The Store Comonad (ストア余モナド) 24 F-Algebras (F代数) ★★★ 24.1 Recursion (再帰) 24.2 Category of F-Algebras (F代数の圏) 24.3 Natural Numbers (自然数) 24.4 Catamorphisms (カタモーフィズム) 24.5 Folds (畳み込み) 24.6 Coalgebras (余代数) 25 Algebras for Monads (モナドの代数) ★★ 25.1 T-algebras (T代数) 25.2 The Kleisli Category (クライスリ圏) 25.3 Coalgebras for Comonads (余モナドの余代数) 25.4 Lenses (レンズ) 26 Ends and Coends (エンドと余エンド) ★ 26.1 Dinatural Transformations (対角化自然変換) 26.2 Ends (エンド) 26.3 Ends as Equalizers (等価子としてのエンド) 26.4 Natural Transformations as Ends (エンドとしての自然変換) 26.5 Coends (余エンド) 26.6 Ninja Yoneda Lemma (忍者米田の補題) 26.7 Profunctor Composition (プロ関手の合成) 27 Kan Extensions (カン拡張) ★ 27.1 Right Kan Extension (右カン拡張) 27.2 Kan Extension as Adjunction (随伴としてのカン拡張) 27.3 Left Kan Extension (左カン拡張) 27.4 Kan Extensions as Ends (エンドとしてのカン拡張) 27.5 Kan Extensions in Haskell (Haskellにおけるカン拡張) 27.6 Free Functor (自由関手) 28 Enriched Categories (豊穣圏) ★ 28.1 Why Monoidal Category? (なぜ豊穣圏なのか？) 28.2 Monoidal Category (モノイダル圏) 28.3 Enriched Category (豊穣圏) 28.4 Preorders (前順序) 28.5 Metric Spaces (距離空間) 28.6 Enriched Functors (豊穣関手) 28.7 Self Enrichment (自己豊穣化) 28.8 Relation to 𝟐-Categories (2圏との関係) 29 Topoi (トポス) ★ 29.1 Subobject Classifier (部分対象分類子) 29.2 Topos (トポス) 29.3 Topoi and Logic (トポスと論理) 30 Lawvere Theories (ローヴェア理論) ★ 30.1 Universal Algebra (普遍代数) 30.2 Lawvere Theories (ローヴェア理論) 30.3 Models of Lawvere Theories (ローヴェア理論のモデル) 30.4 The Theory of Monoids (モノイドの理論) 30.5 Lawvere Theories and Monads (ローヴェア理論とモナド) 30.6 Monads as Coends (余エンドとしてのモナド) 30.7 Lawvere Theory of Side Effects(副作用のローヴェア理論) 31 Monads, Monoids, and Categories (モナドとモノイドと圏) ★★ 31.1 Bicategories (双圏) 31.2 Monads (モナド) 3.2. Scala with Cats次に紹介したいのは「Scala with Cats」です4。CatsはScalaで関数型プログラミングをサポートするためのライブラリで、主に型クラスを提供しています。この型クラスにはモナド(Monad)や関手(Functor)も含まれており、圏論をプログラミングに応用する上で重要な役割を果たしています。 Scala with Cats この本の特色は「型チャート」が豊富に載っていることです。Scalaの型は圏論においては対象や関手やモナドだったり様々ですが、それらの変換の様子が図に表されているので非常に分かりやすくなっています。以下の引用は反変関手の型チャートになります。 本書の構成で秀逸なのは、型クラスの説明に留まらず「Case Study(事例)」と「Solution(答え)」が載っていることです。Case Studyには、具体的のどのようなケースで型クラスを使えばいいかが載っています。「Solution」には、各章に豊富に散りばめられた「Excercise」の答えが載っています。従って本書を読むことで圏論の一部を「実務」でも応用できるようになると思います。 以下に本書の目次(一部抜粋)を載せておきます5。また、自分の日本語訳付けていますが・・・途中で力尽きました。本書を読む参考にしてください。 目次(日本語訳付き) 1 Introduction (はじめに) 1.1 Anatomy of a Type Class (型クラスの解剖学) 1.1.1 The Type Class (型クラス) 1.1.2 Type Class Instances (型クラスインスタンス) 1.1.3 Type Class Interfaces (型クラスインタフェース) 1.2 Working with Implicits (暗黙と働く) 1.2.1 Packaging Implicits (暗黙のパッケージ) 1.2.2 Implicit Scope (暗黙のスコープ) 1.2.3 Recursive Implicit Resolution (再帰的な暗黙の解決) 1.3 Exercise: Printable Library (練習: 印字可能ライブラリ) 1.4 Meet Cats (Catsとの邂逅) 1.4.1 Importing Type Classes (型クラスのインポート) 1.4.2 Importing Default Instances (デフォルトインスタンスのインポート) 1.4.3 Importing Interface Syntax (インタフェース構文のインポート) 1.4.4 Importing All The Things! (全てをインポート!) 1.4.5 Defining Custom Instances (カスタムインスタンスを定義する) 1.5 Example: Eq (例: Eq) 1.5.1 Equality, Liberty, and Fraternity (等値性、自由、友愛) 1.5.2 Comparing Ints (Intの比較) 1.5.3 Comparing Options (Optionの比較) 1.5.4 Comparing Custom Types (カスタム型の比較) 1.6 Controlling Instance Selection (インスタンス選択の制御) 1.6.1 Variance (変位) 2 Monoids and Semigroups (モノイドと半群) 2.1 Definition of a Monoid (モノイドの定義) 2.2 Definition of a Semigroup (半群の定義) 2.3 Exercise: The Truth About Monoids (モナドの真実) 2.4 Exercise: All Set for Monoids\u001d (モノイドの全ての集合) 2.5 Monoids in Cats (Catsにおけるモノイド) 2.5.1 The Monoid Type Class (モノイド型クラス) 2.5.2 Monoid Instances (モノイドインタンス) 2.5.3 Monoid Syntax (モノイド構文) 2.6 Applications of Monoids (モノイドの応用) 2.6.1 Big Data (ビッグデータ) 2.6.2 Distributed Systems (分散システム) 2.6.3 Monoids in the Small (小さな世界におけるモノイド) 3 Functors (関手) 3.1 Examples of Functors (関手の例) 3.2 More Examples of Functors (関手のさらなる例) 3.3 Definition of a Functor (関手の定義) 3.4 Aside: Higher Kinds and Type Constructors (寄り道: 高カインドと型コンストラクタ) 3.5 Functors in Cats (Catsにおける関手) 3.5.1 The Functor Type Class (関手型クラス) 3.5.2 Functor Syntax (関手構文) 3.5.3 Instances for Custom Types (カスタム型のインスタンス) 3.6 Contravariant and Invariant Functors (反変・不変関手) 3.6.1 Contravariant Functors and the contramap Method (反変関手とcontramapメソッド) 3.6.2 Invariant functors and the imap method(不変関手とimap) 3.7 Contravariant and Invariant in Cats (CatsにおけるContravariantとInvariant) 3.7.1 Contravariant in Cats (CatsにおけるContravariant) 3.7.2 Invariant in Cats (CatsにおけるInvariant) 3.8 Aside: Partial Unification (寄り道: 部分的ユニフィケーション) 3.8.1 Unifying Type Constructors (型コンストラクタの結合) 3.8.2 Left-to-Right Elimination (左から右への削除) 4 Monads (モナド) 4.1 What is a Monad? (モナドとは何か) 4.1.1 Definition of a Monad (モナドの定義) 4.2 Monads in Cats (Catsにおけるモナド) 4.2.1 The Monad Type Class(モナド型クラス) 4.2.2 Default Instances(デフォルトインスタンス) 4.2.3 Monad Syntax(モナド構文) 4.3 The Identity Monad(恒等モナド) 4.4 Either (Either) 4.4.1 Left and Right Bias (左右バイアス) 4.4.2 Creating Instances (インスタンスの作成) 4.4.3 Transforming Eithers (Eitherへの変換) 4.4.4 Error Handling (エラーハンドリング) 4.5 Aside: Error Handling and MonadError (寄り道: エラーハンドリングとMonadError) 4.5.1 The MonadError Type Class (MonadError型クラス) 4.5.2 Raising and Handling Errors (エラーの投げ方とハンドリングの仕方) 4.5.3 Instances of MonadError (MonadErrorのインスタンス) 4.6 The Eval Monad (Evalモナド) 4.6.1 Eager, Lazy, Memoized, Oh My! (熱心、怠惰、メモ化、オッ!) 4.6.2 Eval’s Models of Evaluation (Evalの評価モデル) 4.6.3 Eval as a Monad (モナドとしてのEval) 4.6.4 Trampolining and Eval.defer (トランポリンとEval.defer) 4.7 The Writer Monad (Writerモナド) 4.7.1 Creating and Unpacking Writers (Writerの作成と開封) 4.7.2 Composing and Transforming Writers ((Writerの合成と変換)) 4.8 The Reader Monad (Readerモナド) 4.8.1 Creating and Unpacking Readers (Readerの作成と開封) 4.8.2 Composing Readers (Readerの合成) 4.8.3 Exercise: Hacking on Readers (練習: Readerでハッキング) 4.8.4 When to Use Readers? (いつReaderを使うか？) 4.9 The State Monad (Stateモナド) 4.9.1 Creating and Unpacking State (Stateの作成と開封) 4.9.2 Composing and Transforming State (Stateの合成と変換) 4.10 Defining Custom Monads (カスタムモナドの定義) 5 Monad Transformers (モナド変換子) 5.1 Exercise: Composing Monads (練習: モナドの合成) 5.2 A Transformative Example (変換的な例) 5.3 Monad Transformers in Cats (Catsにおけるモナド変換子) 5.3.1 The Monad Transformer Classes (モナド変換子クラス) 5.3.2 Building Monad Stacks (モナドスタックの構築) 5.3.3 Constructing and Unpacking Instances (インスタンスの構成と開封) 5.3.4 Default Instances (デフォルトインスタンス) 5.3.5 Usage Patterns (利用パターン) 6 Semigroupal and Applicative (半群とアプリカティブ) 6.1 Semigroupal (Semigroupal) 6.1.1 Joining Two Contexts (2つのコンテキストの結合) 6.1.2 Joining Three or More Contexts (3つ以上のコンテキストの結合) 6.2 Apply Syntax (Apply構文) 6.2.1 Fancy Functors and Apply Syntax (面白いFunctorとApply構文) 6.3 Semigroupal Applied to Different Types (Semigroupalの異なる型への適用) 6.3.1 Semigroupal Applied to Monads (Semigroupalのモナドへの適用) 6.4 Validated (Validated) 6.4.1 Creating Instances of Validated (Validatedのインスタンス作成) 6.4.2 Combining Instances of Validated (Validatedのインスタンス結合) 6.4.3 Methods of Validated (Validatedのメソッド) 6.5 Apply and Applicative (ApplyとApplicative) 6.5.1 The Hierarchy of Sequencing Type Classes (列型クラスの階層) 7 Foldable and Traverse (FoldableとTraverse) 7.1 Foldable (Foldable) 7.1.1 Folds and Folding 7.1.2 Exercise: Reflecting on Folds 7.1.3 Exercise: Scaf-fold-ing Other Methods 7.1.4 Foldable in Cats 7.2 Traverse 7.2.1 Traversing with Futures 7.2.2 Traversing with Applicatives 7.2.3 Traverse in Cats 8 Case Study: Testing Asynchronous Code (事例: 非同期コードのテスト) 8.1 Abstracting over Type Constructors 8.2 Abstracting over Monads 9 Case Study: Map-Reduce (事例: Map-Reduce) 9.1 Parallelizing map and fold 9.2 Implementing foldMap 9.3 Parallelising foldMap 9.3.1 Futures, Thread Pools, and Execu􀦞onContexts 9.3.2 Dividing Work 9.3.3 Implementing parallelFoldMap 9.3.4 parallelFoldMap with more Cats 10 Case Study: Data Validation (事例: データバリデーション) 10.1 Sketching the Library Structure 10.2 The Check Datatype 10.3 Basic Combinators 10.4 Transforming Data 10.4.1 Predicates 10.4.2 Checks 10.5 Kleislis 11 Case Study: CRDTs (事例: CRDT) 11.1 Eventual Consistency 11.2 The GCounter 11.2.1 Simple Counters 11.2.2 GCounters 11.3 Generalisation 11.3.1 Implementation 11.4 Abstracting GCounter to a Type Class 11.5 Abstracting a Key Value Store 3.3. 猫番最後に紹介したいのが「猫番」です。紹介する中では唯一の日本語で読める文献です。現在は「O日目」から「17日目」まで公開されており、著者が「Cats」を使って理解していく過程が記録されています。後半はより「圏論」の説明に移っています。 猫番 「猫番」は前二つの文献と比べ非常に自由に書かれていて、独特な構成になっています。ただそれが不思議と読みにくいという訳でもなく、著者と一緒に「Cats」や「圏論」を旅をしている気分になれるところがこの文献の面白いところです。もっと気楽に圏論に触れてみたい人や圏論の雰囲気を味わってみたい方はこの文献から読むといいかもしれません。 4. プログラマが圏論で学んでおいたほうがよい概念とりあえず「Category Theory for Programmers Scala Edition」に出てきた概念の中で、プログラマが学んでおいた方が良いと思うものを以下に分類してみました6。これはあくまで数学が苦手な圏論入門者である自分の私見です。 必ず学んでおきたい 圏、関手、自然変換 集合の圏(Set)、圏の圏(Cat)、関手圏 半群、モノイド モナド、クライスリ圏 普遍的構成（普遍性） できれば学んでおきたい 積、余積 同型 双対 冪、デカルト閉圏 モノイダル圏 自由モノイド、自由モナド F代数、T代数 余力があれば学んでおきたい ホム関手、表現可能関手 米田の補題、米田埋め込み 極限と余極限 随伴 カリー＝ハワード同型 興味があれば学んだ方が良い エンド カン拡張 ← 全ての概念 豊穣圏 トポス ローヴェア理論 圏論は非常に多くの概念が出てくるので無理せず少しずつ消化していくのが良いと思われます。自分が圏論に興味を持ち始めたのは「モナド」に出会ってからでした。以下の言葉の意味を知りたくて圏論を始めたのがきっかけです。 モナドは単なる自己関手の圏におけるモノイド対象だよ。何か問題でも？ フィリップ・ワドラー この言葉の意味は恐らく「必ず学んでおきたい」まで理解できればなんとなく意味が理解できるようになると思われます。さらに圏論にはパワーワード「全ての概念はKan拡張である」7があって、いつか理解できればいいなと思っています。 5. まとめ本記事ではプログラマがなぜ圏論を学ぶべきかを説明し、Scalaプログラマが圏論を学ぶ上で有用な以下の３つの文献を紹介しました。 Category Theory for Programmers Scala Edition Scala with Cats 猫番 本記事がScalaで圏論を学んでみたい方の一助になれば幸いです。 6. もっと圏論を学びたい人向けのオンラインで読めるオススメ資料残念ながら本記事の趣旨には合いませんでしたが、プログラマが圏論を学ぶ上でぜひオススメしたい資料です。 プログラマーのための圏論 説明がHaskellベースですが非常に丁寧で分かりやすいです 上、中、下 物理学者のための圏論入門 物理学者ではなくても圏論の基本的な概念を理解できる非常にオススメの資料です 特に普遍射の説明が秀逸で、会社組織の擬えての説明がツボりました 圏論によるプログラミングと論理 灘校パソコン研究部の部誌(2013年)に掲載されていたものです 普通に書店に並んでいてもおかしくないボリュームとクオリティです 圏論だけでなく数学やコンピュータサイエンスの基礎も補完しています 圏論 | 壱大整域 圏論の概念を本気で理解したくなったらここに駆け込んでください ただしストイックな数学スタイルで書かれているのでプログラマには少し辛いかもしれません1.ときどき証明をつけずに「簡単(自明)なので証明は読者に委ねる」というパワーワードが記載されています。もちろんプログラマにとって「簡単」ではありません・・・ ↩2.実際には3番と4番の図の間に逆射を持っていた場合の図が挟まっています。 ↩3.掲載している目次は、「Conclusion」、「Challenges」、「Bibliography」等の見出しは削っております。これは本書の概要を知る手がかりにはならないと考えたからです。正しい目次は直接文献をご確認ください。 ↩4.この本はもともと「Scalaz」という別のライブラリ向けに書かれていたものが、Cats向けに書き直されたものです。書き直された当初は「Advanced Scala with Cats」という名前で有償でしたが、無償化されるにあたって「Scala with Cats」という名称に変更され可愛らしい猫の表紙が付きました。 ↩5.掲載している目次は、「Summary」、「Excercise」、「Solution」等の見出しは削っております。これは本書の概要を知る手がかりにはならないと考えたからです。正しい目次は直接文献をご確認ください。 ↩6.ここで列挙する概念は一般的な圏論に登場する概念から選択しています。プログラミングの文脈で登場する代数的データ型や型クラスは含まれていません。 ↩7.参考文献: 全ての概念はKan拡張である、とは何か - algebraic dialy | 壱大整域 ↩ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/cats-cats-cats/2019/07/20/learning-category-theory/"}],"tags":[{"name":"Keyboard","slug":"Keyboard","link":"/cats-cats-cats/tags/Keyboard/"},{"name":"Keymap","slug":"Keymap","link":"/cats-cats-cats/tags/Keymap/"},{"name":"Git","slug":"Git","link":"/cats-cats-cats/tags/Git/"},{"name":"Hexo","slug":"Hexo","link":"/cats-cats-cats/tags/Hexo/"},{"name":"Web","slug":"Web","link":"/cats-cats-cats/tags/Web/"},{"name":"npm","slug":"npm","link":"/cats-cats-cats/tags/npm/"},{"name":"oEmbed","slug":"oEmbed","link":"/cats-cats-cats/tags/oEmbed/"},{"name":"html5","slug":"html5","link":"/cats-cats-cats/tags/html5/"},{"name":"Book","slug":"Book","link":"/cats-cats-cats/tags/Book/"},{"name":"Event","slug":"Event","link":"/cats-cats-cats/tags/Event/"},{"name":"Qiita","slug":"Qiita","link":"/cats-cats-cats/tags/Qiita/"},{"name":"ErgoDash","slug":"ErgoDash","link":"/cats-cats-cats/tags/ErgoDash/"},{"name":"k8s","slug":"k8s","link":"/cats-cats-cats/tags/k8s/"},{"name":"Container","slug":"Container","link":"/cats-cats-cats/tags/Container/"},{"name":"GCP","slug":"GCP","link":"/cats-cats-cats/tags/GCP/"},{"name":"Go","slug":"Go","link":"/cats-cats-cats/tags/Go/"},{"name":"gRPC","slug":"gRPC","link":"/cats-cats-cats/tags/gRPC/"},{"name":"AdventCalendar","slug":"AdventCalendar","link":"/cats-cats-cats/tags/AdventCalendar/"},{"name":"MachineLearning","slug":"MachineLearning","link":"/cats-cats-cats/tags/MachineLearning/"},{"name":"Scala","slug":"Scala","link":"/cats-cats-cats/tags/Scala/"},{"name":"Dotty","slug":"Dotty","link":"/cats-cats-cats/tags/Dotty/"},{"name":"Ruby","slug":"Ruby","link":"/cats-cats-cats/tags/Ruby/"},{"name":"Jupyter","slug":"Jupyter","link":"/cats-cats-cats/tags/Jupyter/"},{"name":"Algorithm","slug":"Algorithm","link":"/cats-cats-cats/tags/Algorithm/"},{"name":"Mind","slug":"Mind","link":"/cats-cats-cats/tags/Mind/"},{"name":"CategoryTheory","slug":"CategoryTheory","link":"/cats-cats-cats/tags/CategoryTheory/"},{"name":"Cats","slug":"Cats","link":"/cats-cats-cats/tags/Cats/"}],"categories":[{"name":"DIY","slug":"DIY","link":"/cats-cats-cats/categories/DIY/"},{"name":"Tech","slug":"Tech","link":"/cats-cats-cats/categories/Tech/"},{"name":"Keyboard","slug":"DIY/Keyboard","link":"/cats-cats-cats/categories/DIY/Keyboard/"},{"name":"Miscellaneous","slug":"Tech/Miscellaneous","link":"/cats-cats-cats/categories/Tech/Miscellaneous/"},{"name":"Tool","slug":"Tech/Tool","link":"/cats-cats-cats/categories/Tech/Tool/"},{"name":"Web","slug":"Tech/Web","link":"/cats-cats-cats/categories/Tech/Web/"},{"name":"Container","slug":"Tech/Container","link":"/cats-cats-cats/categories/Tech/Container/"},{"name":"Language","slug":"Tech/Language","link":"/cats-cats-cats/categories/Tech/Language/"},{"name":"Programming","slug":"Tech/Programming","link":"/cats-cats-cats/categories/Tech/Programming/"},{"name":"Engineering","slug":"Tech/Engineering","link":"/cats-cats-cats/categories/Tech/Engineering/"}]}